{
  "repo": {
    "owner": "octodemo-db",
    "repo": "simple-java-project"
  },
  "head": {
    "ageInSeconds": 1436,
    "scan": {
      "ref": "refs/heads/main",
      "commit_sha": "8170e2f69f9d7c0e0f460d0b3fbb081fb6b15772",
      "analysis_key": ".github/workflows/code_quality_pack_expriment.yml:scan",
      "environment": "{}",
      "category": "sonar-like",
      "error": "",
      "created_at": "2023-10-02T13:15:57Z",
      "results_count": 51,
      "rules_count": 142,
      "id": 124915631,
      "url": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/analyses/124915631",
      "sarif_id": "d2817ace-6125-11ee-8511-4b234b72de48",
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.14.6"
      },
      "deletable": true,
      "warning": ""
    },
    "sarif": {
      "runs": [
        {
          "artifacts": [
            {
              "location": {
                "index": 0,
                "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
              }
            },
            {
              "location": {
                "index": 1,
                "uri": "src/main/java/com/github/demo/model/Book.java"
              }
            },
            {
              "location": {
                "index": 2,
                "uri": "src/main/java/com/github/demo/DemoServer.java"
              }
            },
            {
              "location": {
                "index": 3,
                "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
              }
            },
            {
              "location": {
                "index": 4,
                "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
              }
            },
            {
              "location": {
                "index": 5,
                "uri": "src/main/java/com/github/demo/service/BookService.java"
              }
            },
            {
              "location": {
                "index": 6,
                "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
              }
            },
            {
              "location": {
                "index": 7,
                "uri": "src/main/java/com/github/demo/service/BookUtils.java"
              }
            },
            {
              "location": {
                "index": 8,
                "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
              }
            },
            {
              "location": {
                "index": 9,
                "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
              }
            },
            {
              "location": {
                "index": 10,
                "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
              }
            }
          ],
          "automationDetails": {
            "id": "sonar-like/"
          },
          "conversion": {
            "tool": {
              "driver": {
                "name": "GitHub Code Scanning"
              }
            }
          },
          "results": [
            {
              "correlationGuid": "f82862a7-2f7e-46b3-98c5-352af6a56167",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 20,
                      "startColumn": 20,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This method overrides [HttpServlet.doGet](1); it is advisable to add an Override annotation."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3c367b5f91bcd568:1"
              },
              "properties": {
                "github/alertNumber": 34,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/34"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "HttpServlet.doGet"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "file:/home/runner/.m2/repository/org/eclipse/jetty/toolchain/jetty-servlet-api/4.0.5/jetty-servlet-api-4.0.5.jar/javax/servlet/http/HttpServlet.class"
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/missing-override-annotation",
                "toolComponent": {
                  "index": 0
                },
                "index": 65
              },
              "ruleId": "java/missing-override-annotation"
            },
            {
              "correlationGuid": "1cff28ce-7445-413b-97f3-214cb8afda17",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 29,
                      "endLine": 45,
                      "startColumn": 19,
                      "startLine": 45
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b9437607b3c632b3:1"
              },
              "properties": {
                "github/alertNumber": 8,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/8"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "c1c95d40-a8c7-4c14-b317-196886efc8dd",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 20,
                      "startColumn": 24,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "44494a2dbdb9a1ce:1"
              },
              "properties": {
                "github/alertNumber": 3,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/3"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d73b5f2f-eaa7-485b-8636-bf3b85598d68",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 23,
                      "startColumn": 12,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "9b703bd20ed7eb58:1"
              },
              "properties": {
                "github/alertNumber": 11,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/11"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "705359b4-dce4-4315-b9f0-bc62b15253c2",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 18,
                      "startColumn": 12,
                      "startLine": 18
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "380395c0f8f81c59:1"
              },
              "properties": {
                "github/alertNumber": 12,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/12"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "042c0efb-240d-4874-a830-ed198ef1f32d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "518b735ee3a80e78:1"
              },
              "properties": {
                "github/alertNumber": 15,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/15"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d5f0a858-ddc8-41c7-8b88-506a0d62355e",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "97e33a1f8c216390:1"
              },
              "properties": {
                "github/alertNumber": 6,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/6"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "07a69cbc-3036-4b70-8667-0e339ea1ca24",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 10,
                      "startColumn": 17,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3a1cd0254b7cbcd0:1"
              },
              "properties": {
                "github/alertNumber": 4,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/4"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "bc8d45fa-9bb9-4f4d-a51c-fdfee27914a6",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 7,
                      "startColumn": 12,
                      "startLine": 7
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5cf2232a276f9ce0:1"
              },
              "properties": {
                "github/alertNumber": 5,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/5"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "e9a29948-eb3b-4f4c-a167-99949edda617",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 18,
                      "endLine": 14,
                      "startColumn": 10,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b3b40cc112193332:1"
              },
              "properties": {
                "github/alertNumber": 7,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/7"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "f17b2441-342a-4f20-982d-3109b4392824",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 12,
                      "startColumn": 16,
                      "startLine": 12
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "dae1616c3d3d6eb1:1"
              },
              "properties": {
                "github/alertNumber": 9,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/9"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "8ee15b28-fc96-4f76-b21f-95e97bec1f7f",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 22,
                      "endLine": 10,
                      "startColumn": 16,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3360404f8d27224b:1"
              },
              "properties": {
                "github/alertNumber": 10,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/10"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "4c088064-061d-41c3-963f-5b7b011073cc",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "c7e3f380813e4f4d:1"
              },
              "properties": {
                "github/alertNumber": 19,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/19"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "949c13e2-f5b4-449d-8c31-bb6d4c4fc050",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 27,
                      "endLine": 75,
                      "startColumn": 20,
                      "startLine": 75
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "468b77760bb20c1b:1"
              },
              "properties": {
                "github/alertNumber": 13,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/13"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "cf525e6a-2a50-4ef7-ad63-a5896d22a257",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 50,
                      "startColumn": 12,
                      "startLine": 50
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bfbc8cdb38ca8cba:1"
              },
              "properties": {
                "github/alertNumber": 14,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/14"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "00a746e2-d9b3-4acc-a7b2-7db25f22564c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 23,
                      "startColumn": 23,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "d3826bb5326123f5:1"
              },
              "properties": {
                "github/alertNumber": 21,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/21"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d9820c6e-063e-4473-9897-c849466daacb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 46,
                      "startColumn": 12,
                      "startLine": 46
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "81f57cf77b6c5b72:1"
              },
              "properties": {
                "github/alertNumber": 16,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/16"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d06feebf-e295-4519-aff1-d1b6b099eddb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 11,
                      "startColumn": 12,
                      "startLine": 11
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5a7395da5f6169ca:1"
              },
              "properties": {
                "github/alertNumber": 22,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/22"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "e69e66a9-472e-4542-ae28-c8ceeb281dd7",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 7,
                      "uri": "src/main/java/com/github/demo/service/BookUtils.java"
                    },
                    "region": {
                      "endColumn": 44,
                      "endLine": 10,
                      "startColumn": 30,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "f20fd2ff4a3e0fe0:1"
              },
              "properties": {
                "github/alertNumber": 20,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/20"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "2ff8ae78-8726-4957-897d-96e7ad53a6cd",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
                    },
                    "region": {
                      "endColumn": 32,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "569e915f9b444017:1"
              },
              "properties": {
                "github/alertNumber": 17,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/17"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "23f241fd-95ef-40bb-a5e4-6636bcdbac70",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
                    },
                    "region": {
                      "endColumn": 32,
                      "endLine": 10,
                      "startColumn": 12,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "8f5181d5fcc3b37c:1"
              },
              "properties": {
                "github/alertNumber": 18,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/18"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "b9b6c229-461a-4a72-9278-7757ee1cf9dc",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 9,
                      "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
                    },
                    "region": {
                      "endColumn": 26,
                      "endLine": 15,
                      "startColumn": 12,
                      "startLine": 15
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "433ec78c10747a8e:1"
              },
              "properties": {
                "github/alertNumber": 24,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/24"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "81ccf8b9-f94e-4815-808f-cac471f7b93c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 31,
                      "startColumn": 12,
                      "startLine": 31
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "ca136ea197a5612d:1"
              },
              "properties": {
                "github/alertNumber": 23,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/23"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "c1c68b5d-98f6-4417-b406-fce4c74b01a1",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 17,
                      "startColumn": 12,
                      "startLine": 17
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "2ee210f8987e4d4c:1"
              },
              "properties": {
                "github/alertNumber": 25,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/25"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "60793fe3-0c3c-4d8f-be92-cbb7daebcb36",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 24,
                      "endLine": 16,
                      "startColumn": 14,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "940645f2719e526c:1"
              },
              "properties": {
                "github/alertNumber": 26,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/26"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "27cc4208-8221-4ebf-86cd-21e22d9828f8",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 30,
                      "endLine": 8,
                      "startColumn": 18,
                      "startLine": 8
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "1ffb2d89569dd73a:1"
              },
              "properties": {
                "github/alertNumber": 28,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/28"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "e20cc37f-d6de-4c1c-935b-f2ae59ca5685",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 5,
                      "startColumn": 14,
                      "startLine": 5
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "394a65fc17100873:1"
              },
              "properties": {
                "github/alertNumber": 27,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/27"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "156ed08b-b8ba-4393-b7b1-fc5741bd69c0",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 30,
                      "endLine": 20,
                      "startColumn": 14,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "ea764871e1e011c:1"
              },
              "properties": {
                "github/alertNumber": 29,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/29"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "d790dfe6-ec65-4db4-8825-631c6b248a0b",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 7,
                      "startColumn": 14,
                      "startLine": 7
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "13d2f681f7702725:1"
              },
              "properties": {
                "github/alertNumber": 30,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/30"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "cf995fba-d367-4b79-9aed-70f38fcd909d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 7,
                      "uri": "src/main/java/com/github/demo/service/BookUtils.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 8,
                      "startColumn": 14,
                      "startLine": 8
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "8be943fa16995f8b:1"
              },
              "properties": {
                "github/alertNumber": 31,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/31"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "cd2dc000-2e6d-48f1-ba7e-5c720fde6723",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 9,
                      "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 11,
                      "startColumn": 14,
                      "startLine": 11
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "d9c3924db2087e03:1"
              },
              "properties": {
                "github/alertNumber": 33,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/33"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "6851edbc-e00b-4be7-8da4-c66ea69f191d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 23,
                      "startColumn": 14,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "63c211b65be41211:1"
              },
              "properties": {
                "github/alertNumber": 32,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/32"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "8e16bd59-3fe7-4724-8432-da807f586cc9",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 5,
                      "startColumn": 14,
                      "startLine": 5
                    }
                  }
                }
              ],
              "message": {
                "text": "The class BrokenModel is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "394a65fc17100873:1"
              },
              "properties": {
                "github/alertNumber": 2,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/2"
              },
              "rule": {
                "id": "java/dead-class",
                "toolComponent": {
                  "index": 0
                },
                "index": 17
              },
              "ruleId": "java/dead-class"
            },
            {
              "correlationGuid": "051815fe-076c-40bb-a811-e91f68f164d9",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 53,
                      "startColumn": 17,
                      "startLine": 53
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setCover is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "51ebf0292ad0eb0f:1"
              },
              "properties": {
                "github/alertNumber": 35,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/35"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "bcdba47b-9037-4bc7-be9c-782532f6f617",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 29,
                      "endLine": 45,
                      "startColumn": 19,
                      "startLine": 45
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getDetails is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b9437607b3c632b3:1"
              },
              "properties": {
                "github/alertNumber": 36,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/36"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "fb2525e5-6942-4556-9fc6-bedc92dfb1b7",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 26,
                      "endLine": 41,
                      "startColumn": 17,
                      "startLine": 41
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setAuthor is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "35f91ee75930f986:1"
              },
              "properties": {
                "github/alertNumber": 37,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/37"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "84e16bf8-7b0b-406f-8c59-f34673d73932",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 33,
                      "startColumn": 17,
                      "startLine": 33
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setTitle is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5887a7b23df0e772:1"
              },
              "properties": {
                "github/alertNumber": 38,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/38"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "c2c89122-7d5b-4e08-b8c6-429a42346ccb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 18,
                      "startColumn": 12,
                      "startLine": 18
                    }
                  }
                }
              ],
              "message": {
                "text": "The method Book is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "380395c0f8f81c59:1"
              },
              "properties": {
                "github/alertNumber": 39,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/39"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "4cb66fac-06a4-4e14-a838-0b1d6120950c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "The method Book is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "518b735ee3a80e78:1"
              },
              "properties": {
                "github/alertNumber": 40,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/40"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "1a908b0f-216f-48e3-b11c-54bfbcdff3c5",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "The method destroy is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "97e33a1f8c216390:1"
              },
              "properties": {
                "github/alertNumber": 41,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/41"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "05c03252-d66b-4bb0-8a8f-ca3ae0b2180f",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 12,
                      "startColumn": 16,
                      "startLine": 12
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getBooksByTitle is only used from dead code originating at [searchBooks](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "dae1616c3d3d6eb1:1"
              },
              "properties": {
                "github/alertNumber": 45,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/45"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "searchBooks"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "b387c0d5-04fe-4732-ad03-f642b60dae60",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "message": {
                "text": "The method searchBooks is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "c7e3f380813e4f4d:1"
              },
              "properties": {
                "github/alertNumber": 46,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/46"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "968a7768-23af-48bc-9571-cdb40fb3836a",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 24,
                      "endLine": 148,
                      "startColumn": 17,
                      "startLine": 148
                    }
                  }
                }
              ],
              "message": {
                "text": "The method destroy is only used from dead code originating at [destroy](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bcf960f7da0b54d3:1"
              },
              "properties": {
                "github/alertNumber": 42,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/42"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "destroy"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "a758429c-90f8-4baa-8157-e4ea6c7ecc7d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 38,
                      "endLine": 107,
                      "startColumn": 23,
                      "startLine": 107
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getBooksByTitle is only used from dead code originating at [searchBooks](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "37d0497d51ef382c:1"
              },
              "properties": {
                "github/alertNumber": 43,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/43"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "searchBooks"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "4db6fd4a-5777-4ea5-9e95-d81c998bcae8",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 46,
                      "startColumn": 12,
                      "startLine": 46
                    }
                  }
                }
              ],
              "message": {
                "text": "The method BookDatabaseImpl is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "81f57cf77b6c5b72:1"
              },
              "properties": {
                "github/alertNumber": 44,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/44"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "e35d28b9-ea37-4328-83b6-110b0e60be26",
              "level": "warning",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 36,
                      "endLine": 29,
                      "startColumn": 25,
                      "startLine": 29
                    }
                  }
                }
              ],
              "message": {
                "text": "This field is in a serializable class, but is not serializable itself because BookService is not serializable."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bd202652310c17e5:1"
              },
              "properties": {
                "github/alertNumber": 50,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/50"
              },
              "rule": {
                "id": "java/non-serializable-field",
                "toolComponent": {
                  "index": 0
                },
                "index": 74
              },
              "ruleId": "java/non-serializable-field"
            },
            {
              "correlationGuid": "49dc577b-5a00-4767-9bee-2fba011ac240",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 6,
                      "startColumn": 1,
                      "startLine": 6
                    }
                  }
                }
              ],
              "message": {
                "text": "It is advisable to make imports explicit."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "aad9b6b129b12fef:1"
              },
              "properties": {
                "github/alertNumber": 51,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/51"
              },
              "rule": {
                "id": "java/implicit-import",
                "toolComponent": {
                  "index": 0
                },
                "index": 37
              },
              "ruleId": "java/implicit-import"
            },
            {
              "correlationGuid": "fcc48a6d-4046-473c-ab1f-74e8f64d278b",
              "level": "warning",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 85,
                      "endLine": 52,
                      "startColumn": 32,
                      "startLine": 52
                    }
                  }
                }
              ],
              "message": {
                "text": "The idiom getClass().getResource() is unsafe for classes that may be extended."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5d23010d6c3bf340:1"
              },
              "properties": {
                "github/alertNumber": 52,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/52"
              },
              "rule": {
                "id": "java/unsafe-get-resource",
                "toolComponent": {
                  "index": 0
                },
                "index": 122
              },
              "ruleId": "java/unsafe-get-resource"
            },
            {
              "correlationGuid": "e65be450-9cd5-427f-a0b7-859d7c91fb95",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 38,
                      "endLine": 224,
                      "startColumn": 9,
                      "startLine": 224
                    }
                  }
                }
              ],
              "message": {
                "text": "This local variable shadows field [connection](1), which is not used in method [getConnection](2)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "a263339cb745e0bc:1"
              },
              "properties": {
                "github/alertNumber": 53,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/53"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "connection"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 31,
                      "startColumn": 24,
                      "startLine": 31
                    }
                  }
                },
                {
                  "id": 2,
                  "message": {
                    "text": "getConnection"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 37,
                      "endLine": 223,
                      "startColumn": 24,
                      "startLine": 223
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/local-shadows-field-unused",
                "toolComponent": {
                  "index": 0
                },
                "index": 49
              },
              "ruleId": "java/local-shadows-field-unused"
            },
            {
              "correlationGuid": "2cf4d6a6-bf1b-4ee0-9170-93ba7c437005",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 41,
                      "endLine": 64,
                      "startColumn": 13,
                      "startLine": 64
                    }
                  }
                }
              ],
              "message": {
                "text": "Assignment to parameters may decrease code readability."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "27ae0193b728089b:1"
              },
              "properties": {
                "github/alertNumber": 54,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/54"
              },
              "rule": {
                "id": "java/assignment-to-parameter",
                "toolComponent": {
                  "index": 0
                },
                "index": 4
              },
              "ruleId": "java/assignment-to-parameter"
            },
            {
              "correlationGuid": "28bbe2ed-55ee-4447-95de-473fc6153924",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 3,
                      "startColumn": 1,
                      "startLine": 3
                    }
                  }
                }
              ],
              "message": {
                "text": "Import of 'import List' is not used."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "7ae9ae674ca3b8f5:1"
              },
              "properties": {
                "github/alertNumber": 55,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/55"
              },
              "rule": {
                "id": "java/unused-import",
                "toolComponent": {
                  "index": 0
                },
                "index": 126
              },
              "ruleId": "java/unused-import"
            }
          ],
          "tool": {
            "driver": {
              "name": "CodeQL",
              "semanticVersion": "2.14.6"
            },
            "extensions": [
              {
                "name": "codeql/java-queries",
                "rules": [
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'Math.abs' to find the absolute value of a randomly generated integer is not guaranteed to return a non-negative integer."
                    },
                    "help": {
                      "markdown": "# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n",
                      "text": "# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n"
                    },
                    "id": "java/abs-of-random",
                    "name": "java/abs-of-random",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/BadAbsOfRandom.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Incorrect absolute value of random number"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A cast from an abstract collection to a concrete implementation type makes the code brittle."
                    },
                    "help": {
                      "markdown": "# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n",
                      "text": "# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
                    },
                    "id": "java/abstract-to-concrete-cast",
                    "name": "java/abstract-to-concrete-cast",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/AbstractToConcreteCollection.ql",
                      "tags": [
                        "external/cwe/cwe-485",
                        "maintainability",
                        "modularity",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Cast from abstract to concrete collection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Extending or implementing an annotation is unlikely to be what the programmer intends."
                    },
                    "help": {
                      "markdown": "# Annotation is extended or implemented\nAlthough an annotation type is a special kind of interface that can be implemented by a concrete class, this is not its intended use. It is more likely that an annotation type should be used to annotate a class.\n\n\n## Recommendation\nEnsure that any annotations are used to annotate a class, unless they are really supposed to be extended or implemented by the class.\n\n\n## Example\nIn the following example, the annotation `Deprecated` is implemented by the class `ImplementsAnnotation`.\n\n\n```java\npublic abstract class ImplementsAnnotation implements Deprecated {\n\t// ...\n}\n```\nThe following example shows the intended use of annotations: to annotate the class `ImplementsAnnotationFix`.\n\n\n```java\n@Deprecated\npublic abstract class ImplementsAnnotationFix {\n\t// ...\n}\n```\n\n## References\n* Java Language Specification: [Annotation Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6).\n* The Java Tutorials: [Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n",
                      "text": "# Annotation is extended or implemented\nAlthough an annotation type is a special kind of interface that can be implemented by a concrete class, this is not its intended use. It is more likely that an annotation type should be used to annotate a class.\n\n\n## Recommendation\nEnsure that any annotations are used to annotate a class, unless they are really supposed to be extended or implemented by the class.\n\n\n## Example\nIn the following example, the annotation `Deprecated` is implemented by the class `ImplementsAnnotation`.\n\n\n```java\npublic abstract class ImplementsAnnotation implements Deprecated {\n\t// ...\n}\n```\nThe following example shows the intended use of annotations: to annotate the class `ImplementsAnnotationFix`.\n\n\n```java\n@Deprecated\npublic abstract class ImplementsAnnotationFix {\n\t// ...\n}\n```\n\n## References\n* Java Language Specification: [Annotation Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6).\n* The Java Tutorials: [Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
                    },
                    "id": "java/annotation-subtype",
                    "name": "java/annotation-subtype",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/ImplementsAnnotation.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Annotation is extended or implemented"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Assigning to a local variable in a 'return' statement has no effect."
                    },
                    "help": {
                      "markdown": "# Assignment in return statement\nAn assignment is an expression. The value of an assignment expression is the value assigned to the variable. This can be useful, for example, when initializing two or more variables at once (for example, `a = b = 0;`). However, assigning to a local variable in the expression of a return statement is redundant because that value can never be read.\n\n\n## Recommendation\nRemove the redundant assignment from the `return` statement, leaving just the right-hand side of the assignment.\n\n\n## Example\nIn the following example, consider the second assignment to `ret`. The variable goes out of scope when the method returns, and the value assigned to it is never read. Therefore, the assignment is redundant. Instead, the last line of the method can be changed to `return Math.max(ret, c);`\n\n\n```java\npublic class Utilities\n{\n\tpublic static int max(int a, int b, int c) {\n\t\tint ret = Math.max(a, b)\n\t\treturn ret = Math.max(ret, c);  // Redundant assignment\n\t}\n}\n```\n\n## References\n* Java Language Specification: [ 14.17 The return Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.17), [ 15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).\n",
                      "text": "# Assignment in return statement\nAn assignment is an expression. The value of an assignment expression is the value assigned to the variable. This can be useful, for example, when initializing two or more variables at once (for example, `a = b = 0;`). However, assigning to a local variable in the expression of a return statement is redundant because that value can never be read.\n\n\n## Recommendation\nRemove the redundant assignment from the `return` statement, leaving just the right-hand side of the assignment.\n\n\n## Example\nIn the following example, consider the second assignment to `ret`. The variable goes out of scope when the method returns, and the value assigned to it is never read. Therefore, the assignment is redundant. Instead, the last line of the method can be changed to `return Math.max(ret, c);`\n\n\n```java\npublic class Utilities\n{\n\tpublic static int max(int a, int b, int c) {\n\t\tint ret = Math.max(a, b)\n\t\treturn ret = Math.max(ret, c);  // Redundant assignment\n\t}\n}\n```\n\n## References\n* Java Language Specification: [ 14.17 The return Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.17), [ 15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).\n"
                    },
                    "id": "java/assignment-in-return",
                    "name": "java/assignment-in-return",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/AssignmentInReturn.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assignment in return statement"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Changing a parameter's value in a method or constructor may decrease code readability."
                    },
                    "help": {
                      "markdown": "# Assignment to parameter\nProgrammers usually assume that the value of a parameter is the value that was passed in to the method or constructor. Assigning a different value to a parameter in a method or constructor invalidates that assumption.\n\n\n## Recommendation\nAvoid assignment to parameters by doing one of the following:\n\n* Introduce a local variable and assign to that instead.\n* Use an expression directly rather than assigning it to a parameter.\n\n## Example\nIn the following example, the first method shows assignment to the parameter `miles`. The second method shows how to avoid this by using the expression `miles * KM_PER_MILE`. The third method shows how to avoid the assignment by declaring a local variable `kilometres` and assigning to that.\n\n\n```java\nfinal private static double KM_PER_MILE = 1.609344;\n\n// AVOID: Example that assigns to a parameter\npublic double milesToKM(double miles) {\n\tmiles *= KM_PER_MILE;\n\treturn miles;\n}\n\n// GOOD: Example of using an expression instead\npublic double milesToKM(double miles) {\n\treturn miles * KM_PER_MILE;\n}\n\n// GOOD: Example of using a local variable\npublic double milesToKM(double miles) {\n\tdouble kilometres = miles * KM_PER_MILE;\n\treturn kilometres;\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Basics: [Methods 4 - Local variables](https://web.archive.org/web/20200223080939/http://leepoint.net/JavaBasics/methods/methods-22-local-variables.html).\n",
                      "text": "# Assignment to parameter\nProgrammers usually assume that the value of a parameter is the value that was passed in to the method or constructor. Assigning a different value to a parameter in a method or constructor invalidates that assumption.\n\n\n## Recommendation\nAvoid assignment to parameters by doing one of the following:\n\n* Introduce a local variable and assign to that instead.\n* Use an expression directly rather than assigning it to a parameter.\n\n## Example\nIn the following example, the first method shows assignment to the parameter `miles`. The second method shows how to avoid this by using the expression `miles * KM_PER_MILE`. The third method shows how to avoid the assignment by declaring a local variable `kilometres` and assigning to that.\n\n\n```java\nfinal private static double KM_PER_MILE = 1.609344;\n\n// AVOID: Example that assigns to a parameter\npublic double milesToKM(double miles) {\n\tmiles *= KM_PER_MILE;\n\treturn miles;\n}\n\n// GOOD: Example of using an expression instead\npublic double milesToKM(double miles) {\n\treturn miles * KM_PER_MILE;\n}\n\n// GOOD: Example of using a local variable\npublic double milesToKM(double miles) {\n\tdouble kilometres = miles * KM_PER_MILE;\n\treturn kilometres;\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Basics: [Methods 4 - Local variables](https://web.archive.org/web/20200223080939/http://leepoint.net/JavaBasics/methods/methods-22-local-variables.html).\n"
                    },
                    "id": "java/assignment-to-parameter",
                    "name": "java/assignment-to-parameter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/ParameterAssignment.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assignment to parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling the default implementation of 'toString' returns a value that is unlikely to be what you expect."
                    },
                    "help": {
                      "markdown": "# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/call-to-object-tostring",
                    "name": "java/call-to-object-tostring",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/DefaultToString.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use of default toString()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Casting 'this' to a type parameter of the current type masks an implicit type constraint that should be explicitly stated."
                    },
                    "help": {
                      "markdown": "# Cast of 'this' to a type parameter\nCasting `this` to a type parameter usually suggests that there is an implicit type constraint - the programmer probably wanted to express the notion that `this` could be converted to the type parameter (when using the enclosing method from derived types). However, casting to the desired type, relies on derived types to ensure that the cast will succeed without the compiler forcing them to do so.\n\n\n## Recommendation\nThe solution is to enforce the constraint by adding an abstract method on the base type (see example below). Each derived type must then implement this method, which makes the constraint checkable by the compiler and removes the need for a cast.\n\n\n## Example\nIn this example `BadBaseNode` relies on derived types to use the right pattern.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class BadBaseNode<T extends BadBaseNode<T>> {\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// BAD: relies on derived types to use the right pattern\n\t\t\tT cur = (T)this;\n\t\t\twhile(cur.getParent() != null) {\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n}\n```\nThis constraint is better enforced by adding an abstract method on the base type. Implementing this method makes the constraint checkable by the compiler.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class GoodBaseNode<T extends GoodBaseNode<T>> {\n\t\tpublic abstract T getSelf();\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// GOOD: introduce an abstract method to enforce the constraint\n\t\t\t// that 'this' can be converted to T for derived types\n\t\t\tT cur = getSelf();\n\t\t\twhile(cur.getParent() != null)\n\t\t\t{\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tprivate static class GoodConcreteNode extends GoodBaseNode<GoodConcreteNode> {\n\t\tprivate String name;\n\t\tprivate GoodConcreteNode parent;\n\n\t\tpublic GoodConcreteNode(String name, GoodConcreteNode parent)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getSelf() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGoodConcreteNode a = new GoodConcreteNode(\"a\", null);\n\t\tGoodConcreteNode b = new GoodConcreteNode(\"b\", a);\n\t\tGoodConcreteNode c = new GoodConcreteNode(\"c\", a);\n\t\tGoodConcreteNode d = new GoodConcreteNode(\"d\", b);\n\t\tGoodConcreteNode root = d.getRoot();\n\t\tSystem.out.println(a + \" \" + root);\n\t}\n}\n```\n",
                      "text": "# Cast of 'this' to a type parameter\nCasting `this` to a type parameter usually suggests that there is an implicit type constraint - the programmer probably wanted to express the notion that `this` could be converted to the type parameter (when using the enclosing method from derived types). However, casting to the desired type, relies on derived types to ensure that the cast will succeed without the compiler forcing them to do so.\n\n\n## Recommendation\nThe solution is to enforce the constraint by adding an abstract method on the base type (see example below). Each derived type must then implement this method, which makes the constraint checkable by the compiler and removes the need for a cast.\n\n\n## Example\nIn this example `BadBaseNode` relies on derived types to use the right pattern.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class BadBaseNode<T extends BadBaseNode<T>> {\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// BAD: relies on derived types to use the right pattern\n\t\t\tT cur = (T)this;\n\t\t\twhile(cur.getParent() != null) {\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n}\n```\nThis constraint is better enforced by adding an abstract method on the base type. Implementing this method makes the constraint checkable by the compiler.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class GoodBaseNode<T extends GoodBaseNode<T>> {\n\t\tpublic abstract T getSelf();\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// GOOD: introduce an abstract method to enforce the constraint\n\t\t\t// that 'this' can be converted to T for derived types\n\t\t\tT cur = getSelf();\n\t\t\twhile(cur.getParent() != null)\n\t\t\t{\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tprivate static class GoodConcreteNode extends GoodBaseNode<GoodConcreteNode> {\n\t\tprivate String name;\n\t\tprivate GoodConcreteNode parent;\n\n\t\tpublic GoodConcreteNode(String name, GoodConcreteNode parent)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getSelf() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGoodConcreteNode a = new GoodConcreteNode(\"a\", null);\n\t\tGoodConcreteNode b = new GoodConcreteNode(\"b\", a);\n\t\tGoodConcreteNode c = new GoodConcreteNode(\"c\", a);\n\t\tGoodConcreteNode d = new GoodConcreteNode(\"d\", b);\n\t\tGoodConcreteNode root = d.getRoot();\n\t\tSystem.out.println(a + \" \" + root);\n\t}\n}\n```\n"
                    },
                    "id": "java/cast-of-this-to-type-parameter",
                    "name": "java/cast-of-this-to-type-parameter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/CastThisToTypeParameter.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Cast of 'this' to a type parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Long sequences of type tests on a variable are difficult to maintain."
                    },
                    "help": {
                      "markdown": "# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n",
                      "text": "# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n"
                    },
                    "id": "java/chained-type-tests",
                    "name": "java/chained-type-tests",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/ChainedInstanceof.ql",
                      "tags": [
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Chain of 'instanceof' tests"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A class that has the same name as its superclass may be confusing."
                    },
                    "help": {
                      "markdown": "# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n",
                      "text": "# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/class-name-matches-super-class",
                    "name": "java/class-name-matches-super-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/SameNameAsSuper.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Class has same name as super class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Commented-out code makes the remaining code more difficult to read."
                    },
                    "help": {
                      "markdown": "# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n",
                      "text": "# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n"
                    },
                    "id": "java/commented-out-code",
                    "name": "java/commented-out-code",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Comments/CommentedCode.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Commented-out code"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A block that contains too many complex statements becomes unreadable and unmaintainable."
                    },
                    "help": {
                      "markdown": "# Block with too many statements\nCode has a tendency to become more complex over time. A method that is initially simple may need to be extended to accommodate additional functionality or to address defects. Before long it becomes unreadable and unmaintainable, with many complex statements nested within each other.\n\nThis rule applies to a block that contains a significant number of complex statements. Note that this is quite different from just considering the number of statements in a block, because each complex statement is potentially a candidate for being extracted to a new method as part of refactoring. For the purposes of this rule, loops and switch statements are considered to be complex.\n\n\n## Recommendation\nTo make the code more understandable and less complex, identify logical units and extract them to new methods. As a result, the top-level logic becomes clearer.\n\n\n## References\n* M. Fowler, *Refactoring: Improving the Design of Existing Code*. Addison-Wesley Professional, 1999.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n",
                      "text": "# Block with too many statements\nCode has a tendency to become more complex over time. A method that is initially simple may need to be extended to accommodate additional functionality or to address defects. Before long it becomes unreadable and unmaintainable, with many complex statements nested within each other.\n\nThis rule applies to a block that contains a significant number of complex statements. Note that this is quite different from just considering the number of statements in a block, because each complex statement is potentially a candidate for being extracted to a new method as part of refactoring. For the purposes of this rule, loops and switch statements are considered to be complex.\n\n\n## Recommendation\nTo make the code more understandable and less complex, identify logical units and extract them to new methods. As a result, the top-level logic becomes clearer.\n\n\n## References\n* M. Fowler, *Refactoring: Improving the Design of Existing Code*. Addison-Wesley Professional, 1999.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/complex-block",
                    "name": "java/complex-block",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Complexity/BlockWithTooManyStatements.ql",
                      "tags": [
                        "complexity",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Block with too many statements"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Methods in the same class whose names differ only in capitalization are confusing."
                    },
                    "help": {
                      "markdown": "# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n",
                      "text": "# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/confusing-method-name",
                    "name": "java/confusing-method-name",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingMethodNames.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing method names because of capitalization"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Overloaded methods that have the same number of parameters, where each pair of corresponding parameter types is convertible by casting or autoboxing, may be confusing."
                    },
                    "help": {
                      "markdown": "# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n",
                      "text": "# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n"
                    },
                    "id": "java/confusing-method-signature",
                    "name": "java/confusing-method-signature",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingOverloading.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing overloading of methods"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that would override another method but does not, because the name is capitalized differently, is confusing and may be a mistake."
                    },
                    "help": {
                      "markdown": "# Confusing method names because of overriding\nIf a method that would override another method but does not because the name is capitalized differently, there are two possibilities:\n\n* The programmer intends the method to override the other method, and the difference in capitalization is a typographical error.\n* The programmer does not intend the method to override the other method, in which case the similarity of the names is very confusing.\n\n## Recommendation\nIf overriding *is* intended, make the capitalization of the two methods the same.\n\nIf overriding is *not* intended, consider naming the methods to make the distinction between them clear.\n\n\n## Example\nIn the following example, `toString` has been wrongly capitalized as `tostring`. This means that objects of type `Customer` do not print correctly.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // Incorrect capitalization of 'toString'\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n",
                      "text": "# Confusing method names because of overriding\nIf a method that would override another method but does not because the name is capitalized differently, there are two possibilities:\n\n* The programmer intends the method to override the other method, and the difference in capitalization is a typographical error.\n* The programmer does not intend the method to override the other method, in which case the similarity of the names is very confusing.\n\n## Recommendation\nIf overriding *is* intended, make the capitalization of the two methods the same.\n\nIf overriding is *not* intended, consider naming the methods to make the distinction between them clear.\n\n\n## Example\nIn the following example, `toString` has been wrongly capitalized as `tostring`. This means that objects of type `Customer` do not print correctly.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // Incorrect capitalization of 'toString'\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/confusing-override-name",
                    "name": "java/confusing-override-name",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingOverridesNames.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing method names because of overriding"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Implementing an interface (or extending an abstract class) only to put a number of constant definitions into scope is considered bad practice."
                    },
                    "help": {
                      "markdown": "# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n",
                      "text": "# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/constants-only-interface",
                    "name": "java/constants-only-interface",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Declarations/NoConstantsOnly.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Constant interface anti-pattern"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that has the same name as its declaring type may have been intended to be a constructor."
                    },
                    "help": {
                      "markdown": "# Typo in constructor\nA method that has the same name as its declaring type may be intended to be a constructor, not a method.\n\n\n## Example\nThe following example shows how the singleton design pattern is often misimplemented. The programmer intends the constructor of `MasterSingleton` to be protected so that it cannot be instantiated (because the singleton instance should be retrieved using `getInstance`). However, the programmer accidentally wrote `void` in front of the constructor name, which makes it a method rather than a constructor.\n\n\n```java\nclass MasterSingleton\n{\n\t// ...\n\n\tprivate static MasterSingleton singleton = new MasterSingleton();\n\tpublic static MasterSingleton getInstance() { return singleton; }\n\n\t// Make the constructor 'protected' to prevent this class from being instantiated.\n\tprotected void MasterSingleton() { }\n}\n\n```\n\n## Recommendation\nEnsure that methods that have the same name as their declaring type are intended to be methods. Even if they are intended to be methods, it may be better to rename them to avoid confusion.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 63. Addison-Wesley, 2005.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design Patterns: Elements of Reusable Objection-Oriented Software*, &sect;3. Addison-Wesley Longman Publishing Co. Inc., 1995.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4 Method Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4), [8.8 Constructor Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8).\n",
                      "text": "# Typo in constructor\nA method that has the same name as its declaring type may be intended to be a constructor, not a method.\n\n\n## Example\nThe following example shows how the singleton design pattern is often misimplemented. The programmer intends the constructor of `MasterSingleton` to be protected so that it cannot be instantiated (because the singleton instance should be retrieved using `getInstance`). However, the programmer accidentally wrote `void` in front of the constructor name, which makes it a method rather than a constructor.\n\n\n```java\nclass MasterSingleton\n{\n\t// ...\n\n\tprivate static MasterSingleton singleton = new MasterSingleton();\n\tpublic static MasterSingleton getInstance() { return singleton; }\n\n\t// Make the constructor 'protected' to prevent this class from being instantiated.\n\tprotected void MasterSingleton() { }\n}\n\n```\n\n## Recommendation\nEnsure that methods that have the same name as their declaring type are intended to be methods. Even if they are intended to be methods, it may be better to rename them to avoid confusion.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 63. Addison-Wesley, 2005.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design Patterns: Elements of Reusable Objection-Oriented Software*, &sect;3. Addison-Wesley Longman Publishing Co. Inc., 1995.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4 Method Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4), [8.8 Constructor Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8).\n"
                    },
                    "id": "java/constructor-typo",
                    "name": "java/constructor-typo",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/ConstructorTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Two otherwise unrelated classes that share too much information about each other are difficult to maintain, change and understand."
                    },
                    "help": {
                      "markdown": "# Inappropriate Intimacy\n*Inappropriate intimacy* is an anti-pattern that describes a pair of otherwise unrelated classes that are too tightly coupled: each class uses a significant number of methods and fields of the other. This makes both classes difficult to maintain, change and understand. Inappropriate intimacy is the same as the \"feature envy\" anti-pattern but in both directions: each class is \"envious\" of some functionality or data defined in the other class.\n\n\n## Recommendation\nThe solution might be as simple as moving some misplaced methods to their rightful place, or perhaps some tangled bits of code need to be extracted to their own methods first before being moved.\n\nSometimes the entangled parts (both fields and methods) indicate a missing object or level of abstraction. It might make sense to combine them into a new type that can be used in both classes. You may need to introduce delegation to hide some implementation details.\n\nIt may be necessary to convert the bidirectional association into a unidirectional relationship, possibly by using dependency inversion.\n\nModern IDEs provide refactoring support for this sort of issue, usually with the names \"Move method\", \"Extract method\" or \"Extract class\".\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 95&ndash;96. Addison-Wesley Professional, 2004.\n",
                      "text": "# Inappropriate Intimacy\n*Inappropriate intimacy* is an anti-pattern that describes a pair of otherwise unrelated classes that are too tightly coupled: each class uses a significant number of methods and fields of the other. This makes both classes difficult to maintain, change and understand. Inappropriate intimacy is the same as the \"feature envy\" anti-pattern but in both directions: each class is \"envious\" of some functionality or data defined in the other class.\n\n\n## Recommendation\nThe solution might be as simple as moving some misplaced methods to their rightful place, or perhaps some tangled bits of code need to be extracted to their own methods first before being moved.\n\nSometimes the entangled parts (both fields and methods) indicate a missing object or level of abstraction. It might make sense to combine them into a new type that can be used in both classes. You may need to introduce delegation to hide some implementation details.\n\nIt may be necessary to convert the bidirectional association into a unidirectional relationship, possibly by using dependency inversion.\n\nModern IDEs provide refactoring support for this sort of issue, usually with the names \"Move method\", \"Extract method\" or \"Extract class\".\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 95&ndash;96. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/coupled-types",
                    "name": "java/coupled-types",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/InappropriateIntimacy.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inappropriate Intimacy"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead classes add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead class\nClasses that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nClasses are considered dead if at runtime:\n\n* No methods declared in the class, or a sub-type, are called.\n* No fields declared in the class, or a sub-type, are read.\n* The class is never constructed.\nAny class which is not dead is considered to be \"live\". Nested classes are considered and listed separately, as a live nested class within a dead outer class can be moved to a separate file, allowing the outer class to be deleted.\n\nA special exception is made for \"namespace classes\". A namespace class is used only to group static fields, methods and nested classes - it is never instantiated, has no public constructor and has no instance methods. If a class is considered to be a namespace class, then it is live if at least one of the static members of that class is live - including static nested classes.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the class is not required by verifying that the only dependencies on the class are from other dead classes and methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the class is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the class is not required, remove the class. You will also need to remove any references to this class, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nNested classes within this type should be moved, either to a new top-level type, or to another type, unless they are also marked as dead, in which case they can also be removed. Alternatively, if there are some live nested classes within the dead class, the class can be retained by converting all live nested classes to static members, and removing all instance methods and fields, and all dead static members (see Example 2).\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of classes, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\tString firstName = /*...*/; String lastName = /*...*/;\n\t// Construct a customer\n\tCustomer customer = new Customer();\n\t// Set important properties (but not the address)\n\tcustomer.setName(firstName, lastName);\n\t// Save the customer\n\tcustomer.save();\n}\n\npublic class Customer {\n\tprivate Address address;\n\t// ...\n\n\t// This setter and getter are unused, and so may be deleted.\n\tpublic void addAddress(String line1, String line2, String line3) {\n\t\taddress = new Address(line1, line2, line3);\n\t}\n\tpublic Address getAddress() { return address; }\n}\n\n/*\n * This class is only constructed from dead code, and may be deleted.\n */\npublic class Address {\n\t// ...\n\tpublic Address(String line1, String line2, String line3) {\n\t\t// ...\n\t}\n}\n\n```\nThe class `Customer` is constructed in the main method, and is therefore live. The class `Address` is constructed in `setAddress`, so we might think that it would also be live. However, `setAddress` is never called by the main method, so, assuming that this is the entire program, an `Address` is never constructed at runtime. Therefore, the `Address` class is dead and can be removed without changing the meaning of this program. To delete the `Address` class we will also need to delete the `setAddress` and `getAddress` methods, and the `address` field, otherwise the program will not compile.\n\n\n## Example 2\nIn the next example, we have a `CustomerActions` class containing `Action`s that affect customers. For example, this could be a Java Swing application, and the `Action`s could be actions that are available in the user interface.\n\n\n```java\n/*\n * This class is dead because it is never constructed, and the instance methods are not\n * called.\n */\npublic class CustomerActions {\n\tpublic CustomerActions() {\n\t}\n\n\t// This method is never called,\n\tpublic Action createAddCustomerAction () {\n\t\treturn new AddCustomerAction();\n\t}\n\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\nThe `CustomerActions` class has a constructor and an instance method, which are never called. Instead, actions are instantiated directly. Although this makes the nested `Action` classes live, live nested classes do not make the outer class live. Therefore, the `CustomerActions` class is marked as dead.\n\nThere are two ways to resolve the dead `CustomerActions` class:\n\n* Move each nested static action that is used by the program to a new file, or nest it within a different class, then delete the dead `CustomerActions` class.\n* Convert the `CustomerActions` class to a *namespace class*. First convert the constructor to a *suppressed constructor* by making it private, preventing the class from being instantiated, then remove the instance method `createAddCustomerAction`.\nTaking the second approach, this is the final result.\n\n\n```java\n// This class is now live - it is used as a namespace class\npublic class CustomerActions {\n\t/*\n\t * This constructor is suppressing construction of this class, so is not considered\n\t * dead.\n\t */\n\tprivate CustomerActions() { }\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead class\nClasses that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nClasses are considered dead if at runtime:\n\n* No methods declared in the class, or a sub-type, are called.\n* No fields declared in the class, or a sub-type, are read.\n* The class is never constructed.\nAny class which is not dead is considered to be \"live\". Nested classes are considered and listed separately, as a live nested class within a dead outer class can be moved to a separate file, allowing the outer class to be deleted.\n\nA special exception is made for \"namespace classes\". A namespace class is used only to group static fields, methods and nested classes - it is never instantiated, has no public constructor and has no instance methods. If a class is considered to be a namespace class, then it is live if at least one of the static members of that class is live - including static nested classes.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the class is not required by verifying that the only dependencies on the class are from other dead classes and methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the class is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the class is not required, remove the class. You will also need to remove any references to this class, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nNested classes within this type should be moved, either to a new top-level type, or to another type, unless they are also marked as dead, in which case they can also be removed. Alternatively, if there are some live nested classes within the dead class, the class can be retained by converting all live nested classes to static members, and removing all instance methods and fields, and all dead static members (see Example 2).\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of classes, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\tString firstName = /*...*/; String lastName = /*...*/;\n\t// Construct a customer\n\tCustomer customer = new Customer();\n\t// Set important properties (but not the address)\n\tcustomer.setName(firstName, lastName);\n\t// Save the customer\n\tcustomer.save();\n}\n\npublic class Customer {\n\tprivate Address address;\n\t// ...\n\n\t// This setter and getter are unused, and so may be deleted.\n\tpublic void addAddress(String line1, String line2, String line3) {\n\t\taddress = new Address(line1, line2, line3);\n\t}\n\tpublic Address getAddress() { return address; }\n}\n\n/*\n * This class is only constructed from dead code, and may be deleted.\n */\npublic class Address {\n\t// ...\n\tpublic Address(String line1, String line2, String line3) {\n\t\t// ...\n\t}\n}\n\n```\nThe class `Customer` is constructed in the main method, and is therefore live. The class `Address` is constructed in `setAddress`, so we might think that it would also be live. However, `setAddress` is never called by the main method, so, assuming that this is the entire program, an `Address` is never constructed at runtime. Therefore, the `Address` class is dead and can be removed without changing the meaning of this program. To delete the `Address` class we will also need to delete the `setAddress` and `getAddress` methods, and the `address` field, otherwise the program will not compile.\n\n\n## Example 2\nIn the next example, we have a `CustomerActions` class containing `Action`s that affect customers. For example, this could be a Java Swing application, and the `Action`s could be actions that are available in the user interface.\n\n\n```java\n/*\n * This class is dead because it is never constructed, and the instance methods are not\n * called.\n */\npublic class CustomerActions {\n\tpublic CustomerActions() {\n\t}\n\n\t// This method is never called,\n\tpublic Action createAddCustomerAction () {\n\t\treturn new AddCustomerAction();\n\t}\n\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\nThe `CustomerActions` class has a constructor and an instance method, which are never called. Instead, actions are instantiated directly. Although this makes the nested `Action` classes live, live nested classes do not make the outer class live. Therefore, the `CustomerActions` class is marked as dead.\n\nThere are two ways to resolve the dead `CustomerActions` class:\n\n* Move each nested static action that is used by the program to a new file, or nest it within a different class, then delete the dead `CustomerActions` class.\n* Convert the `CustomerActions` class to a *namespace class*. First convert the constructor to a *suppressed constructor* by making it private, preventing the class from being instantiated, then remove the instance method `createAddCustomerAction`.\nTaking the second approach, this is the final result.\n\n\n```java\n// This class is now live - it is used as a namespace class\npublic class CustomerActions {\n\t/*\n\t * This constructor is suppressing construction of this class, so is not considered\n\t * dead.\n\t */\n\tprivate CustomerActions() { }\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-class",
                    "name": "java/dead-class",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadClass.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead enum constants add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead enum constant\nEnum constants that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nAn enum constant is considered dead if at runtime it is never used, or only used in comparisons. Any enum constant which is not dead is considered to be \"live\".\n\nAn enum constant that is only used in a comparison is considered dead because the comparison will always produce the same result. This is because no variable holds the value of the enum constant, so the comparison of any variable against the constant will always return the same result.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the enum constant is not required by verifying that the enum constant is never used. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the enum constant is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the enum constant is not required, remove the enum constant. You will also need to remove any references to this enum constant, which may, in turn, require removing other dead code.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example\nIn the following example, we have an enum class called `Result`, intended to report the result of some operation:\n\n\n```java\npublic enum Result {\n\tSUCCESS,\n\tFAILURE,\n\tERROR\n}\n\npublic Result runOperation(String value) {\n\tif (value == 1) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\npublic static void main(String[] args) {\n\tResult operationResult = runOperation(args[0]);\n\tif (operationResult == Result.ERROR) {\n\t\texit(1);\n\t} else {\n\t\texit(0);\n\t}\n\n}\n```\nThe method `runOperation` performs some operation, and returns a `Result` depending on whether the operation succeeded. However, it only returns either `SUCCESS` or `FAILURE`, and never `ERROR`. The `main` method calls `runOperation`, and checks whether the returned result is the `ERROR`. However, this check will always return the same result - `false`. This is because the `operationResult` can never hold `ERROR`, because `ERROR` is never stored or returned anywhere in the program. Therefore, `ERROR` is dead and can be removed, along with the comparison check, and the `exit(1);`.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead enum constant\nEnum constants that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nAn enum constant is considered dead if at runtime it is never used, or only used in comparisons. Any enum constant which is not dead is considered to be \"live\".\n\nAn enum constant that is only used in a comparison is considered dead because the comparison will always produce the same result. This is because no variable holds the value of the enum constant, so the comparison of any variable against the constant will always return the same result.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the enum constant is not required by verifying that the enum constant is never used. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the enum constant is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the enum constant is not required, remove the enum constant. You will also need to remove any references to this enum constant, which may, in turn, require removing other dead code.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example\nIn the following example, we have an enum class called `Result`, intended to report the result of some operation:\n\n\n```java\npublic enum Result {\n\tSUCCESS,\n\tFAILURE,\n\tERROR\n}\n\npublic Result runOperation(String value) {\n\tif (value == 1) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\npublic static void main(String[] args) {\n\tResult operationResult = runOperation(args[0]);\n\tif (operationResult == Result.ERROR) {\n\t\texit(1);\n\t} else {\n\t\texit(0);\n\t}\n\n}\n```\nThe method `runOperation` performs some operation, and returns a `Result` depending on whether the operation succeeded. However, it only returns either `SUCCESS` or `FAILURE`, and never `ERROR`. The `main` method calls `runOperation`, and checks whether the returned result is the `ERROR`. However, this check will always return the same result - `false`. This is because the `operationResult` can never hold `ERROR`, because `ERROR` is never stored or returned anywhere in the program. Therefore, `ERROR` is dead and can be removed, along with the comparison check, and the `exit(1);`.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-enum-constant",
                    "name": "java/dead-enum-constant",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadEnumConstant.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead enum constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Fields that are never read are likely unnecessary."
                    },
                    "help": {
                      "markdown": "# Dead field\nFields that are never read at runtime are unnecessary and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nFields are considered dead if at runtime they are never read directly or indirectly, for example through a framework or a use of reflection. Any field which is not dead is considered to be \"live\".\n\nFields are considered to be dead if they are only written to, and never read.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the field is not required by verifying that the field is only read from dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the field is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the field is not required, remove the field. You will also need to remove any references to this field, which may, in turn, require removing other unused classes, methods and fields.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a class containing a single field called `deadField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int deadField;\n\n\tprivate int getDeadField() {\n\t\treturn deadField;\n\t}\n}\n```\nThe field is only read from the method `getDeadField`. However, `getDeadField` is never called, so the field is never read at runtime. The field is therefore marked as dead.\n\n\n## Example 2\nIn this example, we have another class containing a single field called `writtenToField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int writtenToField;\n\n\tpublic void runThing() {\n\t\twrittenToField = 2;\n\t\tcallOtherThing();\n\t}\n\n\tpublic static main(String[] args) {\n\t\trunThing();\n\t}\n}\n```\nThe field is written to in the method `runThing`, which is live because it is called by the `main` method. However, the field is never read at runtime, only written to. The field is therefore marked as dead.\n\n\n## Example 3\nIn this example, we have a class representing something that can be serialized to and from XML:\n\n\n```java\n@XmlRootElement\npublic class SerializableClass {\n\t@XmlAttribute\n\tprivate String field;\n\n\tpublic void setField(String field) {\n\t\tthis.field = field;\n\t}\n}\n```\nThe field `field` is written and read by the serialization framework in order to store the contents of the object in an XML file, or to construct an instance of the object from an XML file. The field is therefore considered to be read at runtime, which makes the field live.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead field\nFields that are never read at runtime are unnecessary and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nFields are considered dead if at runtime they are never read directly or indirectly, for example through a framework or a use of reflection. Any field which is not dead is considered to be \"live\".\n\nFields are considered to be dead if they are only written to, and never read.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the field is not required by verifying that the field is only read from dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the field is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the field is not required, remove the field. You will also need to remove any references to this field, which may, in turn, require removing other unused classes, methods and fields.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a class containing a single field called `deadField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int deadField;\n\n\tprivate int getDeadField() {\n\t\treturn deadField;\n\t}\n}\n```\nThe field is only read from the method `getDeadField`. However, `getDeadField` is never called, so the field is never read at runtime. The field is therefore marked as dead.\n\n\n## Example 2\nIn this example, we have another class containing a single field called `writtenToField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int writtenToField;\n\n\tpublic void runThing() {\n\t\twrittenToField = 2;\n\t\tcallOtherThing();\n\t}\n\n\tpublic static main(String[] args) {\n\t\trunThing();\n\t}\n}\n```\nThe field is written to in the method `runThing`, which is live because it is called by the `main` method. However, the field is never read at runtime, only written to. The field is therefore marked as dead.\n\n\n## Example 3\nIn this example, we have a class representing something that can be serialized to and from XML:\n\n\n```java\n@XmlRootElement\npublic class SerializableClass {\n\t@XmlAttribute\n\tprivate String field;\n\n\tpublic void setField(String field) {\n\t\tthis.field = field;\n\t}\n}\n```\nThe field `field` is written and read by the serialization framework in order to store the contents of the object in an XML file, or to construct an instance of the object from an XML file. The field is therefore considered to be read at runtime, which makes the field live.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-field",
                    "name": "java/dead-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadField.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead methods add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead method\nMethods that are never called at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nMethods are considered dead if at runtime they are never called, either directly, by a method call, or indirectly, through a framework or use of reflection. Any method which is not dead is considered to be \"live\".\n\nThe results can include methods, constructors and initializers. Initializers come in two forms, instance initializers and static initializers. For each class there will be at most one dead initializer of each type, representing all the initialization of that type in the class.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the method is not required by verifying that the only dependencies on the method are from other dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the method is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the method is not required, remove the method. You will also need to remove any references to this method, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nIf the result is a static initializer, then all `static { ... }` blocks and initializers on static fields are dead within that class. In addition, the lack of static initialization implies that all static methods and fields are also dead and can be removed. These methods and fields will also be reported separately. In contrast, static nested classes may still be live, because constructing or accessing the nested static class does not trigger static initialization of the outer class.\n\nIf the result is an instance initializer, then all instance initializer `{ ... }` blocks and initializers on instance fields are dead. In addition, the lack of instance initialization implies that the class is never constructed, which means that all instance methods and fields are also dead and can be removed. These methods and fields will also be reported separately.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of methods, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\t// Only call the live method\n\tliveMethod();\n}\n\n/** This method is live because it is called by main(..) */\npublic static void liveMethod() {\n\totherLiveMethod()\n}\n\n/** This method is live because it is called by a live method */\npublic static void otherLiveMethod() {\n}\n\n\n/** This method is dead because it is never called */\npublic static void deadMethod() {\n\totherDeadMethod();\n}\n\n/** This method is dead because it is only called by dead methods */\npublic static void otherDeadMethod() {\n}\n```\nThe method `liveMethod` is called from the main method, and is therefore considered live. `liveMethod` calls `otherLiveMethod`, which also makes that live.\n\nIn contrast, `deadMethod` is never called, and does not represent an entry point, so is marked as dead. Likewise, `otherDeadMethod` is only called from the `deadMethod`, so is also marked as dead.\n\n\n## Example 2\nIn this example, we have a test class containing a number of methods.\n\n\n```java\npublic class TestClass {\n\n\t@Before\n\tpublic void setUp() {\n\t\t// ...\n\t}\n\n\t@Test\n\tpublic void testCustomer() {\n\t\t// ...\n\t}\n}\n```\nIn this case, no methods are called directly. However, the annotations on the methods indicate that this is a test class - specifically, JUnit - and that the methods will be called by the test framework when running the tests. `testCustomer` and `setUp` are therefore considered to be \"live\".\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead method\nMethods that are never called at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nMethods are considered dead if at runtime they are never called, either directly, by a method call, or indirectly, through a framework or use of reflection. Any method which is not dead is considered to be \"live\".\n\nThe results can include methods, constructors and initializers. Initializers come in two forms, instance initializers and static initializers. For each class there will be at most one dead initializer of each type, representing all the initialization of that type in the class.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the method is not required by verifying that the only dependencies on the method are from other dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the method is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the method is not required, remove the method. You will also need to remove any references to this method, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nIf the result is a static initializer, then all `static { ... }` blocks and initializers on static fields are dead within that class. In addition, the lack of static initialization implies that all static methods and fields are also dead and can be removed. These methods and fields will also be reported separately. In contrast, static nested classes may still be live, because constructing or accessing the nested static class does not trigger static initialization of the outer class.\n\nIf the result is an instance initializer, then all instance initializer `{ ... }` blocks and initializers on instance fields are dead. In addition, the lack of instance initialization implies that the class is never constructed, which means that all instance methods and fields are also dead and can be removed. These methods and fields will also be reported separately.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of methods, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\t// Only call the live method\n\tliveMethod();\n}\n\n/** This method is live because it is called by main(..) */\npublic static void liveMethod() {\n\totherLiveMethod()\n}\n\n/** This method is live because it is called by a live method */\npublic static void otherLiveMethod() {\n}\n\n\n/** This method is dead because it is never called */\npublic static void deadMethod() {\n\totherDeadMethod();\n}\n\n/** This method is dead because it is only called by dead methods */\npublic static void otherDeadMethod() {\n}\n```\nThe method `liveMethod` is called from the main method, and is therefore considered live. `liveMethod` calls `otherLiveMethod`, which also makes that live.\n\nIn contrast, `deadMethod` is never called, and does not represent an entry point, so is marked as dead. Likewise, `otherDeadMethod` is only called from the `deadMethod`, so is also marked as dead.\n\n\n## Example 2\nIn this example, we have a test class containing a number of methods.\n\n\n```java\npublic class TestClass {\n\n\t@Before\n\tpublic void setUp() {\n\t\t// ...\n\t}\n\n\t@Test\n\tpublic void testCustomer() {\n\t\t// ...\n\t}\n}\n```\nIn this case, no methods are called directly. However, the annotations on the methods indicate that this is a test class - specifically, JUnit - and that the methods will be called by the test framework when running the tests. `testCustomer` and `setUp` are therefore considered to be \"live\".\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-function",
                    "name": "java/dead-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadMethod.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a method or constructor that has been marked as deprecated may be dangerous or fail to take advantage of a better method or constructor."
                    },
                    "help": {
                      "markdown": "# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n",
                      "text": "# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n"
                    },
                    "id": "java/deprecated-call",
                    "name": "java/deprecated-call",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Deprecated%20Code/AvoidDeprecatedCallableAccess.ql",
                      "tags": [
                        "external/cwe/cwe-477",
                        "maintainability",
                        "non-attributable"
                      ]
                    },
                    "shortDescription": {
                      "text": "Deprecated method or constructor invocation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Casting 'this' to a derived type introduces a dependency cycle between the type of 'this' and the target type."
                    },
                    "help": {
                      "markdown": "# Dubious downcast of 'this'\nDowncasting `this` to a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, abstract classes may require every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by coercing the type of `this` to a derived type.\n\n\n```java\npublic class DubiousDowncastOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\n\t\t\t\tthis.d = (Derived)this;\t\t// violation\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n",
                      "text": "# Dubious downcast of 'this'\nDowncasting `this` to a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, abstract classes may require every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by coercing the type of `this` to a derived type.\n\n\n```java\npublic class DubiousDowncastOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\n\t\t\t\tthis.d = (Derived)this;\t\t// violation\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n"
                    },
                    "id": "java/downcast-of-this",
                    "name": "java/downcast-of-this",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/DubiousDowncastOfThis.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dubious downcast of 'this'"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Duplicated anonymous classes indicate that refactoring is necessary."
                    },
                    "help": {
                      "markdown": "# Duplicate anonymous class\nAnonymous classes are a common way of creating implementations of an interface or abstract class whose functionality is really only needed once. Duplicating the definition of an anonymous class in several places is usually a sign that refactoring is necessary.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nIntroduce a concrete class that contains the definition just once, and replace the anonymous classes with instances of this concrete class.\n\n\n## Example\nIn the following example, the definition of the class `addActionListener` is duplicated for each button that needs to use it. A better solution is shown that defines just one class, `MultiplexingListener`, which is used by each button.\n\n\n```java\n// BAD: Duplicate anonymous classes:\nbutton1.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\nbutton2.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\n// ... and so on.\n\n// GOOD: Better solution:\nclass MultiplexingListener implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        for (ActionListener listener : listeners)\n            listener.actionPerformed(e);\n    }\n}\n\nbutton1.addActionListener(new MultiplexingListener());\nbutton2.addActionListener(new MultiplexingListener());\n// ... and so on.\n\n```\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Duplicate anonymous class\nAnonymous classes are a common way of creating implementations of an interface or abstract class whose functionality is really only needed once. Duplicating the definition of an anonymous class in several places is usually a sign that refactoring is necessary.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nIntroduce a concrete class that contains the definition just once, and replace the anonymous classes with instances of this concrete class.\n\n\n## Example\nIn the following example, the definition of the class `addActionListener` is duplicated for each button that needs to use it. A better solution is shown that defines just one class, `MultiplexingListener`, which is used by each button.\n\n\n```java\n// BAD: Duplicate anonymous classes:\nbutton1.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\nbutton2.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\n// ... and so on.\n\n// GOOD: Better solution:\nclass MultiplexingListener implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        for (ActionListener listener : listeners)\n            listener.actionPerformed(e);\n    }\n}\n\nbutton1.addActionListener(new MultiplexingListener());\nbutton2.addActionListener(new MultiplexingListener());\n// ... and so on.\n\n```\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-anonymous-class",
                    "name": "java/duplicate-anonymous-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/DuplicateAnonymous.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Duplicate anonymous class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Classes in which most of the methods are duplicated in another class make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate class\nWhen most of the methods in one class are duplicated in one or more other classes, the classes themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated classes are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many methods between two classes, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two classes serve different purposes but many of their methods are duplicated, this indicates that there is a missing level of abstraction. Introducing a common super-class to define the common methods is likely to prevent many problems in the long term. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n* If the two classes serve the same purpose and are different only as a result of inconsistent updates then treat the classes as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate class\nWhen most of the methods in one class are duplicated in one or more other classes, the classes themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated classes are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many methods between two classes, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two classes serve different purposes but many of their methods are duplicated, this indicates that there is a missing level of abstraction. Introducing a common super-class to define the common methods is likely to prevent many problems in the long term. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n* If the two classes serve the same purpose and are different only as a result of inconsistent updates then treat the classes as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-class",
                    "name": "java/duplicate-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateClass.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Files in which most of the lines are duplicated in another file make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate file\nWhen most of the lines in one file are duplicated in one or more other files, the files themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated files are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them. A common exception is generated code that simply occurs in several places in the source tree.\n\nIt is more common to see duplication of many lines between two files, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two files serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways to share the functionality, either by extracting a utility class for parts of it or by encapsulating the common parts into a new super class of any classes involved.\n* If the two files serve the same purpose and are different only as a result of inconsistent updates then treat the files as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate file\nWhen most of the lines in one file are duplicated in one or more other files, the files themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated files are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them. A common exception is generated code that simply occurs in several places in the source tree.\n\nIt is more common to see duplication of many lines between two files, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two files serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways to share the functionality, either by extracting a utility class for parts of it or by encapsulating the common parts into a new super class of any classes involved.\n* If the two files serve the same purpose and are different only as a result of inconsistent updates then treat the files as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-file",
                    "name": "java/duplicate-file",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateFile.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Duplicated methods make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Duplicate method\nA method should never be duplicated exactly in several places in the code. The severity of this problem is higher for longer methods than for extremely short methods of one or two statements, but there are usually better ways of achieving the same effect.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAt its simplest, the duplication can be addressed by simply removing all but one of the duplicate method definitions, and changing calls to the removed methods so that they call the remaining function instead.\n\nThis may not be possible because of visibility or accessibility. A common example is where two classes implement the same functionality but neither is a subtype of the other, so it is not possible to inherit a single method definition. In such cases, introducing a common superclass to share the duplicated code is a possible option. Alternatively, if the methods do not need access to private object state, they can be moved to a shared utility class that just provides the functionality itself.\n\n\n## Example\nIn the following example, `RowWidget` and `ColumnWidget` contain duplicate methods. The `collectChildren` method should probably be moved into the superclass, `Widget`, and shared between `RowWidget` and `ColumnWidget`.\n\n\n```java\nclass RowWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ColumnWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n```\nAlternatively, if not all kinds of `Widget` actually need `collectChildren` (for example, not all of them have children), it might be necessary to introduce a new, possibly abstract, class under `Widget`. For example, the new class might be called `ContainerWidget` and include a single definition of `collectChildren`. Both `RowWidget` and `ColumnWidget` could extend the class and inherit `collectChildren`.\n\nModern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Duplicate method\nA method should never be duplicated exactly in several places in the code. The severity of this problem is higher for longer methods than for extremely short methods of one or two statements, but there are usually better ways of achieving the same effect.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAt its simplest, the duplication can be addressed by simply removing all but one of the duplicate method definitions, and changing calls to the removed methods so that they call the remaining function instead.\n\nThis may not be possible because of visibility or accessibility. A common example is where two classes implement the same functionality but neither is a subtype of the other, so it is not possible to inherit a single method definition. In such cases, introducing a common superclass to share the duplicated code is a possible option. Alternatively, if the methods do not need access to private object state, they can be moved to a shared utility class that just provides the functionality itself.\n\n\n## Example\nIn the following example, `RowWidget` and `ColumnWidget` contain duplicate methods. The `collectChildren` method should probably be moved into the superclass, `Widget`, and shared between `RowWidget` and `ColumnWidget`.\n\n\n```java\nclass RowWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ColumnWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n```\nAlternatively, if not all kinds of `Widget` actually need `collectChildren` (for example, not all of them have children), it might be necessary to introduce a new, possibly abstract, class under `Widget`. For example, the new class might be called `ContainerWidget` and include a single definition of `collectChildren`. Both `RowWidget` and `ColumnWidget` could extend the class and inherit `collectChildren`.\n\nModern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-method",
                    "name": "java/duplicate-method",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/DuplicateMethod.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Duplicate method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Querying the contents of a collection or map that is never initialized is not normally useful."
                    },
                    "help": {
                      "markdown": "# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/empty-container",
                    "name": "java/empty-container",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Collections/ReadOnlyContainer.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "reliability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Container contents are never initialized"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An empty statement hinders readability."
                    },
                    "help": {
                      "markdown": "# Empty statement\nAn *empty statement* is a single semicolon `;` that does not terminate another statement. Such a statement hinders readability and has no effect on its own.\n\n\n## Recommendation\nAvoid empty statements. If a loop is intended to have an empty body, it is better to mark that fact explicitly by using a pair of braces `{}` containing an explanatory comment for the body, rather than a single semicolon.\n\n\n## Example\nIn the following example, there is an empty statement on line 3, where an additional semicolon is used. On line 6, the `for` statement has an empty body because the condition is immediately followed by a semicolon. In this case, it is better to include a pair of braces `{}` containing an explanatory comment for the body instead.\n\n\n```java\npublic class Cart {\n\t// AVOID: Empty statement\n\tList<Item> items = new ArrayList<Cart>();;\n\tpublic void applyDiscount(float discount) {\n\t\t// AVOID: Empty statement as loop body\n\t\tfor (int i = 0; i < items.size(); items.get(i++).applyDiscount(discount));\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n",
                      "text": "# Empty statement\nAn *empty statement* is a single semicolon `;` that does not terminate another statement. Such a statement hinders readability and has no effect on its own.\n\n\n## Recommendation\nAvoid empty statements. If a loop is intended to have an empty body, it is better to mark that fact explicitly by using a pair of braces `{}` containing an explanatory comment for the body, rather than a single semicolon.\n\n\n## Example\nIn the following example, there is an empty statement on line 3, where an additional semicolon is used. On line 6, the `for` statement has an empty body because the condition is immediately followed by a semicolon. In this case, it is better to include a pair of braces `{}` containing an explanatory comment for the body instead.\n\n\n```java\npublic class Cart {\n\t// AVOID: Empty statement\n\tList<Item> items = new ArrayList<Cart>();;\n\tpublic void applyDiscount(float discount) {\n\t\t// AVOID: Empty statement as loop body\n\t\tfor (int i = 0; i < items.size(); items.get(i++).applyDiscount(discount));\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
                    },
                    "id": "java/empty-statement",
                    "name": "java/empty-statement",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/EmptyStatement.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Empty statement"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'equal' may be intended to be named 'equals'."
                    },
                    "help": {
                      "markdown": "# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n",
                      "text": "# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
                    },
                    "id": "java/equals-typo",
                    "name": "java/equals-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/EqualsTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in equals"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An expression that always evaluates to the same value, but which has a non-constant subexpression, indicates a mistake."
                    },
                    "help": {
                      "markdown": "# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n",
                      "text": "# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n"
                    },
                    "id": "java/evaluation-to-constant",
                    "name": "java/evaluation-to-constant",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/ConstantExpAppearsNonConstant.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Expression always evaluates to the same value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that uses more methods or variables from another (unrelated) class than from its own class violates the principle of putting data and behavior in the same place."
                    },
                    "help": {
                      "markdown": "# Feature envy\n*Feature envy* refers to situations where a method is \"in the wrong place\", because it does not use many methods or variables of its own class, but uses a whole range of methods or variables from some other class. This violates the principle of putting data and behavior in the same place, and exposes internals of the other class to the method.\n\n\n## Recommendation\nFor each method that may exhibit feature envy, see if it needs to be declared in its present location, or if you can move it to the class it is \"envious\" of. A common example is a method that calls a large number of getters on another class to perform a calculation that does not rely on anything from its own class. In such cases, you should move the method to the class containing the data. If the calculation depends on some values from the method's current class, they can either be passed as arguments or accessed using getters from the other class.\n\nIf it is inappropriate to move the entire method, see if all the dependencies on the other class are concentrated in just one part of the method. If so, you can move them into a method of their own. You can then move this method to the other class and call it from the original method.\n\nIf a class is envious of functionality defined in a superclass, perhaps the superclass needs to be rewritten to become more extensible and allow its subtypes to define new behavior without them depending so deeply on the superclass's implementation. The *template method* pattern may be useful in achieving this.\n\nModern IDEs provide several refactorings that may be useful in addressing instances of feature envy, typically under the names of \"Move method\" and \"Extract method\".\n\nOccasionally, behavior can be misinterpreted as feature envy when in fact it is justified. The most common examples are complex design patterns like *visitor* or *strategy*, where the goal is to separate data from behavior.\n\n\n## Example\nIn the following example, initially the method `getTotalPrice` is in the `Basket` class, but it only uses data belonging to the `Item` class. Therefore, it represents an instance of feature envy. To refactor it, `getTotalPrice` can be moved to `Item` and its parameter can be removed. The resulting code is easier to understand and keep consistent.\n\n\n```java\n// Before refactoring:\nclass Item { .. }\nclass Basket {\n\t// ..\n\tfloat getTotalPrice(Item i) {\n\t\tfloat price = i.getPrice() + i.getTax();\n\t\tif (i.isOnSale())\n\t\t\tprice = price - i.getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n\n// After refactoring:\nclass Item {\n\t// ..\n\tfloat getTotalPrice() {\n\t\tfloat price = getPrice() + getTax();\n\t\tif (isOnSale())\n\t\t\tprice = price - getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n```\nThe refactored code is still appropriate, even if some data from the `Basket` class is necessary for the computation of the total price. For example, if the `Basket` class applies a bulk discount when a sufficient number of items are in the basket, an \"additional discount\" parameter can be added to `Item.getTotalPrice(..)`. Alternatively, the application of the discount can be performed in a method in `Basket` that calls `Item.getTotalPrice`.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 93&ndash;94. Addison-Wesley Professional, 2004.\n",
                      "text": "# Feature envy\n*Feature envy* refers to situations where a method is \"in the wrong place\", because it does not use many methods or variables of its own class, but uses a whole range of methods or variables from some other class. This violates the principle of putting data and behavior in the same place, and exposes internals of the other class to the method.\n\n\n## Recommendation\nFor each method that may exhibit feature envy, see if it needs to be declared in its present location, or if you can move it to the class it is \"envious\" of. A common example is a method that calls a large number of getters on another class to perform a calculation that does not rely on anything from its own class. In such cases, you should move the method to the class containing the data. If the calculation depends on some values from the method's current class, they can either be passed as arguments or accessed using getters from the other class.\n\nIf it is inappropriate to move the entire method, see if all the dependencies on the other class are concentrated in just one part of the method. If so, you can move them into a method of their own. You can then move this method to the other class and call it from the original method.\n\nIf a class is envious of functionality defined in a superclass, perhaps the superclass needs to be rewritten to become more extensible and allow its subtypes to define new behavior without them depending so deeply on the superclass's implementation. The *template method* pattern may be useful in achieving this.\n\nModern IDEs provide several refactorings that may be useful in addressing instances of feature envy, typically under the names of \"Move method\" and \"Extract method\".\n\nOccasionally, behavior can be misinterpreted as feature envy when in fact it is justified. The most common examples are complex design patterns like *visitor* or *strategy*, where the goal is to separate data from behavior.\n\n\n## Example\nIn the following example, initially the method `getTotalPrice` is in the `Basket` class, but it only uses data belonging to the `Item` class. Therefore, it represents an instance of feature envy. To refactor it, `getTotalPrice` can be moved to `Item` and its parameter can be removed. The resulting code is easier to understand and keep consistent.\n\n\n```java\n// Before refactoring:\nclass Item { .. }\nclass Basket {\n\t// ..\n\tfloat getTotalPrice(Item i) {\n\t\tfloat price = i.getPrice() + i.getTax();\n\t\tif (i.isOnSale())\n\t\t\tprice = price - i.getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n\n// After refactoring:\nclass Item {\n\t// ..\n\tfloat getTotalPrice() {\n\t\tfloat price = getPrice() + getTax();\n\t\tif (isOnSale())\n\t\t\tprice = price - getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n```\nThe refactored code is still appropriate, even if some data from the `Basket` class is necessary for the computation of the total price. For example, if the `Basket` class applies a bulk discount when a sufficient number of items are in the basket, an \"additional discount\" parameter can be added to `Item.getTotalPrice(..)`. Alternatively, the application of the discount can be performed in a method in `Basket` that calls `Item.getTotalPrice`.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 93&ndash;94. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/feature-envy",
                    "name": "java/feature-envy",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/FeatureEnvy.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Feature envy"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Hiding a field in a superclass by redeclaring it in a subclass might be unintentional, especially if references to the hidden field are not qualified using 'super'."
                    },
                    "help": {
                      "markdown": "# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n",
                      "text": "# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n"
                    },
                    "id": "java/field-masks-super-field",
                    "name": "java/field-masks-super-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/FieldMasksSuperField.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Field masks field in super class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Setting fields to 'null' in a finalizer does not cause the object to be collected by the garbage collector any earlier, and may adversely affect performance."
                    },
                    "help": {
                      "markdown": "# Finalizer nulls fields\nA finalizer does not need to set an object's fields to `null` to help the garbage collector. At the point in the Java object life-cycle when the `finalize` method is called, the object is no longer reachable from the garbage collection roots. Explicitly setting the object's fields to `null` does not cause the referenced objects to be collected by the garbage collector any earlier, and may even adversely affect performance.\n\nThe life-cycle of a Java object has 7 stages:\n\n* **Created** : Memory is allocated for the object and the initializers and constructors have been run.\n* **In use** : The object is reachable through a chain of strong references from a garbage collection root. A garbage collection root is a special class of variable (which includes variables on the stack of any thread, static variables of any class, and references from Java Native Interface code).\n* **Invisible** : The object has already gone out of scope, but the stack frame of the method that contained the scope is still in memory. Not all objects transition into this state.\n* **Unreachable** : The object is no longer reachable through a chain of strong references. It becomes a candidate for garbage collection.\n* **Collected** : The garbage collector has identified that the object can be deallocated. If it has a finalizer, it is marked for finalization. Otherwise, it is deallocated.\n* **Finalized** : An object with a `finalize` method transitions to this state after the finalize method is completed and the object still remains unreachable.\n* **Deallocated** : The object is a candidate for deallocation.\nThe call to the `finalize` method occurs when the object is in the 'Collected' stage. At that point, it is already unreachable from the garbage collection roots so any of its references to other objects no longer contribute to their reference counts.\n\n\n## Recommendation\nEnsure that the finalizer does not contain any `null` assignments because they are unlikely to help garbage collection.\n\nIf a finalizer does nothing but nullify an object's fields, it is best to completely remove the finalizer. Objects with finalizers severely affect performance, and you should avoid defining `finalize` where possible.\n\n\n## Example\nIn the following example, `finalize` unnecessarily assigns the object's fields to null.\n\n\n```java\nclass FinalizedClass {\n\tObject o = new Object();\n\tString s = \"abcdefg\";\n\tInteger i = Integer.valueOf(2);\n\t\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\t\t//No need to nullify fields\n\t\tthis.o = null;\n\t\tthis.s = null;\n\t\tthis.i = null;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* IBM developerWorks: [Java theory and practice: Explicit nulling](https://web.archive.org/web/20201111184342/https://www.ibm.com/developerworks/java/library/j-jtp01274/index.html#3.2).\n* Oracle Technology Network: [ How to Handle Java Finalization's Memory-Retention Issues ](https://www.oracle.com/technical-resources/articles/javase/finalization.html).\n* S. Wilson and J. Kesselman, *Java Platform Performance: Strategies and Tactics, 1st ed.*, Appendix A. Prentice Hall, 2001.\n",
                      "text": "# Finalizer nulls fields\nA finalizer does not need to set an object's fields to `null` to help the garbage collector. At the point in the Java object life-cycle when the `finalize` method is called, the object is no longer reachable from the garbage collection roots. Explicitly setting the object's fields to `null` does not cause the referenced objects to be collected by the garbage collector any earlier, and may even adversely affect performance.\n\nThe life-cycle of a Java object has 7 stages:\n\n* **Created** : Memory is allocated for the object and the initializers and constructors have been run.\n* **In use** : The object is reachable through a chain of strong references from a garbage collection root. A garbage collection root is a special class of variable (which includes variables on the stack of any thread, static variables of any class, and references from Java Native Interface code).\n* **Invisible** : The object has already gone out of scope, but the stack frame of the method that contained the scope is still in memory. Not all objects transition into this state.\n* **Unreachable** : The object is no longer reachable through a chain of strong references. It becomes a candidate for garbage collection.\n* **Collected** : The garbage collector has identified that the object can be deallocated. If it has a finalizer, it is marked for finalization. Otherwise, it is deallocated.\n* **Finalized** : An object with a `finalize` method transitions to this state after the finalize method is completed and the object still remains unreachable.\n* **Deallocated** : The object is a candidate for deallocation.\nThe call to the `finalize` method occurs when the object is in the 'Collected' stage. At that point, it is already unreachable from the garbage collection roots so any of its references to other objects no longer contribute to their reference counts.\n\n\n## Recommendation\nEnsure that the finalizer does not contain any `null` assignments because they are unlikely to help garbage collection.\n\nIf a finalizer does nothing but nullify an object's fields, it is best to completely remove the finalizer. Objects with finalizers severely affect performance, and you should avoid defining `finalize` where possible.\n\n\n## Example\nIn the following example, `finalize` unnecessarily assigns the object's fields to null.\n\n\n```java\nclass FinalizedClass {\n\tObject o = new Object();\n\tString s = \"abcdefg\";\n\tInteger i = Integer.valueOf(2);\n\t\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\t\t//No need to nullify fields\n\t\tthis.o = null;\n\t\tthis.s = null;\n\t\tthis.i = null;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* IBM developerWorks: [Java theory and practice: Explicit nulling](https://web.archive.org/web/20201111184342/https://www.ibm.com/developerworks/java/library/j-jtp01274/index.html#3.2).\n* Oracle Technology Network: [ How to Handle Java Finalization's Memory-Retention Issues ](https://www.oracle.com/technical-resources/articles/javase/finalization.html).\n* S. Wilson and J. Kesselman, *Java Platform Performance: Strategies and Tactics, 1st ed.*, Appendix A. Prentice Hall, 2001.\n"
                    },
                    "id": "java/finalizer-nulls-fields",
                    "name": "java/finalizer-nulls-fields",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/FinalizerNullsFields.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Finalizer nulls fields"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Triggering garbage collection explicitly may either have no effect or may trigger unnecessary garbage collection."
                    },
                    "help": {
                      "markdown": "# Explicit garbage collection\nYou should avoid making calls to explicit garbage collection methods (`Runtime.gc` and `System.gc`). The calls are not guaranteed to trigger garbage collection, and they may also trigger unnecessary garbage collection passes that lead to decreased performance.\n\n\n## Recommendation\nIt is better to let the Java Virtual Machine (JVM) handle garbage collection. If it becomes necessary to control how the JVM handles memory, it is better to use the JVM's memory and garbage collection options (for example, `-Xmx`, `-XX:NewRatio`, `-XX:Use*GC`) than to trigger garbage collection in the application.\n\nThe memory management classes that are used by Real-Time Java are an exception to this rule, because they are designed to handle garbage collection differently from the JVM default.\n\n\n## Example\nThe following example shows code that makes connection requests, and tries to trigger garbage collection after it has processed each request.\n\n\n```java\nclass RequestHandler extends Thread {\n\tprivate boolean isRunning;\n\tprivate Connection conn = new Connection();\n\t\n\tpublic void run() {\n\t\twhile (isRunning) {\n\t\t\tRequest req = conn.getRequest();\n\t\t\t// Process the request ...\n\t\t\t\n\t\t\tSystem.gc();  // This call may cause a garbage collection after each request.\n\t\t\t\t\t\t  // This will likely reduce the throughput of the RequestHandler\n\t\t\t\t\t\t  // because the JVM spends time on unnecessary garbage collection passes.\n\t\t}\n\t}\n}\n```\nIt is better to remove the call to `System.gc` and rely on the JVM to dispose of the connection.\n\n\n## References\n* Java API Specification: [System.gc()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#gc()).\n* Java Documentation: [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html).\n",
                      "text": "# Explicit garbage collection\nYou should avoid making calls to explicit garbage collection methods (`Runtime.gc` and `System.gc`). The calls are not guaranteed to trigger garbage collection, and they may also trigger unnecessary garbage collection passes that lead to decreased performance.\n\n\n## Recommendation\nIt is better to let the Java Virtual Machine (JVM) handle garbage collection. If it becomes necessary to control how the JVM handles memory, it is better to use the JVM's memory and garbage collection options (for example, `-Xmx`, `-XX:NewRatio`, `-XX:Use*GC`) than to trigger garbage collection in the application.\n\nThe memory management classes that are used by Real-Time Java are an exception to this rule, because they are designed to handle garbage collection differently from the JVM default.\n\n\n## Example\nThe following example shows code that makes connection requests, and tries to trigger garbage collection after it has processed each request.\n\n\n```java\nclass RequestHandler extends Thread {\n\tprivate boolean isRunning;\n\tprivate Connection conn = new Connection();\n\t\n\tpublic void run() {\n\t\twhile (isRunning) {\n\t\t\tRequest req = conn.getRequest();\n\t\t\t// Process the request ...\n\t\t\t\n\t\t\tSystem.gc();  // This call may cause a garbage collection after each request.\n\t\t\t\t\t\t  // This will likely reduce the throughput of the RequestHandler\n\t\t\t\t\t\t  // because the JVM spends time on unnecessary garbage collection passes.\n\t\t}\n\t}\n}\n```\nIt is better to remove the call to `System.gc` and rely on the JVM to dispose of the connection.\n\n\n## References\n* Java API Specification: [System.gc()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#gc()).\n* Java Documentation: [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html).\n"
                    },
                    "id": "java/garbage-collection",
                    "name": "java/garbage-collection",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/GarbageCollection.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Explicit garbage collection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'hashcode' may be intended to be named 'hashCode'."
                    },
                    "help": {
                      "markdown": "# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n",
                      "text": "# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
                    },
                    "id": "java/hashcode-typo",
                    "name": "java/hashcode-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/HashCodeTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in hashCode"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Hub classes, which are classes that use, and are used by, many other classes, are complex and difficult to change without affecting the rest of the system."
                    },
                    "help": {
                      "markdown": "# Hub classes\nA *hub class* is a class that depends on many other classes, and on which many other classes depend.\n\nFor the purposes of this rule, a *dependency* is any use of one class in another. Examples include:\n\n* Using another class as the declared type of a variable or field\n* Using another class as an argument type for a method\n* Using another class as a superclass in the `extends` declaration\n* Calling a method defined in the class\nA class can be regarded as a hub class when both the incoming dependencies and the outgoing source dependencies are particularly high. (Outgoing source dependencies are dependencies on other source classes, rather than library classes like `java.lang.Object`.)\n\nIt is undesirable to have many hub classes because they are extremely difficult to maintain. This is because many other classes depend on a hub class, and so the other classes have to be tested and possibly adapted after each change to the hub class. Also, when one of a hub class's direct dependencies changes, the behavior of the hub class and all of its dependencies has to be checked and possibly adapted.\n\n\n## Recommendation\nOne common reason for a class to be regarded as a hub class is that it tries to do too much, including unrelated functionality that depends on different parts of the code base. If possible, split such classes into several better encapsulated classes.\n\nAnother common reason is that the class is a \"struct-like\" class that has many fields of different types. Introducing some intermediate grouping containers to make it clearer what fields belong together may be a good option.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n",
                      "text": "# Hub classes\nA *hub class* is a class that depends on many other classes, and on which many other classes depend.\n\nFor the purposes of this rule, a *dependency* is any use of one class in another. Examples include:\n\n* Using another class as the declared type of a variable or field\n* Using another class as an argument type for a method\n* Using another class as a superclass in the `extends` declaration\n* Calling a method defined in the class\nA class can be regarded as a hub class when both the incoming dependencies and the outgoing source dependencies are particularly high. (Outgoing source dependencies are dependencies on other source classes, rather than library classes like `java.lang.Object`.)\n\nIt is undesirable to have many hub classes because they are extremely difficult to maintain. This is because many other classes depend on a hub class, and so the other classes have to be tested and possibly adapted after each change to the hub class. Also, when one of a hub class's direct dependencies changes, the behavior of the hub class and all of its dependencies has to be checked and possibly adapted.\n\n\n## Recommendation\nOne common reason for a class to be regarded as a hub class is that it tries to do too much, including unrelated functionality that depends on different parts of the code base. If possible, split such classes into several better encapsulated classes.\n\nAnother common reason is that the class is a \"struct-like\" class that has many fields of different types. Introducing some intermediate grouping containers to make it clearer what fields belong together may be a good option.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/hub-class",
                    "name": "java/hub-class",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/HubClasses.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Hub classes"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An implicit import obscures the dependencies of a file and may cause confusing compile-time errors."
                    },
                    "help": {
                      "markdown": "# Implicit import\nImports can be categorized as *explicit* (for example `import java.util.List;`) or *implicit* (also known as 'on-demand', for example `import java.util.*;`):\n\n* Implicit imports give access to all visible types in the type (or package) that precedes the \".\\*\"; types imported in this way never shadow other types.\n* Explicit imports give access to just the named type; they can shadow other types that would normally be visible through an implicit import, or through the normal package visibility rules.\nIt is often considered bad practice to use implicit imports. The only advantage to doing so is making the code more concise, and there are a number of disadvantages:\n\n* The exact dependencies of a file are not visible at a glance.\n* Confusing compile-time errors can be introduced if a type name is used that could originate from several implicit imports.\n\n## Recommendation\nFor readability, it is recommended to use explicit imports instead of implicit imports. Many modern IDEs provide automatic functionality to help achieve this, typically under the name \"Organize imports\". They can also fold away the import declarations, and automatically manage imports: adding them when a particular type is auto-completed by the editor, and removing them when they are not necessary. This functionality makes implicit imports mainly redundant.\n\n\n## Example\nThe following example uses implicit imports. This means that it is not clear to a programmer where the `List` type on line 5 is imported from.\n\n\n```java\nimport java.util.*;  // AVOID: Implicit import statements\nimport java.awt.*;\n\npublic class Customers {\n\tpublic List getCustomers() {  // Compiler error: 'List' is ambiguous.\n\t\t...\n\t}\n}\n```\nTo improve readability, the implicit imports should be replaced by explicit imports. For example, `import java.util.*;` should be replaced by `import java.util.List;` on line 1.\n\n\n## References\n* Java Language Specification: [6.4.1 Shadowing](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4.1), [7.5.2 Type-Import-on-Demand Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.5.2).\n",
                      "text": "# Implicit import\nImports can be categorized as *explicit* (for example `import java.util.List;`) or *implicit* (also known as 'on-demand', for example `import java.util.*;`):\n\n* Implicit imports give access to all visible types in the type (or package) that precedes the \".\\*\"; types imported in this way never shadow other types.\n* Explicit imports give access to just the named type; they can shadow other types that would normally be visible through an implicit import, or through the normal package visibility rules.\nIt is often considered bad practice to use implicit imports. The only advantage to doing so is making the code more concise, and there are a number of disadvantages:\n\n* The exact dependencies of a file are not visible at a glance.\n* Confusing compile-time errors can be introduced if a type name is used that could originate from several implicit imports.\n\n## Recommendation\nFor readability, it is recommended to use explicit imports instead of implicit imports. Many modern IDEs provide automatic functionality to help achieve this, typically under the name \"Organize imports\". They can also fold away the import declarations, and automatically manage imports: adding them when a particular type is auto-completed by the editor, and removing them when they are not necessary. This functionality makes implicit imports mainly redundant.\n\n\n## Example\nThe following example uses implicit imports. This means that it is not clear to a programmer where the `List` type on line 5 is imported from.\n\n\n```java\nimport java.util.*;  // AVOID: Implicit import statements\nimport java.awt.*;\n\npublic class Customers {\n\tpublic List getCustomers() {  // Compiler error: 'List' is ambiguous.\n\t\t...\n\t}\n}\n```\nTo improve readability, the implicit imports should be replaced by explicit imports. For example, `import java.util.*;` should be replaced by `import java.util.List;` on line 1.\n\n\n## References\n* Java Language Specification: [6.4.1 Shadowing](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4.1), [7.5.2 Type-Import-on-Demand Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.5.2).\n"
                    },
                    "id": "java/implicit-import",
                    "name": "java/implicit-import",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Declarations/MakeImportsExplicit.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Implicit import"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Javadoc that incorrectly claims a method or constructor can throw an exception is misleading."
                    },
                    "help": {
                      "markdown": "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n",
                      "text": "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n"
                    },
                    "id": "java/inconsistent-javadoc-throws",
                    "name": "java/inconsistent-javadoc-throws",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/ImpossibleJavadocThrows.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Javadoc has impossible 'throws' tag"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A 'serialVersionUID' field that is declared in a serializable class but is of the wrong type cannot be used by the serialization framework."
                    },
                    "help": {
                      "markdown": "# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n",
                      "text": "# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n"
                    },
                    "id": "java/incorrect-serial-version-uid",
                    "name": "java/incorrect-serial-version-uid",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/IncorrectSerialVersionUID.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Incorrect serialVersionUID field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling the constructor of a boxed type is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n",
                      "text": "# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n"
                    },
                    "id": "java/inefficient-boxed-constructor",
                    "name": "java/inefficient-boxed-constructor",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientPrimConstructor.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient primitive constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Checking a string for equality with an empty string is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n",
                      "text": "# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n"
                    },
                    "id": "java/inefficient-empty-string-test",
                    "name": "java/inefficient-empty-string-test",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientEmptyStringTest.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient empty string test"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Iterating through the values of a map using the key set is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n",
                      "text": "# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n"
                    },
                    "id": "java/inefficient-key-set-iterator",
                    "name": "java/inefficient-key-set-iterator",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientKeySetIterator.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient use of key set iterator"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using the 'String(String)' constructor is less memory efficient than using the constructor argument directly."
                    },
                    "help": {
                      "markdown": "# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n",
                      "text": "# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n"
                    },
                    "id": "java/inefficient-string-constructor",
                    "name": "java/inefficient-string-constructor",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/NewStringString.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient String constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An object that accidentally exposes its internal representation may allow the object's fields to be modified in ways that the object is not prepared to handle."
                    },
                    "help": {
                      "markdown": "# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n",
                      "text": "# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
                    },
                    "id": "java/internal-representation-exposure",
                    "name": "java/internal-representation-exposure",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/ExposeRepresentation.ql",
                      "tags": [
                        "external/cwe/cwe-485",
                        "maintainability",
                        "modularity",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Exposing internal representation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Use of unsupported JDK-internal APIs may cause compatibility issues when upgrading to newer versions of Java, in particular Java 9."
                    },
                    "help": {
                      "markdown": "# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n",
                      "text": "# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n"
                    },
                    "id": "java/jdk-internal-api-access",
                    "name": "java/jdk-internal-api-access",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Compatibility/JDK9/JdkInternalAccess.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Access to unsupported JDK-internal API"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A JUnit 3.8 test method that overrides 'tearDown' but does not call 'super.tearDown' may result in subsequent tests failing, or allow the current state to persist and affect subsequent tests."
                    },
                    "help": {
                      "markdown": "# TestCase implements tearDown but doesn't call super.tearDown()\nA JUnit 3.8 test method that overrides a non-empty `tearDown` method should call `super.tearDown` to make sure that the superclass performs its de-initialization routines. Not calling `tearDown` may result in test failures in subsequent tests, or allow the current state to persist and affect any following tests.\n\n\n## Recommendation\nCall `super.tearDown` at the end of the overriding `tearDown` method.\n\n\n## Example\nIn the following example, `TearDownNoSuper.tearDown` does not call `super.tearDown`, which may cause subsequent tests to fail, or allow the internal state to be maintained. However, `TearDownSuper.tearDown` *does* call `super.tearDown`, at the end of the method, to enable `FrameworkTestCase.tearDown` to perform de-initialization.\n\n\n```java\n// Abstract class that initializes then shuts down the\n// framework after each set of tests\nabstract class FrameworkTestCase extends TestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tFramework.init();\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tFramework.shutdown();\n\t}\n}\n\n// The following classes extend 'FrameworkTestCase' to reuse the\n// 'setUp' and 'tearDown' methods of the framework.\n\npublic class TearDownNoSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// BAD: Does not call 'super.tearDown'. May cause later tests to fail\n\t\t// when they try to re-initialize an already initialized framework.\n\t\t// Even if the framework allows re-initialization, it may maintain the\n\t\t// internal state, which could affect the results of succeeding tests.\n\t\tSystem.out.println(\"Tests complete\");\n\t}\n}\n\npublic class TearDownSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// GOOD: Correctly calls 'super.tearDown' to shut down the\n\t\t// framework.\n\t\tSystem.out.println(\"Tests complete\");\n\t\tsuper.tearDown();\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# TestCase implements tearDown but doesn't call super.tearDown()\nA JUnit 3.8 test method that overrides a non-empty `tearDown` method should call `super.tearDown` to make sure that the superclass performs its de-initialization routines. Not calling `tearDown` may result in test failures in subsequent tests, or allow the current state to persist and affect any following tests.\n\n\n## Recommendation\nCall `super.tearDown` at the end of the overriding `tearDown` method.\n\n\n## Example\nIn the following example, `TearDownNoSuper.tearDown` does not call `super.tearDown`, which may cause subsequent tests to fail, or allow the internal state to be maintained. However, `TearDownSuper.tearDown` *does* call `super.tearDown`, at the end of the method, to enable `FrameworkTestCase.tearDown` to perform de-initialization.\n\n\n```java\n// Abstract class that initializes then shuts down the\n// framework after each set of tests\nabstract class FrameworkTestCase extends TestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tFramework.init();\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tFramework.shutdown();\n\t}\n}\n\n// The following classes extend 'FrameworkTestCase' to reuse the\n// 'setUp' and 'tearDown' methods of the framework.\n\npublic class TearDownNoSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// BAD: Does not call 'super.tearDown'. May cause later tests to fail\n\t\t// when they try to re-initialize an already initialized framework.\n\t\t// Even if the framework allows re-initialization, it may maintain the\n\t\t// internal state, which could affect the results of succeeding tests.\n\t\tSystem.out.println(\"Tests complete\");\n\t}\n}\n\npublic class TearDownSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// GOOD: Correctly calls 'super.tearDown' to shut down the\n\t\t// framework.\n\t\tSystem.out.println(\"Tests complete\");\n\t\tsuper.tearDown();\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/junit-teardown-without-super",
                    "name": "java/junit-teardown-without-super",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/TearDownNoSuper.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "TestCase implements tearDown but doesn't call super.tearDown()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'System.exit', 'Runtime.halt', or 'Runtime.exit' may make code harder to reuse and prevent important cleanup steps from running."
                    },
                    "help": {
                      "markdown": "# Forcible JVM termination\nCalling one of the methods `System.exit`, `Runtime.halt`, and `Runtime.exit` immediately terminates the Java Virtual Machine (JVM), effectively killing all threads without giving any of them a chance to perform cleanup actions or recover. As such, it is a dangerous thing to do: firstly, it can terminate the entire program inadvertently, and secondly, it can prevent important resources from being released or program state from being written to disk consistently.\n\nIt is sometimes considered acceptable to call `System.exit` from a program's `main` method in order to indicate the overall exit status of the program. Such calls are an exception to this rule.\n\n\n## Recommendation\nIt is usually preferable to use a different mechanism for reporting failure conditions. Consider returning a special value (perhaps `null`) that users of the current method check for and recover from appropriately. Alternatively, throw a suitable exception, which unwinds the stack and allows properly written code to clean up after itself, while leaving other threads undisturbed.\n\n\n## Example\nIn the following example, problem 1 shows that `FileOutput.write` tries to write some data to disk and terminates the JVM if this fails. This leaves the partially-written file on disk without any cleanup code running. It would be better to either return `false` to indicate the failure, or let the `IOException` propagate upwards and be handled by a method that knows how to recover.\n\nProblem 2 is more subtle. In this example, there is just one entry point to the program (the `main` method), which constructs an `Action` and performs it. `Action.run` calls `System.exit` to indicate successful completion. Consider, however, how this code might be integrated in an application server that constructs `Action` instances and calls `run` on them without going through `main`. The fact that `run` terminates the JVM instead of returning its exit code as an integer makes that use-case impossible.\n\n\n```java\n// Problem 1: Miss out cleanup code \nclass FileOutput {\n    boolean write(String[] s) {\n        try {\n            output.write(s.getBytes());\n        } catch (IOException e) {\n            System.exit(1);\n        }\n        return true;\n    }\n}\n\n// Problem 2: Make code reuse difficult\nclass Action {\n    public void run() {\n        // ...\n        // Perform tasks ...\n        // ...\n        System.exit(0);\n    }\n    public static void main(String[] args) {\n        new Action(args).run();\n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 232. Addison-Wesley, 2008.\n* Java API Specification: [System.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#exit(int)), [Runtime.halt(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#halt(int)), [Runtime.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#exit(int)).\n* Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).\n",
                      "text": "# Forcible JVM termination\nCalling one of the methods `System.exit`, `Runtime.halt`, and `Runtime.exit` immediately terminates the Java Virtual Machine (JVM), effectively killing all threads without giving any of them a chance to perform cleanup actions or recover. As such, it is a dangerous thing to do: firstly, it can terminate the entire program inadvertently, and secondly, it can prevent important resources from being released or program state from being written to disk consistently.\n\nIt is sometimes considered acceptable to call `System.exit` from a program's `main` method in order to indicate the overall exit status of the program. Such calls are an exception to this rule.\n\n\n## Recommendation\nIt is usually preferable to use a different mechanism for reporting failure conditions. Consider returning a special value (perhaps `null`) that users of the current method check for and recover from appropriately. Alternatively, throw a suitable exception, which unwinds the stack and allows properly written code to clean up after itself, while leaving other threads undisturbed.\n\n\n## Example\nIn the following example, problem 1 shows that `FileOutput.write` tries to write some data to disk and terminates the JVM if this fails. This leaves the partially-written file on disk without any cleanup code running. It would be better to either return `false` to indicate the failure, or let the `IOException` propagate upwards and be handled by a method that knows how to recover.\n\nProblem 2 is more subtle. In this example, there is just one entry point to the program (the `main` method), which constructs an `Action` and performs it. `Action.run` calls `System.exit` to indicate successful completion. Consider, however, how this code might be integrated in an application server that constructs `Action` instances and calls `run` on them without going through `main`. The fact that `run` terminates the JVM instead of returning its exit code as an integer makes that use-case impossible.\n\n\n```java\n// Problem 1: Miss out cleanup code \nclass FileOutput {\n    boolean write(String[] s) {\n        try {\n            output.write(s.getBytes());\n        } catch (IOException e) {\n            System.exit(1);\n        }\n        return true;\n    }\n}\n\n// Problem 2: Make code reuse difficult\nclass Action {\n    public void run() {\n        // ...\n        // Perform tasks ...\n        // ...\n        System.exit(0);\n    }\n    public static void main(String[] args) {\n        new Action(args).run();\n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 232. Addison-Wesley, 2008.\n* Java API Specification: [System.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#exit(int)), [Runtime.halt(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#halt(int)), [Runtime.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#exit(int)).\n* Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).\n"
                    },
                    "id": "java/jvm-exit",
                    "name": "java/jvm-exit",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToSystemExit.ql",
                      "tags": [
                        "external/cwe/cwe-382",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Forcible JVM termination"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method in which a variable is declared with the same name as a field is difficult to understand."
                    },
                    "help": {
                      "markdown": "# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n",
                      "text": "# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
                    },
                    "id": "java/local-shadows-field",
                    "name": "java/local-shadows-field",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/LocalShadowsFieldConfusing.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Possible confusion of local and field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "If a local variable shadows a field of the same name, each use of the name is harder to read."
                    },
                    "help": {
                      "markdown": "# Local variable shadows field\nThis query finds local variables that shadow like-named field declarations. This is confusing since it might easily lead to assignments to the local variable that should have been to the corresponding field.\n\n\n## How to Address the Query Results\nFor clarity, it may be better to rename the variable to avoid shadowing.\n\n\n## References\n",
                      "text": "# Local variable shadows field\nThis query finds local variables that shadow like-named field declarations. This is confusing since it might easily lead to assignments to the local variable that should have been to the corresponding field.\n\n\n## How to Address the Query Results\nFor clarity, it may be better to rename the variable to avoid shadowing.\n\n\n## References\n"
                    },
                    "id": "java/local-shadows-field-unused",
                    "name": "java/local-shadows-field-unused",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/LocalShadowsField.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Local variable shadows field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A local variable that is never read is redundant."
                    },
                    "help": {
                      "markdown": "# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/local-variable-is-never-read",
                    "name": "java/local-variable-is-never-read",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnreadLocal.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unread local variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic number makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic numbers\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nAssign the magic number to a new named constant, and use this instead. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `timeout`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint timeout = 60000;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, timeout);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;  // Magic number is replaced by named constant\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'TIMEOUT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic numbers\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nAssign the magic number to a new named constant, and use this instead. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `timeout`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint timeout = 60000;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, timeout);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;  // Magic number is replaced by named constant\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'TIMEOUT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/magic-number",
                    "name": "java/magic-number",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicConstantsNumbers.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic numbers"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic string makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic strings\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nAssign the magic string to a new named constant, and use this instead. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `username`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString username = \"test\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(IP, PORT, username, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int USERNAME = \"test\";  // Magic string is replaced by named constant\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'USERNAME' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic strings\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nAssign the magic string to a new named constant, and use this instead. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `username`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString username = \"test\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(IP, PORT, username, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int USERNAME = \"test\";  // Magic string is replaced by named constant\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'USERNAME' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/magic-string",
                    "name": "java/magic-string",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicConstantsString.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic strings"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "If a control structure does not use braces, misleading indentation makes it difficult to see which statements are within its scope."
                    },
                    "help": {
                      "markdown": "# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n",
                      "text": "# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n"
                    },
                    "id": "java/misleading-indentation",
                    "name": "java/misleading-indentation",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Statements/UseBraces.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misleading indentation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A static, final field name that contains lowercase letters decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed static final field\nA static, final field name that contains lowercase letters does not follow standard naming conventions, which decreases code readability. For example, `Min_Width`.\n\n\n## Recommendation\nUse uppercase letters throughout a static, final field name, and use underscores to separate words within the field name. For example, `MIN_WIDTH`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed static final field\nA static, final field name that contains lowercase letters does not follow standard naming conventions, which decreases code readability. For example, `Min_Width`.\n\n\n## Recommendation\nUse uppercase letters throughout a static, final field name, and use underscores to separate words within the field name. For example, `MIN_WIDTH`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-constant",
                    "name": "java/misnamed-constant",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsConstants.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed static final field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method name that begins with an uppercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed method\nA method name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Getbackground`.\n\n\n## Recommendation\nBegin the method name with a lowercase letter and use camel case: capitalize the first letter of each word within the method name. For example, `getBackground`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed method\nA method name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Getbackground`.\n\n\n## Recommendation\nBegin the method name with a lowercase letter and use camel case: capitalize the first letter of each word within the method name. For example, `getBackground`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-function",
                    "name": "java/misnamed-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsMethods.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A package name that contains uppercase letters decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed package\nA package name that contains uppercase letters does not follow standard naming conventions, which decreases code readability. For example, `Com.Sun.Eng`.\n\n\n## Recommendation\nUse lowercase letters throughout a package name. For example, `com.sun.eng`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed package\nA package name that contains uppercase letters does not follow standard naming conventions, which decreases code readability. For example, `Com.Sun.Eng`.\n\n\n## Recommendation\nUse lowercase letters throughout a package name. For example, `com.sun.eng`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-package",
                    "name": "java/misnamed-package",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsPackages.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed package"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A class or interface name that begins with a lowercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed class or interface\nA class or interface name that begins with a lowercase letter does not follow standard naming conventions, which decreases code readability. For example, `hotelbooking`.\n\n\n## Recommendation\nBegin the class name with an uppercase letter and use camel case: capitalize the first letter of each word within the class name. For example, `HotelBooking`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed class or interface\nA class or interface name that begins with a lowercase letter does not follow standard naming conventions, which decreases code readability. For example, `hotelbooking`.\n\n\n## Recommendation\nBegin the class name with an uppercase letter and use camel case: capitalize the first letter of each word within the class name. For example, `HotelBooking`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-type",
                    "name": "java/misnamed-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsRefTypes.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed class or interface"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A variable name that begins with an uppercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed variable\nA variable name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Numberofguests`. This applies to local variables, parameters, and non-constant fields.\n\n\n## Recommendation\nBegin the variable name with a lowercase letter and use camel case: capitalize the first letter of each word within the variable name. For example, `numberOfGuests`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed variable\nA variable name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Numberofguests`. This applies to local variables, parameters, and non-constant fields.\n\n\n## Recommendation\nBegin the variable name with a lowercase letter and use camel case: capitalize the first letter of each word within the variable name. For example, `numberOfGuests`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-variable",
                    "name": "java/misnamed-variable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsVariables.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An 'if' statement where both branches either (a) return or (b) write to the same variable can often be expressed more clearly using the '?' operator."
                    },
                    "help": {
                      "markdown": "# Missed ternary opportunity\nAn `if` statement where both branches do nothing but return or write to a variable can be better expressed using the ternary `?` operator.\n\n\n\nUse of the ternary operator enhances readability in two ways:\n\n* It focuses the reader's attention on the intent of the code (to return or write) rather than the testing of a condition.\n* It is more concise, reducing the amount of code that needs to be read.\n* You can initialize a variable conditionally on the line on which it is declared, rather than assigning to it after initialization. This ensures that you initialize the variable as you intended.\n\n## Recommendation\nConsider using a ternary operator in this situation.\n\n\n## Example\nThe following code includes two examples of `if` statements, `myAbs1` and `1`, which can be simplified using the ternary operator. `myAbs2` and `s2` show how the statements can be improved.\n\n\n```java\npublic class MissedTernaryOpportunity {\n\tprivate static int myAbs1(int x) {\n\t\t// Violation\n\t\tif(x >= 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn -x;\n\t}\n\n\tprivate static int myAbs2(int x) {\n\t\t// Better\n\t\treturn x >= 0 ? x : -x;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint i = 23;\n\n\t\t// Violation\n\t\tString s1;\n\t\tif(i == 23)\n\t\t\ts1 = \"Foo\";\n\t\telse\n\t\t\ts1 = \"Bar\";\n\t\tSystem.out.println(s1);\n\n\t\t// Better\n\t\tString s2 = i == 23 ? \"Foo\" : \"Bar\";\n\t\tSystem.out.println(s2);\n\t}\n}\n```\n",
                      "text": "# Missed ternary opportunity\nAn `if` statement where both branches do nothing but return or write to a variable can be better expressed using the ternary `?` operator.\n\n\n\nUse of the ternary operator enhances readability in two ways:\n\n* It focuses the reader's attention on the intent of the code (to return or write) rather than the testing of a condition.\n* It is more concise, reducing the amount of code that needs to be read.\n* You can initialize a variable conditionally on the line on which it is declared, rather than assigning to it after initialization. This ensures that you initialize the variable as you intended.\n\n## Recommendation\nConsider using a ternary operator in this situation.\n\n\n## Example\nThe following code includes two examples of `if` statements, `myAbs1` and `1`, which can be simplified using the ternary operator. `myAbs2` and `s2` show how the statements can be improved.\n\n\n```java\npublic class MissedTernaryOpportunity {\n\tprivate static int myAbs1(int x) {\n\t\t// Violation\n\t\tif(x >= 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn -x;\n\t}\n\n\tprivate static int myAbs2(int x) {\n\t\t// Better\n\t\treturn x >= 0 ? x : -x;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint i = 23;\n\n\t\t// Violation\n\t\tString s1;\n\t\tif(i == 23)\n\t\t\ts1 = \"Foo\";\n\t\telse\n\t\t\ts1 = \"Bar\";\n\t\tSystem.out.println(s1);\n\n\t\t// Better\n\t\tString s2 = i == 23 ? \"Foo\" : \"Bar\";\n\t\tSystem.out.println(s2);\n\t}\n}\n```\n"
                    },
                    "id": "java/missed-ternary-operator",
                    "name": "java/missed-ternary-operator",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/MissedTernaryOpportunity.ql",
                      "tags": [
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missed ternary opportunity"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A 'clone' method that is overridden in a subclass, and that does not itself call 'super.clone', causes calls to the subclass's 'clone' method to return an object of the wrong type."
                    },
                    "help": {
                      "markdown": "# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n",
                      "text": "# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n"
                    },
                    "id": "java/missing-call-to-super-clone",
                    "name": "java/missing-call-to-super-clone",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Cloning/MissingCallToSuperClone.ql",
                      "tags": [
                        "external/cwe/cwe-580",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing super clone"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A class that implements 'Cloneable' but does not override the 'clone' method will have undesired behavior."
                    },
                    "help": {
                      "markdown": "# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n",
                      "text": "# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n"
                    },
                    "id": "java/missing-clone-method",
                    "name": "java/missing-clone-method",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Cloning/MissingMethodClone.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "No clone method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling 'String.toUpperCase()' or 'String.toLowerCase()' without specifying the locale may cause unexpected results for certain default locales."
                    },
                    "help": {
                      "markdown": "# Missing Locale parameter to toUpperCase() or toLowerCase()\nThe parameterless versions of `String.toUpperCase()` and `String.toLowerCase()` use the default locale of the Java Virtual Machine when transforming strings. This can cause unexpected behavior for certain locales.\n\n\n## Recommendation\nUse the corresponding methods with explicit locale parameters to ensure that the results are consistent across all locales. For example:\n\n`System.out.println(\"I\".toLowerCase(java.util.Locale.ENGLISH));`\n\nprints `i`, regardless of the default locale.\n\n\n## Example\nIn the following example, the calls to the parameterless functions may return different strings for different locales. For example, if the default locale is ENGLISH, the function `toLowerCase()` converts a capital `I` to `i`; if the default locale is TURKISH, the function `toLowerCase()` converts a capital `I` to the Unicode Character \"Latin small letter dotless i\" (U+0131).\n\nTo ensure that an English string is returned, regardless of the default locale, the example shows how to call `toLowerCase` and pass `locale.ENGLISH` as the argument. (This assumes that the text is English. If the text is Turkish, you should pass `locale.TURKISH` as the argument.)\n\n\n```java\npublic static void main(String args[]) {\n    String phrase = \"I miss my home in Mississippi.\";\n\n    // AVOID: Calling 'toLowerCase()' or 'toUpperCase()'\n    // produces different results depending on what the default locale is.\n    System.out.println(phrase.toUpperCase());\n    System.out.println(phrase.toLowerCase());\n\n    // GOOD: Explicitly setting the locale when calling 'toLowerCase()' or\n    // 'toUpperCase()' ensures that the resulting string is\n    // English, regardless of the default locale.\n    System.out.println(phrase.toLowerCase(Locale.ENGLISH));\n    System.out.println(phrase.toUpperCase(Locale.ENGLISH));\n}\n```\n\n## References\n* Java API Specification: [String.toUpperCase()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toUpperCase()).\n",
                      "text": "# Missing Locale parameter to toUpperCase() or toLowerCase()\nThe parameterless versions of `String.toUpperCase()` and `String.toLowerCase()` use the default locale of the Java Virtual Machine when transforming strings. This can cause unexpected behavior for certain locales.\n\n\n## Recommendation\nUse the corresponding methods with explicit locale parameters to ensure that the results are consistent across all locales. For example:\n\n`System.out.println(\"I\".toLowerCase(java.util.Locale.ENGLISH));`\n\nprints `i`, regardless of the default locale.\n\n\n## Example\nIn the following example, the calls to the parameterless functions may return different strings for different locales. For example, if the default locale is ENGLISH, the function `toLowerCase()` converts a capital `I` to `i`; if the default locale is TURKISH, the function `toLowerCase()` converts a capital `I` to the Unicode Character \"Latin small letter dotless i\" (U+0131).\n\nTo ensure that an English string is returned, regardless of the default locale, the example shows how to call `toLowerCase` and pass `locale.ENGLISH` as the argument. (This assumes that the text is English. If the text is Turkish, you should pass `locale.TURKISH` as the argument.)\n\n\n```java\npublic static void main(String args[]) {\n    String phrase = \"I miss my home in Mississippi.\";\n\n    // AVOID: Calling 'toLowerCase()' or 'toUpperCase()'\n    // produces different results depending on what the default locale is.\n    System.out.println(phrase.toUpperCase());\n    System.out.println(phrase.toLowerCase());\n\n    // GOOD: Explicitly setting the locale when calling 'toLowerCase()' or\n    // 'toUpperCase()' ensures that the resulting string is\n    // English, regardless of the default locale.\n    System.out.println(phrase.toLowerCase(Locale.ENGLISH));\n    System.out.println(phrase.toUpperCase(Locale.ENGLISH));\n}\n```\n\n## References\n* Java API Specification: [String.toUpperCase()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toUpperCase()).\n"
                    },
                    "id": "java/missing-locale-argument",
                    "name": "java/missing-locale-argument",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/I18N/MissingLocaleArgument.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Locale parameter to toUpperCase() or toLowerCase()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A class that implements 'Externalizable' but does not have a public no-argument constructor causes an 'InvalidClassException' to be thrown."
                    },
                    "help": {
                      "markdown": "# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n",
                      "text": "# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n"
                    },
                    "id": "java/missing-no-arg-constructor-on-externalizable",
                    "name": "java/missing-no-arg-constructor-on-externalizable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/MissingVoidConstructorOnExternalizable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Externalizable but no public no-argument constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A non-serializable, immediate superclass of a serializable class that does not itself declare an accessible, no-argument constructor causes deserialization to fail."
                    },
                    "help": {
                      "markdown": "# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n",
                      "text": "# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/missing-no-arg-constructor-on-serializable",
                    "name": "java/missing-no-arg-constructor-on-serializable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/MissingVoidConstructorsOnSerializable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serializable but no void constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method that overrides a method in a superclass but does not have an 'Override' annotation cannot take advantage of compiler checks, and makes code less readable."
                    },
                    "help": {
                      "markdown": "# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n",
                      "text": "# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n"
                    },
                    "id": "java/missing-override-annotation",
                    "name": "java/missing-override-annotation",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Declarations/MissingOverrideAnnotation.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Override annotation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A 'finalize' method that does not call 'super.finalize' may leave cleanup actions undone."
                    },
                    "help": {
                      "markdown": "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n",
                      "text": "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"
                    },
                    "id": "java/missing-super-finalize",
                    "name": "java/missing-super-finalize",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Finalization/NullifiedSuperFinalize.ql",
                      "tags": [
                        "external/cwe/cwe-568",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Finalizer inconsistency"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "More than one statement per line decreases readability."
                    },
                    "help": {
                      "markdown": "# Multiple statements on line\nCode where each statement is defined on a separate line is much easier for programmers to read than code where multiple statements are defined on the same line.\n\n\n## Recommendation\nSeparate statements by a newline character.\n\n\n## References\n* Java SE Documentation: [7.1 Simple Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#431).\n",
                      "text": "# Multiple statements on line\nCode where each statement is defined on a separate line is much easier for programmers to read than code where multiple statements are defined on the same line.\n\n\n## Recommendation\nSeparate statements by a newline character.\n\n\n## References\n* Java SE Documentation: [7.1 Simple Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#431).\n"
                    },
                    "id": "java/multiple-statements-on-same-line",
                    "name": "java/multiple-statements-on-same-line",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Statements/OneStatementPerLine.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Multiple statements on line"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Using the remainder operator with the multiplication operator without adding parentheses to clarify precedence may cause confusion."
                    },
                    "help": {
                      "markdown": "# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n",
                      "text": "# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n"
                    },
                    "id": "java/multiplication-of-remainder",
                    "name": "java/multiplication-of-remainder",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/MultiplyRemainder.ql",
                      "tags": [
                        "correctness",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Multiplication of remainder"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Mutual dependency between types makes code difficult to understand and test."
                    },
                    "help": {
                      "markdown": "# Mutually-dependent types\nA mutual dependency exists when two code entities (for example, types or packages) depend directly on each other. Mutual dependencies are caused by unwanted dependencies in one or both directions. There are many different kinds of dependency; here are a few examples of how an inter-type dependency from `T1` to `T2` can occur:\n\n* `T1` derives from a type involving `T2`, for example `T2` itself or `List<T2>`.\n* `T1` declares a field of a type involving `T2`.\n* `T1` declares a method whose return type involves `T2`.\n* A method of `T1` declares a local variable whose type involves `T2`.\n* A method of `T1` catches an exception of a type involving `T2`.\nMutual dependencies prevent you from considering either entity in isolation, affecting readability and testability. For example, if types `T1` and `T2` depend on each other, then it is generally impossible to fully understand `T1` without understanding `T2`, and vice-versa. Moreover, neither type can be tested without the other being present. Whilst mocking can alleviate this latter problem to some extent, breaking the mutual dependency is a better solution. For example, suppose we could remove all of the dependencies from `T2` to `T1` - in that case, we would be able to test `T2` in isolation, and completely side-step the need to provide a `T1`, mocked or otherwise.\n\n\n## Recommendation\nBreaking mutual dependencies involves finding ways of removing the unwanted individual dependencies that cause them. The way to do this depends on the kind of dependency in question, with some kinds (for example, dependencies caused by inheritance) being much harder to break than others. A full list of ways to break cycles is beyond the scope of this help topic, however, a few high-level techniques for breaking a dependency from `T1` to `T2` include:\n\n* Introducing an interface that is implemented by `T2`. `T1` can then be refactored to use `T2` only via the interface, which breaks the cycle.\n* Moving the depended-on code in `T2` to a third (possibly new) entity. `T1` can then depend on this third entity instead of on `T2`, breaking the cycle. `T2` is allowed to depend on the third entity as well, although it does not have to if there is no need.\n* Merging `T1` and `T2` together (for example, if there was an artificial separation between two parts of the same concept). This is not a generally-applicable solution, but is sometimes the right thing to do. It has the effect of internalizing the cycle, which is sufficient to solve the problem.\nFor more information on how to break unwanted dependencies, see the references (particularly \\[Lakos\\]).\n\n\n## Example\nIn this example `BadModel` and `BadView` are mutually dependent.\n\n\n```java\npublic class MutualDependency {\n\t// Violation: BadModel and BadView are mutually dependent\n\tprivate static class BadModel {\n\t\tprivate int i;\n\t\tprivate BadView view;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif(view != null) view.modelChanged();\n\t\t}\n\n\t\tpublic void setView(BadView view) {\n\t\t\tthis.view = view;\n\t\t}\n\t}\n\n\tprivate static class BadView {\n\t\tprivate BadModel model;\n\n\t\tpublic BadView(BadModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n}\n```\nThe interface technique can be used to break the dependency between the model and the view. The `ModelListener` interface allows `BetterView` to interact with `BetterModel` without dependency.\n\n\n```java\npublic class NoMutualDependency {\n\t// Better: A new interface breaks the dependency\n\t// from the model to the view\n\tprivate interface ModelListener {\n\t\tvoid modelChanged();\n\t}\n\n\tprivate static class BetterModel {\n\t\tprivate int i;\n\t\tprivate ModelListener listener;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif (listener != null) listener.modelChanged();\n\t\t}\n\n\t\tpublic void setListener(ModelListener listener) {\n\t\t\tthis.listener = listener;\n\t\t}\n\t}\n\n\tprivate static class BetterView implements ModelListener {\n\t\tprivate BetterModel model;\n\n\t\tpublic BetterView(BetterModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBadModel badModel = new BadModel();\n\t\tBadView badView = new BadView(badModel);\n\t\tbadModel.setView(badView);\n\t\tbadModel.setI(23);\n\t\tbadModel.setI(9);\n\n\t\tBetterModel betterModel = new BetterModel();\n\t\tBetterView betterView = new BetterView(betterModel);\n\t\tbetterModel.setListener(betterView);\n\t\tbetterModel.setI(24);\n\t\tbetterModel.setI(12);\n\t}\n}\n```\n\n## References\n* J. Lakos. *Large-Scale C++ Software Design*. Addison-Wesley, 1996.\n* M. Fowler. *Refactoring*. Addison-Wesley, 1999.\n",
                      "text": "# Mutually-dependent types\nA mutual dependency exists when two code entities (for example, types or packages) depend directly on each other. Mutual dependencies are caused by unwanted dependencies in one or both directions. There are many different kinds of dependency; here are a few examples of how an inter-type dependency from `T1` to `T2` can occur:\n\n* `T1` derives from a type involving `T2`, for example `T2` itself or `List<T2>`.\n* `T1` declares a field of a type involving `T2`.\n* `T1` declares a method whose return type involves `T2`.\n* A method of `T1` declares a local variable whose type involves `T2`.\n* A method of `T1` catches an exception of a type involving `T2`.\nMutual dependencies prevent you from considering either entity in isolation, affecting readability and testability. For example, if types `T1` and `T2` depend on each other, then it is generally impossible to fully understand `T1` without understanding `T2`, and vice-versa. Moreover, neither type can be tested without the other being present. Whilst mocking can alleviate this latter problem to some extent, breaking the mutual dependency is a better solution. For example, suppose we could remove all of the dependencies from `T2` to `T1` - in that case, we would be able to test `T2` in isolation, and completely side-step the need to provide a `T1`, mocked or otherwise.\n\n\n## Recommendation\nBreaking mutual dependencies involves finding ways of removing the unwanted individual dependencies that cause them. The way to do this depends on the kind of dependency in question, with some kinds (for example, dependencies caused by inheritance) being much harder to break than others. A full list of ways to break cycles is beyond the scope of this help topic, however, a few high-level techniques for breaking a dependency from `T1` to `T2` include:\n\n* Introducing an interface that is implemented by `T2`. `T1` can then be refactored to use `T2` only via the interface, which breaks the cycle.\n* Moving the depended-on code in `T2` to a third (possibly new) entity. `T1` can then depend on this third entity instead of on `T2`, breaking the cycle. `T2` is allowed to depend on the third entity as well, although it does not have to if there is no need.\n* Merging `T1` and `T2` together (for example, if there was an artificial separation between two parts of the same concept). This is not a generally-applicable solution, but is sometimes the right thing to do. It has the effect of internalizing the cycle, which is sufficient to solve the problem.\nFor more information on how to break unwanted dependencies, see the references (particularly \\[Lakos\\]).\n\n\n## Example\nIn this example `BadModel` and `BadView` are mutually dependent.\n\n\n```java\npublic class MutualDependency {\n\t// Violation: BadModel and BadView are mutually dependent\n\tprivate static class BadModel {\n\t\tprivate int i;\n\t\tprivate BadView view;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif(view != null) view.modelChanged();\n\t\t}\n\n\t\tpublic void setView(BadView view) {\n\t\t\tthis.view = view;\n\t\t}\n\t}\n\n\tprivate static class BadView {\n\t\tprivate BadModel model;\n\n\t\tpublic BadView(BadModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n}\n```\nThe interface technique can be used to break the dependency between the model and the view. The `ModelListener` interface allows `BetterView` to interact with `BetterModel` without dependency.\n\n\n```java\npublic class NoMutualDependency {\n\t// Better: A new interface breaks the dependency\n\t// from the model to the view\n\tprivate interface ModelListener {\n\t\tvoid modelChanged();\n\t}\n\n\tprivate static class BetterModel {\n\t\tprivate int i;\n\t\tprivate ModelListener listener;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif (listener != null) listener.modelChanged();\n\t\t}\n\n\t\tpublic void setListener(ModelListener listener) {\n\t\t\tthis.listener = listener;\n\t\t}\n\t}\n\n\tprivate static class BetterView implements ModelListener {\n\t\tprivate BetterModel model;\n\n\t\tpublic BetterView(BetterModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBadModel badModel = new BadModel();\n\t\tBadView badView = new BadView(badModel);\n\t\tbadModel.setView(badView);\n\t\tbadModel.setI(23);\n\t\tbadModel.setI(9);\n\n\t\tBetterModel betterModel = new BetterModel();\n\t\tBetterView betterView = new BetterView(betterModel);\n\t\tbetterModel.setListener(betterView);\n\t\tbetterModel.setI(24);\n\t\tbetterModel.setI(12);\n\t}\n}\n```\n\n## References\n* J. Lakos. *Large-Scale C++ Software Design*. Addison-Wesley, 1996.\n* M. Fowler. *Refactoring*. Addison-Wesley, 1999.\n"
                    },
                    "id": "java/mutually-dependent-types",
                    "name": "java/mutually-dependent-types",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Dependencies/MutualDependency.ql",
                      "tags": [
                        "maintainability",
                        "modularity",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mutually-dependent types"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Nested loops in which the iteration variable is the same for each loop are difficult to understand."
                    },
                    "help": {
                      "markdown": "# Nested loops with same variable\nThe behavior of nested loops in which the iteration variable is the same for both loops is difficult to understand because the inner loop affects the iteration variable of the outer loop. This is probably a typographical error.\n\n\n## Recommendation\nEnsure that a different iteration variable is used for each loop.\n\n\n## References\n* Java Language Specification: [The basic for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.1).\n",
                      "text": "# Nested loops with same variable\nThe behavior of nested loops in which the iteration variable is the same for both loops is difficult to understand because the inner loop affects the iteration variable of the outer loop. This is probably a typographical error.\n\n\n## Recommendation\nEnsure that a different iteration variable is used for each loop.\n\n\n## References\n* Java Language Specification: [The basic for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.1).\n"
                    },
                    "id": "java/nested-loops-with-same-variable",
                    "name": "java/nested-loops-with-same-variable",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/NestedLoopsSameVariable.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Nested loops with same variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that appears to override another method but does not, because the declaring classes are in different packages, is potentially confusing."
                    },
                    "help": {
                      "markdown": "# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n",
                      "text": "# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n"
                    },
                    "id": "java/non-overriding-package-private",
                    "name": "java/non-overriding-package-private",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/OverridePackagePrivate.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing non-overriding of package-private method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-constant field that is not declared 'private', but is not accessed outside of its declaring type, may decrease code maintainability."
                    },
                    "help": {
                      "markdown": "# Non-private field\nA non-final or non-static field that is not declared `private`, but is not accessed outside of its declaring type, may decrease code maintainability. This is because a field that is accessible from outside the class that it is declared in tends to restrict the class to a particular implementation.\n\n\n## Recommendation\nIn the spirit of encapsulation, it is generally advisable to choose the most restrictive access modifier (`private`) for a field, unless there is a good reason to increase its visibility.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 13. Addison-Wesley, 2008.\n* The Java Tutorials: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html).\n",
                      "text": "# Non-private field\nA non-final or non-static field that is not declared `private`, but is not accessed outside of its declaring type, may decrease code maintainability. This is because a field that is accessible from outside the class that it is declared in tends to restrict the class to a particular implementation.\n\n\n## Recommendation\nIn the spirit of encapsulation, it is generally advisable to choose the most restrictive access modifier (`private`) for a field, unless there is a good reason to increase its visibility.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 13. Addison-Wesley, 2008.\n* The Java Tutorials: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html).\n"
                    },
                    "id": "java/non-private-field",
                    "name": "java/non-private-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Declarations/NonPrivateField.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-private field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A comparator that is passed to an ordered collection (for example, a treemap) must be serializable, otherwise the collection fails to serialize at run-time."
                    },
                    "help": {
                      "markdown": "# Non-serializable comparator\nA class that implements `java.util.Comparator` and is used to construct a sorted collection needs to be serializable. An ordered collection (such as a `java.util.TreeMap`) that is constructed using a comparator serializes successfully only if the comparator is serializable.\n\nThe `Collection`s in the Java Standard Library that require a comparator (`TreeSet`, `TreeMap`, `PriorityQueue`) all call `ObjectOutputStream.defaultWriteObject`, which tries to serialize every non-static, non-transient field in the class. As the comparator is stored in a field in these collections, the attempt to serialize a non-serializable comparator throws a `java.io.NotSerializableException`.\n\n\n## Recommendation\nComparators should be serializable if they are used in sorted collections that may be serialized. In most cases, simply changing the comparator so it also implements `Serializable` is enough. Comparators that have internal state may require additional changes (for example, custom `writeObject` and `readObject` methods). In these cases, it is best to follow general best practices for serializable objects (see references below).\n\n\n## Example\nIn the following example, `WrongComparator` is not serializable because it does not implement `Serializable`. However, `StringComparator` is serializable because it does implement `Serializable`.\n\n\n```java\n// BAD: This is not serializable, and throws a 'java.io.NotSerializableException'\n// when used in a serializable sorted collection.\nclass WrongComparator implements Comparator<String> {\n    public int compare(String o1, String o2) {\n        return o1.compareTo(o2);\n    }\n}\n\n// GOOD: This is serializable, and can be used in collections that are meant to be serialized.\nclass StringComparator implements Comparator<String>, Serializable {\n    private static final long serialVersionUID = -5972458403679726498L;\n\n    public int compare(String arg0, String arg1) {\n        return arg0.compareTo(arg1);\n    }\n}\n```\n\n## References\n* Java API Specification: [Comparator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html), [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n",
                      "text": "# Non-serializable comparator\nA class that implements `java.util.Comparator` and is used to construct a sorted collection needs to be serializable. An ordered collection (such as a `java.util.TreeMap`) that is constructed using a comparator serializes successfully only if the comparator is serializable.\n\nThe `Collection`s in the Java Standard Library that require a comparator (`TreeSet`, `TreeMap`, `PriorityQueue`) all call `ObjectOutputStream.defaultWriteObject`, which tries to serialize every non-static, non-transient field in the class. As the comparator is stored in a field in these collections, the attempt to serialize a non-serializable comparator throws a `java.io.NotSerializableException`.\n\n\n## Recommendation\nComparators should be serializable if they are used in sorted collections that may be serialized. In most cases, simply changing the comparator so it also implements `Serializable` is enough. Comparators that have internal state may require additional changes (for example, custom `writeObject` and `readObject` methods). In these cases, it is best to follow general best practices for serializable objects (see references below).\n\n\n## Example\nIn the following example, `WrongComparator` is not serializable because it does not implement `Serializable`. However, `StringComparator` is serializable because it does implement `Serializable`.\n\n\n```java\n// BAD: This is not serializable, and throws a 'java.io.NotSerializableException'\n// when used in a serializable sorted collection.\nclass WrongComparator implements Comparator<String> {\n    public int compare(String o1, String o2) {\n        return o1.compareTo(o2);\n    }\n}\n\n// GOOD: This is serializable, and can be used in collections that are meant to be serialized.\nclass StringComparator implements Comparator<String>, Serializable {\n    private static final long serialVersionUID = -5972458403679726498L;\n\n    public int compare(String arg0, String arg1) {\n        return arg0.compareTo(arg1);\n    }\n}\n```\n\n## References\n* Java API Specification: [Comparator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html), [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n"
                    },
                    "id": "java/non-serializable-comparator",
                    "name": "java/non-serializable-comparator",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableComparator.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-serializable comparator"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A non-transient field in a serializable class must also be serializable otherwise it causes the class to fail to serialize with a 'NotSerializableException'."
                    },
                    "help": {
                      "markdown": "# Non-serializable field\nIf a serializable class is serialized using the default Java serialization mechanism, each non-static, non-transient field in the class must also be serializable. Otherwise, the class generates a `java.io.NotSerializableException` as its fields are written out by `ObjectOutputStream.writeObject`.\n\nAs an exception, classes that define their own `readObject` and `writeObject` methods can have fields that are not themselves serializable. The `readObject` and `writeObject` methods are responsible for encoding any state in those fields that needs to be serialized.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Mark the field as `transient` :** Marking the field as `transient` makes the serialization mechanism skip the field. Before doing this, make sure that the field is not really intended to be part of the persistent state of the object.\n* **Define custom `readObject` and `writeObject` methods for the `Serializable` class :** Explicitly defining the `readObject` and `writeObject` methods enables you to choose which fields to read from, or write to, an object stream during serialization.\n* **Make the type of the field `Serializable` :** If the field is part of the object's persistent state and you wish to use Java's default serialization mechanism, the type of the field must implement `Serializable`. When choosing this option, make sure that you follow best practices for serialization.\n\n## Example 1\nIn the following example, `WrongPerformanceRecord` contains a field `factors` that is not serializable but is in a serializable class. This causes a `java.io.NotSerializableException` when the field is written out by `writeObject`. However, `PerformanceRecord` contains a field `factors` that is marked as `transient`, so that the serialization mechanism skips the field. This means that a correctly serialized record is output by `writeObject`.\n\n\n```java\nclass DerivedFactors {             // Class that contains derived values computed from entries in a\n    private Number efficiency;     // performance record\n    private Number costPerItem;\n    private Number profitPerItem;\n    ...\n}\n\nclass WrongPerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    private DerivedFactors factors;  // BAD: 'DerivedFactors' is not serializable\n                                     // but is in a serializable class. This\n                                     // causes a 'java.io.NotSerializableException'\n                                     // when 'WrongPerformanceRecord' is serialized.\n    ...\n}\n\nclass PerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    transient private DerivedFactors factors;  // GOOD: 'DerivedFactors' is declared\n                                               // 'transient' so it does not contribute to the\n                                               // serializable state of 'PerformanceRecord'.\n    ...\n}\n\n```\n\n## Example 2\nIn this second example, `WrongPair` takes two generic parameters `L` and `R`. The class itself is serializable, but users of this class are not forced to pass serializable objects to its constructor, which could lead to problems during serialization. The solution is to set upper type bounds for the parameters, to force the user to supply only serializable objects. A similar example is the `WrongEvent` class, which takes a weakly typed `eventData` object. A better solution is to force the user to supply an object whose class implements the `Serializable` interface.\n\n\n```java\nclass WrongPair<L, R> implements Serializable{\n    private final L left;            // BAD\n    private final R right;           // BAD: L and R are not guaranteed to be serializable\n\n    public WrongPair(L left, R right){ ... }\n\n    ...\n}\n\nclass Pair<L extends Serializable, R extends Serializable> implements Serializable{\n    private final L left;            // GOOD: L and R must implement Serializable\n    private final R right;\n\n    public Pair(L left, R right){ ... }\n\n    ...\n}\n\nclass WrongEvent implements Serializable{\n    private Object eventData;        // BAD: Type is too general.\n\n    public WrongEvent(Object eventData){ ... }\n}\n\nclass Event implements Serializable{\n    private Serializable eventData;  // GOOD: Force the user to supply only serializable data\n\n    public Event(Serializable eventData){ ... }\n}\n\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html).\n",
                      "text": "# Non-serializable field\nIf a serializable class is serialized using the default Java serialization mechanism, each non-static, non-transient field in the class must also be serializable. Otherwise, the class generates a `java.io.NotSerializableException` as its fields are written out by `ObjectOutputStream.writeObject`.\n\nAs an exception, classes that define their own `readObject` and `writeObject` methods can have fields that are not themselves serializable. The `readObject` and `writeObject` methods are responsible for encoding any state in those fields that needs to be serialized.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Mark the field as `transient` :** Marking the field as `transient` makes the serialization mechanism skip the field. Before doing this, make sure that the field is not really intended to be part of the persistent state of the object.\n* **Define custom `readObject` and `writeObject` methods for the `Serializable` class :** Explicitly defining the `readObject` and `writeObject` methods enables you to choose which fields to read from, or write to, an object stream during serialization.\n* **Make the type of the field `Serializable` :** If the field is part of the object's persistent state and you wish to use Java's default serialization mechanism, the type of the field must implement `Serializable`. When choosing this option, make sure that you follow best practices for serialization.\n\n## Example 1\nIn the following example, `WrongPerformanceRecord` contains a field `factors` that is not serializable but is in a serializable class. This causes a `java.io.NotSerializableException` when the field is written out by `writeObject`. However, `PerformanceRecord` contains a field `factors` that is marked as `transient`, so that the serialization mechanism skips the field. This means that a correctly serialized record is output by `writeObject`.\n\n\n```java\nclass DerivedFactors {             // Class that contains derived values computed from entries in a\n    private Number efficiency;     // performance record\n    private Number costPerItem;\n    private Number profitPerItem;\n    ...\n}\n\nclass WrongPerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    private DerivedFactors factors;  // BAD: 'DerivedFactors' is not serializable\n                                     // but is in a serializable class. This\n                                     // causes a 'java.io.NotSerializableException'\n                                     // when 'WrongPerformanceRecord' is serialized.\n    ...\n}\n\nclass PerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    transient private DerivedFactors factors;  // GOOD: 'DerivedFactors' is declared\n                                               // 'transient' so it does not contribute to the\n                                               // serializable state of 'PerformanceRecord'.\n    ...\n}\n\n```\n\n## Example 2\nIn this second example, `WrongPair` takes two generic parameters `L` and `R`. The class itself is serializable, but users of this class are not forced to pass serializable objects to its constructor, which could lead to problems during serialization. The solution is to set upper type bounds for the parameters, to force the user to supply only serializable objects. A similar example is the `WrongEvent` class, which takes a weakly typed `eventData` object. A better solution is to force the user to supply an object whose class implements the `Serializable` interface.\n\n\n```java\nclass WrongPair<L, R> implements Serializable{\n    private final L left;            // BAD\n    private final R right;           // BAD: L and R are not guaranteed to be serializable\n\n    public WrongPair(L left, R right){ ... }\n\n    ...\n}\n\nclass Pair<L extends Serializable, R extends Serializable> implements Serializable{\n    private final L left;            // GOOD: L and R must implement Serializable\n    private final R right;\n\n    public Pair(L left, R right){ ... }\n\n    ...\n}\n\nclass WrongEvent implements Serializable{\n    private Object eventData;        // BAD: Type is too general.\n\n    public WrongEvent(Object eventData){ ... }\n}\n\nclass Event implements Serializable{\n    private Serializable eventData;  // GOOD: Force the user to supply only serializable data\n\n    public Event(Serializable eventData){ ... }\n}\n\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html).\n"
                    },
                    "id": "java/non-serializable-field",
                    "name": "java/non-serializable-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableField.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-serializable field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A class that is serializable with an enclosing class that is not serializable causes serialization to fail."
                    },
                    "help": {
                      "markdown": "# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n",
                      "text": "# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n"
                    },
                    "id": "java/non-serializable-inner-class",
                    "name": "java/non-serializable-inner-class",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableInnerClass.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serializable inner class of non-serializable class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-static nested class keeps a reference to the enclosing object, which makes the nested class bigger and may cause a memory leak."
                    },
                    "help": {
                      "markdown": "# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n",
                      "text": "# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n"
                    },
                    "id": "java/non-static-nested-class",
                    "name": "java/non-static-nested-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InnerClassCouldBeStatic.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inner class could be static"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An integer literal that starts with '0' may cause a problem. If the '0' is intentional, a programmer may misread the literal as a decimal literal. If the '0' is unintentional and a decimal literal is intended, the compiler treats the literal as an octal literal."
                    },
                    "help": {
                      "markdown": "# Use of octal values\nAn integer literal consisting of a leading `0` digit followed by one or more digits in the range `0-7` is an octal literal. This can lead to two problems:\n\n* An octal literal can be misread by a programmer as a decimal literal.\n* A programmer might accidentally start a decimal literal with a zero, so that the compiler treats the decimal literal as an octal literal. For example, `010` is equal to `8`, not `10`.\n\n## Recommendation\nTo avoid these problems:\n\n* Avoid using octal literals so that programmers do not confuse them with decimal literals. However, if you need to use octal literals, you should add a comment to each octal literal indicating the intention to use octal literals.\n* When typing decimal literals, be careful not to begin them with a zero accidentally.\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 59. Addison-Wesley, 2005.\n* Java Language Specification: [Integer Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1).\n",
                      "text": "# Use of octal values\nAn integer literal consisting of a leading `0` digit followed by one or more digits in the range `0-7` is an octal literal. This can lead to two problems:\n\n* An octal literal can be misread by a programmer as a decimal literal.\n* A programmer might accidentally start a decimal literal with a zero, so that the compiler treats the decimal literal as an octal literal. For example, `010` is equal to `8`, not `10`.\n\n## Recommendation\nTo avoid these problems:\n\n* Avoid using octal literals so that programmers do not confuse them with decimal literals. However, if you need to use octal literals, you should add a comment to each octal literal indicating the intention to use octal literals.\n* When typing decimal literals, be careful not to begin them with a zero accidentally.\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 59. Addison-Wesley, 2005.\n* Java Language Specification: [Integer Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1).\n"
                    },
                    "id": "java/octal-literal",
                    "name": "java/octal-literal",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/OctalLiteral.ql",
                      "tags": [
                        "correctness",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use of octal values"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An assignment to a local variable that is not used before a further assignment is made has no effect."
                    },
                    "help": {
                      "markdown": "# Assigned value is overwritten\nA value is assigned to a local variable, but whenever the variable is subsequently read, there has been at least one other assignment to that variable. This means that the original assignment is suspect, because the state of the local variable that it creates is never used.\n\n\n## Recommendation\nEnsure that you check the control and data flow in the method carefully. If a value is really not needed, consider omitting the assignment. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.\n\n\n## Example\nIn the following example, the value assigned to `result` on line 5 is always overwritten (line 6) before being read (line 7). This is a strong indicator that there is something wrong. By examining the code, we can see that the loop in lines 3-5 seems to be left over from an old way of storing the list of persons, and line 6 represents the new (and better-performing) way. Consequently, we can delete lines 3-5 while preserving behavior.\n\n\n```java\nPerson find(String name) {\n\tPerson result;\n\tfor (Person p : people.values())\n\t\tif (p.getName().equals(name))\n\t\t\tresult = p;  // Redundant assignment\n\tresult = people.get(name);\n\treturn result;\n```\n",
                      "text": "# Assigned value is overwritten\nA value is assigned to a local variable, but whenever the variable is subsequently read, there has been at least one other assignment to that variable. This means that the original assignment is suspect, because the state of the local variable that it creates is never used.\n\n\n## Recommendation\nEnsure that you check the control and data flow in the method carefully. If a value is really not needed, consider omitting the assignment. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.\n\n\n## Example\nIn the following example, the value assigned to `result` on line 5 is always overwritten (line 6) before being read (line 7). This is a strong indicator that there is something wrong. By examining the code, we can see that the loop in lines 3-5 seems to be left over from an old way of storing the list of persons, and line 6 represents the new (and better-performing) way. Consequently, we can delete lines 3-5 while preserving behavior.\n\n\n```java\nPerson find(String name) {\n\tPerson result;\n\tfor (Person p : people.values())\n\t\tif (p.getName().equals(name))\n\t\t\tresult = p;  // Redundant assignment\n\tresult = people.get(name);\n\treturn result;\n```\n"
                    },
                    "id": "java/overwritten-assignment-to-local",
                    "name": "java/overwritten-assignment-to-local",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/DeadStoreOfLocal.ql",
                      "tags": [
                        "external/cwe/cwe-563",
                        "maintainability",
                        "readability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assigned value is overwritten"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Directly printing an array, without first converting the array to a string, produces unreadable results."
                    },
                    "help": {
                      "markdown": "# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/print-array",
                    "name": "java/print-array",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/PrintLnArray.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Implicit conversion from array to string"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Creating an instance of 'Random' for each pseudo-random number required does not guarantee an evenly distributed sequence of random numbers."
                    },
                    "help": {
                      "markdown": "# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n",
                      "text": "# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n"
                    },
                    "id": "java/random-used-once",
                    "name": "java/random-used-once",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/RandomUsedOnce.ql",
                      "tags": [
                        "external/cwe/cwe-335",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Random used only once"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Parameterizing a call to a constructor of a generic type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized constructor invocation\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized constructor invocation\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-constructor-invocation",
                    "name": "java/raw-constructor-invocation",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsConstructor.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized constructor invocation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a parameterized instance of a generic type for a method return type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized method return type\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized method return type\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-return-type",
                    "name": "java/raw-return-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsReturnType.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized method return type"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Declaring a field, parameter, or local variable as a parameterized type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized variable\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized variable\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-variable",
                    "name": "java/raw-variable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsVariable.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Casting an object to its own type is unnecessary."
                    },
                    "help": {
                      "markdown": "# Unnecessary cast\nA cast is unnecessary if the type of the operand is already the same as the type that is being cast to.\n\n\n## Recommendation\nAvoid including unnecessary casts.\n\n\n## Example\nIn the following example, casting `i` to an `Integer` is not necessary. It is already an `Integer`.\n\n\n```java\npublic class UnnecessaryCast {\n    public static void main(String[] args) {\n        Integer i = 23;\n        Integer j = (Integer)i;  // AVOID: Redundant cast\n    }\n}\n```\nTo fix the code, delete `(Integer)` on the right-hand side of the assignment on line 4.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unnecessary cast\nA cast is unnecessary if the type of the operand is already the same as the type that is being cast to.\n\n\n## Recommendation\nAvoid including unnecessary casts.\n\n\n## Example\nIn the following example, casting `i` to an `Integer` is not necessary. It is already an `Integer`.\n\n\n```java\npublic class UnnecessaryCast {\n    public static void main(String[] args) {\n        Integer i = 23;\n        Integer j = (Integer)i;  // AVOID: Redundant cast\n    }\n}\n```\nTo fix the code, delete `(Integer)` on the right-hand side of the assignment on line 4.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/redundant-cast",
                    "name": "java/redundant-cast",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/UnnecessaryCast.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unnecessary cast"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit' may cause finalizers to be run on live objects, leading to erratic behavior or deadlock."
                    },
                    "help": {
                      "markdown": "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n",
                      "text": "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n"
                    },
                    "id": "java/run-finalizers-on-exit",
                    "name": "java/run-finalizers-on-exit",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToRunFinalizersOnExit.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dangerous runFinalizersOnExit"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Files in which most of the lines are similar to those in another file make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly similar file\nWhen most of the lines in one file have corresponding \"similar\" lines in one or more other files, the files themselves are regarded as *mostly similar*. Two lines are defined as similar if they are either identical or contain only very minor differences.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nConsider whether the differences are deliberate or a result of an inconsistent update to one of the clones. If the latter, then treating the files as completely duplicate and eliminating all but one (while preserving any corrections or new features that may have been introduced) is the best course. If two files serve genuinely different purposes but almost all of their lines are the same, that can be a sign that there is a missing level of abstraction. Can some of the shared code be extracted into methods (perhaps with additional parameters, to cover the differences in behavior)? Should it be moved into a utility class or file that is accessible to all current implementations, or should a new level of abstraction be introduced?\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly similar file\nWhen most of the lines in one file have corresponding \"similar\" lines in one or more other files, the files themselves are regarded as *mostly similar*. Two lines are defined as similar if they are either identical or contain only very minor differences.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nConsider whether the differences are deliberate or a result of an inconsistent update to one of the clones. If the latter, then treating the files as completely duplicate and eliminating all but one (while preserving any corrections or new features that may have been introduced) is the best course. If two files serve genuinely different purposes but almost all of their lines are the same, that can be a sign that there is a missing level of abstraction. Can some of the shared code be extracted into methods (perhaps with additional parameters, to cover the differences in behavior)? Should it be moved into a utility class or file that is accessible to all current implementations, or should a new level of abstraction be introduced?\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/similar-file",
                    "name": "java/similar-file",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlySimilarFile.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly similar file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Methods in which most of the lines are duplicated in another method make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate method\nWhen most of the lines in one method are duplicated in one or more other methods, the methods themselves are regarded as *mostly duplicate* or *similar*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated methods are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many lines between two methods, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies.\n\n* If the two methods serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways of encapsulating the commonality and sharing it while retaining the differences in functionality. Perhaps the method can be moved to a single place and given an additional parameter, allowing it to cover all use cases. Alternatively, there may be a common pre-processing or post-processing step that can be extracted to its own (shared) method, leaving only the specific parts in the existing methods. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Extract method\", \"Change method signature\", \"Pull up\" or \"Extract supertype\".\n* If the two methods serve the same purpose and are different only as a result of inconsistent updates then treat the methods as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates. Callers of the removed methods should be updated to call the remaining method instead.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate method\nWhen most of the lines in one method are duplicated in one or more other methods, the methods themselves are regarded as *mostly duplicate* or *similar*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated methods are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many lines between two methods, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies.\n\n* If the two methods serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways of encapsulating the commonality and sharing it while retaining the differences in functionality. Perhaps the method can be moved to a single place and given an additional parameter, allowing it to cover all use cases. Alternatively, there may be a common pre-processing or post-processing step that can be extracted to its own (shared) method, leaving only the specific parts in the existing methods. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Extract method\", \"Change method signature\", \"Pull up\" or \"Extract supertype\".\n* If the two methods serve the same purpose and are different only as a result of inconsistent updates then treat the methods as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates. Callers of the removed methods should be updated to call the remaining method instead.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/similar-method",
                    "name": "java/similar-method",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateMethod.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using autowiring in Spring beans may make it difficult to maintain large projects."
                    },
                    "help": {
                      "markdown": "# Avoid autowiring\nUsing Spring autowiring can make it difficult to see what beans get passed to constructors or setters. The Spring Framework Reference documentation cites the following disadvantages of autowiring:\n\n* Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire so-called *simple* properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by design.\n* Autowiring is less exact than explicit wiring. Although ... Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.\n* Wiring information may not be available to tools that may generate documentation from a Spring container.\n* Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.\n\n## Recommendation\nThe Spring Framework Reference documentation suggests the following ways to address problems with autowired beans:\n\n* Abandon autowiring in favor of explicit wiring.\n* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`.\n* Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to true.\n* If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration.\n\n## Example\nThe following example shows a bean, `autoWiredOrderService`, that is defined using autowiring, and an improved version of the bean, `orderService`, that is defined using explicit wiring.\n\n\n```xml\n<!--AVOID: Using autowiring makes it difficult to see the dependencies of the bean-->\n<bean id=\"autoWiredOrderService\"\n        class=\"documentation.examples.spring.OrderService\"\n        autowire=\"byName\"/>\n\n<!--GOOD: Explicitly specifying the properties of the bean documents its dependencies\n    and makes the bean configuration easier to maintain-->\n<bean id=\"orderService\"\n        class=\"documentation.examples.spring.OrderService\">\n        <property name=\"DAO\">\n            <idref bean=\"dao\"/>\n        </property>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.5.1 Limitations and disadvantages of autowiring](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-autowired-exceptions).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n",
                      "text": "# Avoid autowiring\nUsing Spring autowiring can make it difficult to see what beans get passed to constructors or setters. The Spring Framework Reference documentation cites the following disadvantages of autowiring:\n\n* Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire so-called *simple* properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by design.\n* Autowiring is less exact than explicit wiring. Although ... Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.\n* Wiring information may not be available to tools that may generate documentation from a Spring container.\n* Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.\n\n## Recommendation\nThe Spring Framework Reference documentation suggests the following ways to address problems with autowired beans:\n\n* Abandon autowiring in favor of explicit wiring.\n* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`.\n* Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to true.\n* If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration.\n\n## Example\nThe following example shows a bean, `autoWiredOrderService`, that is defined using autowiring, and an improved version of the bean, `orderService`, that is defined using explicit wiring.\n\n\n```xml\n<!--AVOID: Using autowiring makes it difficult to see the dependencies of the bean-->\n<bean id=\"autoWiredOrderService\"\n        class=\"documentation.examples.spring.OrderService\"\n        autowire=\"byName\"/>\n\n<!--GOOD: Explicitly specifying the properties of the bean documents its dependencies\n    and makes the bean configuration easier to maintain-->\n<bean id=\"orderService\"\n        class=\"documentation.examples.spring.OrderService\">\n        <property name=\"DAO\">\n            <idref bean=\"dao\"/>\n        </property>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.5.1 Limitations and disadvantages of autowiring](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-autowired-exceptions).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n"
                    },
                    "id": "java/spring/autowiring",
                    "name": "java/spring/autowiring",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/AvoidAutowiring.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Avoid autowiring"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using 'id' instead of 'name' to name a Spring bean enables the XML parser to perform additional checks."
                    },
                    "help": {
                      "markdown": "# Use id instead of name\nTo name a Spring bean, it is best to use the `id` attribute instead of the `name` attribute. Using the `id` attribute enables the XML parser to perform additional checks (for example, checking if the `id` in a `ref` attribute is an actual `id` of an XML element).\n\n\n## Recommendation\nUse the `id` attribute instead of the `name` attribute when naming a bean.\n\n\n## Example\nIn the following example, the `dao` bean is shown using the `name` attribute, which allows a typo to go undetected because the XML parser does not check `name`. In contrast, using the `id` attribute allows the XML parser to catch the typo.\n\n\n```xml\n<!--AVOID: Using the 'name' attribute disables checking of bean references at XML parse time-->\n<bean name=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser cannot catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n\n\n<!--GOOD: Using the 'id' attribute enables checking of bean references at XML parse time-->\n<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser can catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.3.1 Naming beans](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-beanname).\n* W3C: [3.3.1 Attribute Types](http://www.w3.org/TR/REC-xml/#sec-attribute-types).\n",
                      "text": "# Use id instead of name\nTo name a Spring bean, it is best to use the `id` attribute instead of the `name` attribute. Using the `id` attribute enables the XML parser to perform additional checks (for example, checking if the `id` in a `ref` attribute is an actual `id` of an XML element).\n\n\n## Recommendation\nUse the `id` attribute instead of the `name` attribute when naming a bean.\n\n\n## Example\nIn the following example, the `dao` bean is shown using the `name` attribute, which allows a typo to go undetected because the XML parser does not check `name`. In contrast, using the `id` attribute allows the XML parser to catch the typo.\n\n\n```xml\n<!--AVOID: Using the 'name' attribute disables checking of bean references at XML parse time-->\n<bean name=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser cannot catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n\n\n<!--GOOD: Using the 'id' attribute enables checking of bean references at XML parse time-->\n<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser can catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.3.1 Naming beans](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-beanname).\n* W3C: [3.3.1 Attribute Types](http://www.w3.org/TR/REC-xml/#sec-attribute-types).\n"
                    },
                    "id": "java/spring/bean-id",
                    "name": "java/spring/bean-id",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseIdInsteadOfName.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use id instead of name"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a type name instead of an index number in a Spring 'constructor-arg' element improves readability."
                    },
                    "help": {
                      "markdown": "# Use constructor-arg types instead of index\nUsing type matching instead of index matching in a Spring `constructor-arg` element produces a more readable bean definition and is less vulnerable to being broken by a change to the constructor of the bean's underlying class. Index matching should be used only if type matching is not sufficient to remove ambiguity in the constructor arguments.\n\n\n## Recommendation\nThe bean definition's `constructor-arg` elements should use type matching instead of index matching.\n\n\n## Example\nThe following example shows a bean, `billingService1`, whose `constructor-arg` elements use index matching, and an improved version of the bean, `billingService2`, whose `constructor-arg` elements use type matching.\n\n\n```xml\n<!--AVOID: Using explicit constructor indices makes the bean configuration\n           vulnerable to changes to the constructor-->\n<bean id=\"billingService1\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg index=\"0\" value=\"John Doe\"/>\n    <constructor-arg index=\"1\" ref=\"dao\"/>\n</bean>\n\n<!--GOOD: Using type matching makes the bean configuration more robust to changes in\n    the constructor-->\n<bean id=\"billingService2\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg ref=\"dao\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"Jane Doe\"/>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=2).\n",
                      "text": "# Use constructor-arg types instead of index\nUsing type matching instead of index matching in a Spring `constructor-arg` element produces a more readable bean definition and is less vulnerable to being broken by a change to the constructor of the bean's underlying class. Index matching should be used only if type matching is not sufficient to remove ambiguity in the constructor arguments.\n\n\n## Recommendation\nThe bean definition's `constructor-arg` elements should use type matching instead of index matching.\n\n\n## Example\nThe following example shows a bean, `billingService1`, whose `constructor-arg` elements use index matching, and an improved version of the bean, `billingService2`, whose `constructor-arg` elements use type matching.\n\n\n```xml\n<!--AVOID: Using explicit constructor indices makes the bean configuration\n           vulnerable to changes to the constructor-->\n<bean id=\"billingService1\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg index=\"0\" value=\"John Doe\"/>\n    <constructor-arg index=\"1\" ref=\"dao\"/>\n</bean>\n\n<!--GOOD: Using type matching makes the bean configuration more robust to changes in\n    the constructor-->\n<bean id=\"billingService2\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg ref=\"dao\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"Jane Doe\"/>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=2).\n"
                    },
                    "id": "java/spring/constructor-arg-index",
                    "name": "java/spring/constructor-arg-index",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/DontUseConstructorArgIndex.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use constructor-arg types instead of index"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "When using the Spring Framework, using setter injection instead of constructor injection is more flexible, especially when several properties are optional."
                    },
                    "help": {
                      "markdown": "# Use setter injection instead of constructor injection\nWhen you use the Spring Framework, using setter injection instead of constructor injection is more flexible, particularly for Spring beans with a large number of optional properties. Constructor injection should be used only on required bean properties; using constructor injection on optional bean properties requires a large number of constructors to handle different combinations of properties.\n\nAlthough the generally accepted best practice is to use constructor injection for mandatory dependencies, and setter injection for optional dependencies, the `@Required` annotation allows you to forgo constructor injection completely. Using the `@Required` annotation on a setter method makes the framework check that a dependency is injected using that method.\n\n\n## Recommendation\nUse setter injection in bean configurations, marking required properties with the `@Required` annotation. It makes it easier to accommodate a large number of optional properties, and makes the bean more flexible by allowing for re-injection of dependencies.\n\n\n## Example\nThe following example shows a bean that is defined using constructor injection. The bean configuration is followed by the class definition.\n\n\n```xml\n<!--AVOID: Using constructor args for optional parameters requires one constructor per combination\nof properties. This leads to a large number of constructors in the bean class.-->\n<bean id=\"chart1\" class=\"documentation.examples.spring.WrongChartMaker\">\n\t<constructor-arg ref=\"customTrend\"/>\n\t<constructor-arg ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart1'\npublic class WrongChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic WrongChartMaker() {}\n\n\t// Each combination of the optional parameters must be represented by a constructor.\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(TrendRenderer customTrendRenderer) {\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer, \n\t\t\t\t\t\t\tTrendRenderer customTrendRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n}\n```\nThe following example shows how the same bean can be defined using setter injection instead. Again, the bean configuration is followed by the class definition.\n\n\n```xml\n<!--GOOD: Using setter injection requires only one setter for each property.-->\n<bean id=\"chart2\" class=\"documentation.examples.spring.ChartMaker\">\n\t<property name=\"axisRenderer\" ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart2'\npublic class ChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic ChartMaker() {}\n\t\n\tpublic void setAxisRenderer(AxisRenderer axisRenderer) {\n\t\tthis.axisRenderer = axisRenderer;\n\t}\n\t\n\tpublic void setTrendRenderer(TrendRenderer trendRenderer) {\n\t\tthis.trendRenderer = trendRenderer;\n\t}\n}\n```\n\n## References\n* Martin Fowler: [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html).\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection), [3.4.1.2 Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n* SpringSource: [Setter injection versus constructor injection and the use of @Required](https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/).\n",
                      "text": "# Use setter injection instead of constructor injection\nWhen you use the Spring Framework, using setter injection instead of constructor injection is more flexible, particularly for Spring beans with a large number of optional properties. Constructor injection should be used only on required bean properties; using constructor injection on optional bean properties requires a large number of constructors to handle different combinations of properties.\n\nAlthough the generally accepted best practice is to use constructor injection for mandatory dependencies, and setter injection for optional dependencies, the `@Required` annotation allows you to forgo constructor injection completely. Using the `@Required` annotation on a setter method makes the framework check that a dependency is injected using that method.\n\n\n## Recommendation\nUse setter injection in bean configurations, marking required properties with the `@Required` annotation. It makes it easier to accommodate a large number of optional properties, and makes the bean more flexible by allowing for re-injection of dependencies.\n\n\n## Example\nThe following example shows a bean that is defined using constructor injection. The bean configuration is followed by the class definition.\n\n\n```xml\n<!--AVOID: Using constructor args for optional parameters requires one constructor per combination\nof properties. This leads to a large number of constructors in the bean class.-->\n<bean id=\"chart1\" class=\"documentation.examples.spring.WrongChartMaker\">\n\t<constructor-arg ref=\"customTrend\"/>\n\t<constructor-arg ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart1'\npublic class WrongChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic WrongChartMaker() {}\n\n\t// Each combination of the optional parameters must be represented by a constructor.\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(TrendRenderer customTrendRenderer) {\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer, \n\t\t\t\t\t\t\tTrendRenderer customTrendRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n}\n```\nThe following example shows how the same bean can be defined using setter injection instead. Again, the bean configuration is followed by the class definition.\n\n\n```xml\n<!--GOOD: Using setter injection requires only one setter for each property.-->\n<bean id=\"chart2\" class=\"documentation.examples.spring.ChartMaker\">\n\t<property name=\"axisRenderer\" ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart2'\npublic class ChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic ChartMaker() {}\n\t\n\tpublic void setAxisRenderer(AxisRenderer axisRenderer) {\n\t\tthis.axisRenderer = axisRenderer;\n\t}\n\t\n\tpublic void setTrendRenderer(TrendRenderer trendRenderer) {\n\t\tthis.trendRenderer = trendRenderer;\n\t}\n}\n```\n\n## References\n* Martin Fowler: [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html).\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection), [3.4.1.2 Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n* SpringSource: [Setter injection versus constructor injection and the use of @Required](https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/).\n"
                    },
                    "id": "java/spring/constructor-injection",
                    "name": "java/spring/constructor-injection",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseSetterInjection.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use setter injection instead of constructor injection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Putting 'import' statements before bean definitions in a Spring bean configuration file makes it easier to immediately see all the file's dependencies."
                    },
                    "help": {
                      "markdown": "# Imports should come before bean definitions\nPutting `import` statements at the top of Spring XML bean definition files is good practice because they give a quick summary of the file's dependencies, and can even be used to document the general architecture of a system.\n\n\n## Recommendation\nMake sure that all `import` statements are at the top of the `<beans>` section of a Spring XML bean definition file.\n\n\n## Example\nThe following example shows a `<beans>` section of a Spring XML bean definition file in which an `import` statement is in the middle, and a `<beans>` section in which all the `import` statements are at the top.\n\n\n```xml\n<beans>\n    <import resource=\"services.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    \n    <!--AVOID: Imports in the middle of a bean configuration make it difficult\n        to immediately determine the dependencies of the configuration-->\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n\n<beans>\n    <!--GOOD: Having the imports at the top immediately gives an idea of\n        what the dependencies of the configuration are-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n",
                      "text": "# Imports should come before bean definitions\nPutting `import` statements at the top of Spring XML bean definition files is good practice because they give a quick summary of the file's dependencies, and can even be used to document the general architecture of a system.\n\n\n## Recommendation\nMake sure that all `import` statements are at the top of the `<beans>` section of a Spring XML bean definition file.\n\n\n## Example\nThe following example shows a `<beans>` section of a Spring XML bean definition file in which an `import` statement is in the middle, and a `<beans>` section in which all the `import` statements are at the top.\n\n\n```xml\n<beans>\n    <import resource=\"services.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    \n    <!--AVOID: Imports in the middle of a bean configuration make it difficult\n        to immediately determine the dependencies of the configuration-->\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n\n<beans>\n    <!--GOOD: Having the imports at the top immediately gives an idea of\n        what the dependencies of the configuration are-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n"
                    },
                    "id": "java/spring/import-location",
                    "name": "java/spring/import-location",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/ImportsFirst.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Imports should come before bean definitions"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Adding 'description' elements to a Spring XML bean definition file is good practice."
                    },
                    "help": {
                      "markdown": "# This bean does not have a description element\nIn a Spring XML bean definition file, adding a `<description>` element to a `<bean>` element or the enclosing `<beans>` element to document the purpose of the bean specification is good practice. A `description` element also has the advantage of making it easier for tools to detect and display the documentation for your bean specifications.\n\n\n## Recommendation\nAdd a `<description>` element either in the `<bean>` element or its enclosing `<beans>` element.\n\n\n## Example\nThe following example shows a Spring XML bean definition file that includes `<description>` elements.\n\n\n```xml\n<beans>\n\t<!--Using a description element makes it easier for tools to pick up\n\t    documentation of the bean configuration-->\n\t<description>\n\tThis file configures the various service beans.\n\t</description>\n\t\n\t<!--You can also put a description element in a bean-->\n\t<bean id=\"baseService\" abstract=\"true\">\n\t\t<description>\n\t\tThis bean defines base properties common to the service beans\n\t\t</description>\n\t\t...\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n\t\n\t<bean id=\"orderService\" \n\t\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n</beans>\n```\n\n## References\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n",
                      "text": "# This bean does not have a description element\nIn a Spring XML bean definition file, adding a `<description>` element to a `<bean>` element or the enclosing `<beans>` element to document the purpose of the bean specification is good practice. A `description` element also has the advantage of making it easier for tools to detect and display the documentation for your bean specifications.\n\n\n## Recommendation\nAdd a `<description>` element either in the `<bean>` element or its enclosing `<beans>` element.\n\n\n## Example\nThe following example shows a Spring XML bean definition file that includes `<description>` elements.\n\n\n```xml\n<beans>\n\t<!--Using a description element makes it easier for tools to pick up\n\t    documentation of the bean configuration-->\n\t<description>\n\tThis file configures the various service beans.\n\t</description>\n\t\n\t<!--You can also put a description element in a bean-->\n\t<bean id=\"baseService\" abstract=\"true\">\n\t\t<description>\n\t\tThis bean defines base properties common to the service beans\n\t\t</description>\n\t\t...\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n\t\n\t<bean id=\"orderService\" \n\t\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n</beans>\n```\n\n## References\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n"
                    },
                    "id": "java/spring/missing-bean-description",
                    "name": "java/spring/missing-bean-description",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/NoBeanDescription.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "This bean does not have a description element"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Beans that share similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see."
                    },
                    "help": {
                      "markdown": "# Beans sharing similar properties\nBeans that share a considerable number of similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see.\n\n\n## Recommendation\nTry to move the properties that the bean definitions share to a common parent bean. This reduces repetition in the bean definitions and gives a clearer picture of the system's architecture.\n\n\n## Example\nThe following example shows a configuration file that contains two beans that share several properties with the same values.\n\n\n```xml\n<!--AVOID: 'shippingService' and 'orderService' share several properties with the same values-->\n<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\nThe following example shows how the shared properties have been moved into a parent bean, `baseService`.\n\n\n```xml\n<!--The 'baseService' bean contains common property definitions for services.-->\n<bean id=\"baseService\" abstract=\"true\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n</bean>\n\n<bean id=\"shippingService\" \n\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\tparent=\"baseService\">\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" \n\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\tparent=\"baseService\">\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.2 References to other beans (collaborators)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-ref-element).\n",
                      "text": "# Beans sharing similar properties\nBeans that share a considerable number of similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see.\n\n\n## Recommendation\nTry to move the properties that the bean definitions share to a common parent bean. This reduces repetition in the bean definitions and gives a clearer picture of the system's architecture.\n\n\n## Example\nThe following example shows a configuration file that contains two beans that share several properties with the same values.\n\n\n```xml\n<!--AVOID: 'shippingService' and 'orderService' share several properties with the same values-->\n<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\nThe following example shows how the shared properties have been moved into a parent bean, `baseService`.\n\n\n```xml\n<!--The 'baseService' bean contains common property definitions for services.-->\n<bean id=\"baseService\" abstract=\"true\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n</bean>\n\n<bean id=\"shippingService\" \n\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\tparent=\"baseService\">\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" \n\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\tparent=\"baseService\">\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.2 References to other beans (collaborators)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-ref-element).\n"
                    },
                    "id": "java/spring/missing-parent-bean",
                    "name": "java/spring/missing-parent-bean",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/MissingParentBean.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Beans sharing similar properties"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Not declaring a setter for a property that is defined in a Spring XML file causes a compilation error."
                    },
                    "help": {
                      "markdown": "# Missing setters for property dependency injection\nThe absence of a matching setter method for a property that is defined in a Spring XML bean causes a validation error when the project is compiled.\n\n\n## Recommendation\nEnsure that there is a setter method in the bean file that matches the property name.\n\n\n## Example\nThe following example shows a bean file in which there is no match for the setter method that is in the class.\n\n\n```xml\n<bean id=\"contentService\" class=\"documentation.examples.spring.ContentService\">\n\t<!--BAD: The setter method in the class is 'setHelper', so this property\n\t         does not match the setter method.-->\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n</bean>\n\n```\nThis is the bean class.\n\n\n```java\n// bean class\npublic class ContentService {\n\tprivate TransactionHelper helper;\n\n\t// This method does not match the property in the bean file.\n\tpublic void setHelper(TransactionHelper helper) {\n\t\tthis.helper = helper;\n\t}\n}\n\n```\nThe property `transactionHelper` should instead have the name `helper`.\n\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.2 Setter-based dependency injection](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n",
                      "text": "# Missing setters for property dependency injection\nThe absence of a matching setter method for a property that is defined in a Spring XML bean causes a validation error when the project is compiled.\n\n\n## Recommendation\nEnsure that there is a setter method in the bean file that matches the property name.\n\n\n## Example\nThe following example shows a bean file in which there is no match for the setter method that is in the class.\n\n\n```xml\n<bean id=\"contentService\" class=\"documentation.examples.spring.ContentService\">\n\t<!--BAD: The setter method in the class is 'setHelper', so this property\n\t         does not match the setter method.-->\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n</bean>\n\n```\nThis is the bean class.\n\n\n```java\n// bean class\npublic class ContentService {\n\tprivate TransactionHelper helper;\n\n\t// This method does not match the property in the bean file.\n\tpublic void setHelper(TransactionHelper helper) {\n\t\tthis.helper = helper;\n\t}\n}\n\n```\nThe property `transactionHelper` should instead have the name `helper`.\n\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.2 Setter-based dependency injection](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n"
                    },
                    "id": "java/spring/missing-setter",
                    "name": "java/spring/missing-setter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/XML%20Configuration%20Errors/MissingSetters.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing setters for property dependency injection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using local references when referring to Spring beans in the same file allows reference errors to be detected during XML parsing."
                    },
                    "help": {
                      "markdown": "# Use local refs when referring to beans in the same file\nIf at all possible, refer to Spring beans in the same XML file using local references, that is `<idref local=\"targetBean\">`. This requires that the bean being referenced is in the same XML file, and is named using the `id` attribute. Using local references has the advantage of allowing reference errors to be detected during XML parsing, instead of during deployment or instantiation.\n\nFrom the Spring Framework Reference documentation on `idref` elements:\n\n> \\[Using the `idref` tag in a `property` element\\] is preferable to \\[using the bean name in the property's `value` attribute\\], because using the `idref` tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the \\[`name`\\] property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.\n\nAdditionally, if the referenced bean is in the same XML unit, and the bean name is the bean `id`, you can use the `local` attribute, which allows the XML parser itself to validate the bean `id` earlier, at XML document parse time.\n\n\n## Recommendation\nUse a local `idref` when referring to beans in the same XML file. This allows errors to be detected earlier, at XML parse time rather than during instantiation.\n\n\n## Example\nIn the following example, the `shippingService` bean is shown using the `ref` element, which cannot be checked by the XML parser. The `orderService` bean is shown using the `idref` element, which allows the XML parser to find any errors at parse time.\n\n\n```xml\n<beans>\n\t<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t\t<!--AVOID: This form of reference cannot be checked by the XML parser-->\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\t<!--GOOD: This form of reference allows the XML parser to find any errors at parse time-->\n\t\t<property name=\"dao\">\n\t\t\t<idref local=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n",
                      "text": "# Use local refs when referring to beans in the same file\nIf at all possible, refer to Spring beans in the same XML file using local references, that is `<idref local=\"targetBean\">`. This requires that the bean being referenced is in the same XML file, and is named using the `id` attribute. Using local references has the advantage of allowing reference errors to be detected during XML parsing, instead of during deployment or instantiation.\n\nFrom the Spring Framework Reference documentation on `idref` elements:\n\n> \\[Using the `idref` tag in a `property` element\\] is preferable to \\[using the bean name in the property's `value` attribute\\], because using the `idref` tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the \\[`name`\\] property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.\n\nAdditionally, if the referenced bean is in the same XML unit, and the bean name is the bean `id`, you can use the `local` attribute, which allows the XML parser itself to validate the bean `id` earlier, at XML document parse time.\n\n\n## Recommendation\nUse a local `idref` when referring to beans in the same XML file. This allows errors to be detected earlier, at XML parse time rather than during instantiation.\n\n\n## Example\nIn the following example, the `shippingService` bean is shown using the `ref` element, which cannot be checked by the XML parser. The `orderService` bean is shown using the `idref` element, which allows the XML parser to find any errors at parse time.\n\n\n```xml\n<beans>\n\t<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t\t<!--AVOID: This form of reference cannot be checked by the XML parser-->\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\t<!--GOOD: This form of reference allows the XML parser to find any errors at parse time-->\n\t\t<property name=\"dao\">\n\t\t\t<idref local=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
                    },
                    "id": "java/spring/non-local-reference",
                    "name": "java/spring/non-local-reference",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseLocalRef.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use local refs when referring to beans in the same file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using shortcut forms may make a Spring XML configuration file less cluttered."
                    },
                    "help": {
                      "markdown": "# Use shortcut forms for values\nShortcut forms, introduced in Spring 1.2, allow nested `value` elements to instead be defined as attributes in the enclosing `property` entry. This leads to shorter XML bean configurations that are easier to read.\n\n\n## Recommendation\nWhen possible, use the shortcut form for defining bean property values.\n\nNote that this does *not* apply to `idref` elements, which are the preferred form of referring to another bean. These do not have a shortcut form that can still be checked by the XML parser.\n\n\n## Example\nThe following example shows how a bean that is defined using shortcut forms is more concise than the same bean defined using nested `value` elements.\n\n\n```xml\n<!--AVOID: Using nested 'value' elements can make the configuration file difficult to read-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\">\n\t\t<value>main_service_registry</value>\n\t</constructor-arg>\n\t<property name=\"description\">\n\t\t<value>Top-level registry for services</value>\n\t</property>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>orderService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.OrderService</value>\n\t\t\t</entry>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>billingService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.BillingService</value>\n\t\t\t</entry>\n\t\t</map>\n\t</property>\n</bean>\n\n\n<!--GOOD: Shortcut forms (Spring 1.2) result in more concise bean definitions-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\" value=\"main_service_registry\"/>\n\t<property name=\"description\" value=\"Top-level registry for services\"/>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry key=\"orderService\" value=\"com.foo.bar.OrderService\"/>\n\t\t\t<entry key=\"billingService\" value=\"com.foo.bar.BillingService\"/>\n\t\t</map>\n\t</property>\n</bean>\n\n```\n\n## References\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n",
                      "text": "# Use shortcut forms for values\nShortcut forms, introduced in Spring 1.2, allow nested `value` elements to instead be defined as attributes in the enclosing `property` entry. This leads to shorter XML bean configurations that are easier to read.\n\n\n## Recommendation\nWhen possible, use the shortcut form for defining bean property values.\n\nNote that this does *not* apply to `idref` elements, which are the preferred form of referring to another bean. These do not have a shortcut form that can still be checked by the XML parser.\n\n\n## Example\nThe following example shows how a bean that is defined using shortcut forms is more concise than the same bean defined using nested `value` elements.\n\n\n```xml\n<!--AVOID: Using nested 'value' elements can make the configuration file difficult to read-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\">\n\t\t<value>main_service_registry</value>\n\t</constructor-arg>\n\t<property name=\"description\">\n\t\t<value>Top-level registry for services</value>\n\t</property>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>orderService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.OrderService</value>\n\t\t\t</entry>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>billingService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.BillingService</value>\n\t\t\t</entry>\n\t\t</map>\n\t</property>\n</bean>\n\n\n<!--GOOD: Shortcut forms (Spring 1.2) result in more concise bean definitions-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\" value=\"main_service_registry\"/>\n\t<property name=\"description\" value=\"Top-level registry for services\"/>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry key=\"orderService\" value=\"com.foo.bar.OrderService\"/>\n\t\t\t<entry key=\"billingService\" value=\"com.foo.bar.BillingService\"/>\n\t\t</map>\n\t</property>\n</bean>\n\n```\n\n## References\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
                    },
                    "id": "java/spring/non-shortcut-form",
                    "name": "java/spring/non-shortcut-form",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseShortcutForms.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use shortcut forms for values"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A non-abstract Spring bean that is a parent of other beans and specifies an abstract class causes an error during bean instantiation."
                    },
                    "help": {
                      "markdown": "# Non-abstract parent beans should not use an abstract class\nA non-abstract Spring bean that is a parent of other beans must not specify an abstract class. Doing so causes an error during bean instantiation.\n\n\n## Recommendation\nMake sure that a non-abstract bean does not specify an abstract class, by doing one of the following:\n\n* Specify that the bean is also abstract by adding `abstract=\"true\"` to the bean specification.\n* If possible, update the class that is specified by the bean so that it is not abstract.\nYou can also make the XML parent bean definition abstract and remove any references from it to any class (in which case it becomes a pure bean template). Note that, like an abstract class, an abstract bean cannot be used on its own and only provides property and constructor definitions to its children.\n\n\n## Example\nIn the following example, the bean `wrongConnectionPool` is using an abstract class, `ConnectionPool`, which causes an error. Instead, the bean should be declared `abstract`, as shown in the definition of `connectionPool`.\n\n\n```xml\n<beans>\n    <!--BAD: A non-abstract bean should use a concrete class.\n        'ConnectionPool' is an abstract class.-->\n    <bean id=\"wrongConnectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\"/>\n    <bean id=\"appReqPool1\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"wrongConnectionPool\"/>\n\n    <!--GOOD: A bean that specifies an abstract class should be declared 'abstract'.-->\n    <bean id=\"connectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\" abstract=\"true\"/>\n    <bean id=\"appReqPool2\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"connectionPool\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n",
                      "text": "# Non-abstract parent beans should not use an abstract class\nA non-abstract Spring bean that is a parent of other beans must not specify an abstract class. Doing so causes an error during bean instantiation.\n\n\n## Recommendation\nMake sure that a non-abstract bean does not specify an abstract class, by doing one of the following:\n\n* Specify that the bean is also abstract by adding `abstract=\"true\"` to the bean specification.\n* If possible, update the class that is specified by the bean so that it is not abstract.\nYou can also make the XML parent bean definition abstract and remove any references from it to any class (in which case it becomes a pure bean template). Note that, like an abstract class, an abstract bean cannot be used on its own and only provides property and constructor definitions to its children.\n\n\n## Example\nIn the following example, the bean `wrongConnectionPool` is using an abstract class, `ConnectionPool`, which causes an error. Instead, the bean should be declared `abstract`, as shown in the definition of `connectionPool`.\n\n\n```xml\n<beans>\n    <!--BAD: A non-abstract bean should use a concrete class.\n        'ConnectionPool' is an abstract class.-->\n    <bean id=\"wrongConnectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\"/>\n    <bean id=\"appReqPool1\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"wrongConnectionPool\"/>\n\n    <!--GOOD: A bean that specifies an abstract class should be declared 'abstract'.-->\n    <bean id=\"connectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\" abstract=\"true\"/>\n    <bean id=\"appReqPool2\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"connectionPool\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
                    },
                    "id": "java/spring/parent-bean-abstract-class",
                    "name": "java/spring/parent-bean-abstract-class",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/ParentShouldNotUseAbstractClass.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-abstract parent beans should not use an abstract class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Too many beans in a file can make the file difficult to understand and maintain."
                    },
                    "help": {
                      "markdown": "# Too many beans in file\nToo many bean definitions in a single file can make the file difficult to understand and maintain. It is also an indication that the architecture of the system is too tightly coupled and can be refactored.\n\n\n## Recommendation\nRefactor related bean definitions into separate files, and compose them using the `<import/>` element.\n\n\n## Example\nThe following example shows a configuration file that imports two other configuration files. These two files were created by refactoring a file that contained too many bean definitions.\n\n\n```xml\n<beans>\n    <!--Compose configuration files by using the 'import' element.-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n",
                      "text": "# Too many beans in file\nToo many bean definitions in a single file can make the file difficult to understand and maintain. It is also an indication that the architecture of the system is too tightly coupled and can be refactored.\n\n\n## Recommendation\nRefactor related bean definitions into separate files, and compose them using the `<import/>` element.\n\n\n## Example\nThe following example shows a configuration file that imports two other configuration files. These two files were created by refactoring a file that contained too many bean definitions.\n\n\n```xml\n<beans>\n    <!--Compose configuration files by using the 'import' element.-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n"
                    },
                    "id": "java/spring/too-many-beans",
                    "name": "java/spring/too-many-beans",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/TooManyBeans.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Too many beans in file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Beans that are specified but never used are redundant and should be removed."
                    },
                    "help": {
                      "markdown": "# Beans that are never used within the code\nBean definitions that are specified but are never used are redundant and can be removed. Unused beans make the program harder to understand.\n\nA bean definition is considered to be used if one or more of the following is true:\n\n* The bean is referenced or defined in the `<constructor-arg>` or `<property>` element of a live bean.\n* The bean is injected in to a constructor or method of a live bean due to autowiring. This includes autowiring by annotation (`@Autowired` or `@Inject`), and autowiring configured by the autowired attribute within bean configuration files.\n* The bean is explicitly loaded from a factory bean. It is not always possible to determine when this occurs, because factory beans are loaded using a `String` value, which may contain arbitrary values.\n* The bean is called reflectively by the Spring framework. For example, if the class is a Spring MVC framework controller, it may be called in response to web requests.\n* The bean has a static initializer.\n* The bean is not lazy, and has a constructor or instance initializer that modifies state outside of the bean.\nAny bean which is not used in one or more ways will be marked as \"dead\".\n\n\n## Recommendation\nFirst verify that the bean definition is never used at runtime. In some cases beans may be used in framework-specific ways, or may be loaded by name from a bean factory in a way that is impossible to determine statically.\n\nAfter confirming that the bean is not required, remove the bean. You will also need remove any references to this bean, which may, in turn, require removing other beans or references.\n\n\n## Example\nThe following example shows a configuration file that includes two beans:\n\n\n```xml\n<beans>\n    <!-- This bean is referred to, so is live. -->\n    <bean id=\"petStore\" class=\"org.sample.PetStoreService\"/>\n    <!-- This bean is never referred to, so is dead. -->\n    <bean id=\"clinic\" class=\"org.sample.ClinicService\"/>\n</beans>\n\n```\nThis XML file is loaded with the following Java class:\n\n\n```java\nclass Start {\n\tpublic static void main(String[] args) {\n\t\t// Create a context from the XML file, constructing beans\n\t\tApplicationContext context =\n\t\t    new ClassPathXmlApplicationContext(new String[] {\"services.xml\"});\n\n\t\t// Retrieve the petStore from the context bean factory.\n\t\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\t\t// Use the value\n\t\tList<String> userList = service.getUsernameList();\n\t}\n}\n```\nThis class constructs a Spring `ApplicationContext` using the XML file, then loads the \"petStore\" bean. Given these two files, the \"clinic\" bean will be marked as dead because it is not used in any context, unlike the \"petStore\" bean.\n\n\n## References\n* Spring Framework Reference Documentation 4.2: [6.3 Bean overview](http://docs.spring.io/spring/docs/4.2.3.RELEASE/spring-framework-reference/html/beans.html#beans-definition).\n",
                      "text": "# Beans that are never used within the code\nBean definitions that are specified but are never used are redundant and can be removed. Unused beans make the program harder to understand.\n\nA bean definition is considered to be used if one or more of the following is true:\n\n* The bean is referenced or defined in the `<constructor-arg>` or `<property>` element of a live bean.\n* The bean is injected in to a constructor or method of a live bean due to autowiring. This includes autowiring by annotation (`@Autowired` or `@Inject`), and autowiring configured by the autowired attribute within bean configuration files.\n* The bean is explicitly loaded from a factory bean. It is not always possible to determine when this occurs, because factory beans are loaded using a `String` value, which may contain arbitrary values.\n* The bean is called reflectively by the Spring framework. For example, if the class is a Spring MVC framework controller, it may be called in response to web requests.\n* The bean has a static initializer.\n* The bean is not lazy, and has a constructor or instance initializer that modifies state outside of the bean.\nAny bean which is not used in one or more ways will be marked as \"dead\".\n\n\n## Recommendation\nFirst verify that the bean definition is never used at runtime. In some cases beans may be used in framework-specific ways, or may be loaded by name from a bean factory in a way that is impossible to determine statically.\n\nAfter confirming that the bean is not required, remove the bean. You will also need remove any references to this bean, which may, in turn, require removing other beans or references.\n\n\n## Example\nThe following example shows a configuration file that includes two beans:\n\n\n```xml\n<beans>\n    <!-- This bean is referred to, so is live. -->\n    <bean id=\"petStore\" class=\"org.sample.PetStoreService\"/>\n    <!-- This bean is never referred to, so is dead. -->\n    <bean id=\"clinic\" class=\"org.sample.ClinicService\"/>\n</beans>\n\n```\nThis XML file is loaded with the following Java class:\n\n\n```java\nclass Start {\n\tpublic static void main(String[] args) {\n\t\t// Create a context from the XML file, constructing beans\n\t\tApplicationContext context =\n\t\t    new ClassPathXmlApplicationContext(new String[] {\"services.xml\"});\n\n\t\t// Retrieve the petStore from the context bean factory.\n\t\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\t\t// Use the value\n\t\tList<String> userList = service.getUsernameList();\n\t}\n}\n```\nThis class constructs a Spring `ApplicationContext` using the XML file, then loads the \"petStore\" bean. Given these two files, the \"clinic\" bean will be marked as dead because it is not used in any context, unlike the \"petStore\" bean.\n\n\n## References\n* Spring Framework Reference Documentation 4.2: [6.3 Bean overview](http://docs.spring.io/spring/docs/4.2.3.RELEASE/spring-framework-reference/html/beans.html#beans-definition).\n"
                    },
                    "id": "java/spring/unused-bean",
                    "name": "java/spring/unused-bean",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/UnusedBean.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Beans that are never used within the code"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A bean property that overrides the same property in a parent bean, and has the same contents, is useless."
                    },
                    "help": {
                      "markdown": "# Useless property override\nA property in a child bean that overrides a property with the same name in its parent and has the same contents is useless. This is because the bean inherits the property from its parent anyway.\n\n\n## Recommendation\nIf possible, remove the property in the child bean.\n\n\n## Example\nIn the following example, `registry` is defined in both the parent bean and the child bean. It should be removed from the child bean.\n\n\n```xml\n<beans>\n\t<bean id=\"baseShippingService\" abstract=\"true\">\n\t\t<property name=\"transactionHelper\">\n\t\t\t<ref bean=\"transactionHelper\"/>\n\t\t</property>\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseShippingService\">\n\t\t<!--AVOID: This property is already defined with the same value in the parent bean.-->\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n\t</bean>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n",
                      "text": "# Useless property override\nA property in a child bean that overrides a property with the same name in its parent and has the same contents is useless. This is because the bean inherits the property from its parent anyway.\n\n\n## Recommendation\nIf possible, remove the property in the child bean.\n\n\n## Example\nIn the following example, `registry` is defined in both the parent bean and the child bean. It should be removed from the child bean.\n\n\n```xml\n<beans>\n\t<bean id=\"baseShippingService\" abstract=\"true\">\n\t\t<property name=\"transactionHelper\">\n\t\t\t<ref bean=\"transactionHelper\"/>\n\t\t</property>\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseShippingService\">\n\t\t<!--AVOID: This property is already defined with the same value in the parent bean.-->\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n\t</bean>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
                    },
                    "id": "java/spring/useless-property-override",
                    "name": "java/spring/useless-property-override",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/UselessPropertyOverride.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless property override"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Array constants are mutable and can be changed by malicious code or by accident."
                    },
                    "help": {
                      "markdown": "# Array constant vulnerable to change\nConstant values are typically represented by public, static, final fields. When defining several related constants, it is sometimes tempting to define a public, static, final field with an array type, and initialize it with a list of all the different constant values.\n\nHowever, the `final` keyword applies only to the field itself (that is, the array reference), and not to the contents of the array. This means that the field always refers to the same array instance, but each element of the array may be modified freely. This possibly invalidates important assumptions of client code.\n\n\n## Recommendation\nWhere possible, avoid declaring array constants. If there are only a few constant values, consider using a named constant for each one, or defining them in an `enum` type.\n\nIf you genuinely need to refer to a long list of constants with the same name and an index, consider replacing the array constant with a constant of type `List` to which you assign an unmodifiable collection. See the example for ways of achieving this.\n\n\n## Example\nIn the following example, `public static final` applies only to `RGB` itself, not the constants that it contains.\n\n\n```java\npublic class Display {\n\t// AVOID: Array constant is vulnerable to mutation.\n\tpublic static final String[] RGB = {\n\t\t\"FF0000\", \"00FF00\", \"0000FF\"\n\t};\n\t\n\tvoid f() {\n\t\t// Re-assigning the \"constant\" is legal.\n\t\tRGB[0] = \"00FFFF\";\n\t}\n}\n```\nThe following example shows examples of ways to declare constants that avoid this problem.\n\n\n```java\n// Solution 1: Extract to individual constants\npublic class Display {\n    public static final String RED = \"FF0000\";\n    public static final String GREEN = \"00FF00\";\n    public static final String BLUE = \"0000FF\";\n}\n\n// Solution 2: Define constants using in an enum type\npublic enum Display\n{\n    RED (\"FF0000\"), GREEN (\"00FF00\"), BLUE (\"0000FF\");\n\n    private String rgb;\n    private Display(int rgb) {\n        this.rgb = rgb;\n    }\n    public String getRGB(){\n        return rgb;\n    }\n}\n\n// Solution 3: Use an unmodifiable collection\npublic class Display {\n    public static final List<String> RGB =\n            Collections.unmodifiableList(\n                    Arrays.asList(\"FF0000\",\n                            \"00FF00\",\n                            \"0000FF\"));\n}\n\n// Solution 4: Use a utility method\npublic class Utils {\n    public static <T> List<T> constList(T... values) {\n        return Collections.unmodifiableList(\n                Arrays.asList(values));\n    }\n}\n\npublic class Display {\n    public static final List<String> RGB =\n            Utils.constList(\"FF0000\", \"00FF00\", \"0000FF\");\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 70. Addison-Wesley, 2008.\n* Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4).\n* Common Weakness Enumeration: [CWE-582](https://cwe.mitre.org/data/definitions/582.html).\n",
                      "text": "# Array constant vulnerable to change\nConstant values are typically represented by public, static, final fields. When defining several related constants, it is sometimes tempting to define a public, static, final field with an array type, and initialize it with a list of all the different constant values.\n\nHowever, the `final` keyword applies only to the field itself (that is, the array reference), and not to the contents of the array. This means that the field always refers to the same array instance, but each element of the array may be modified freely. This possibly invalidates important assumptions of client code.\n\n\n## Recommendation\nWhere possible, avoid declaring array constants. If there are only a few constant values, consider using a named constant for each one, or defining them in an `enum` type.\n\nIf you genuinely need to refer to a long list of constants with the same name and an index, consider replacing the array constant with a constant of type `List` to which you assign an unmodifiable collection. See the example for ways of achieving this.\n\n\n## Example\nIn the following example, `public static final` applies only to `RGB` itself, not the constants that it contains.\n\n\n```java\npublic class Display {\n\t// AVOID: Array constant is vulnerable to mutation.\n\tpublic static final String[] RGB = {\n\t\t\"FF0000\", \"00FF00\", \"0000FF\"\n\t};\n\t\n\tvoid f() {\n\t\t// Re-assigning the \"constant\" is legal.\n\t\tRGB[0] = \"00FFFF\";\n\t}\n}\n```\nThe following example shows examples of ways to declare constants that avoid this problem.\n\n\n```java\n// Solution 1: Extract to individual constants\npublic class Display {\n    public static final String RED = \"FF0000\";\n    public static final String GREEN = \"00FF00\";\n    public static final String BLUE = \"0000FF\";\n}\n\n// Solution 2: Define constants using in an enum type\npublic enum Display\n{\n    RED (\"FF0000\"), GREEN (\"00FF00\"), BLUE (\"0000FF\");\n\n    private String rgb;\n    private Display(int rgb) {\n        this.rgb = rgb;\n    }\n    public String getRGB(){\n        return rgb;\n    }\n}\n\n// Solution 3: Use an unmodifiable collection\npublic class Display {\n    public static final List<String> RGB =\n            Collections.unmodifiableList(\n                    Arrays.asList(\"FF0000\",\n                            \"00FF00\",\n                            \"0000FF\"));\n}\n\n// Solution 4: Use a utility method\npublic class Utils {\n    public static <T> List<T> constList(T... values) {\n        return Collections.unmodifiableList(\n                Arrays.asList(values));\n    }\n}\n\npublic class Display {\n    public static final List<String> RGB =\n            Utils.constList(\"FF0000\", \"00FF00\", \"0000FF\");\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 70. Addison-Wesley, 2008.\n* Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4).\n* Common Weakness Enumeration: [CWE-582](https://cwe.mitre.org/data/definitions/582.html).\n"
                    },
                    "id": "java/static-array",
                    "name": "java/static-array",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/StaticArray.ql",
                      "tags": [
                        "external/cwe/cwe-582",
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Array constant vulnerable to change"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Writing to a static field from an instance method is prone to race conditions unless you use synchronization. In addition, it makes it difficult to keep the static state consistent and affects code readability."
                    },
                    "help": {
                      "markdown": "# Static field written by instance method\nA static field represents state shared between all instances of a particular class. Typically, static methods are provided to manipulate this static state, and it is bad practice to modify the static state of a class from an instance method (or from a constructor).\n\nThere are several reasons why this is bad practice. It can be very difficult to keep the static state consistent when there are multiple instances through which it could be modified. Such modifications represent a readability issue: most programmers would expect a static method to affect static state, and an instance method to affect instance state.\n\n\n## Recommendation\nIf the field should be an instance field, ensure that it does not have a `static` modifier.\n\nIf the field does have to be static, evaluate the assumptions in the code. Does the field really have to be modified directly in an instance method? It might be better to access the field from within static methods, so that any concerns about synchronization can be addressed without numerous synchronization statements in the code. Perhaps the field modification is part of the static initialization of the class, and should be moved to a static initializer or method.\n\n\n## Example\nIn the following example, a static field, `customers`, is written to by an instance method, `initialize`. It is entirely reasonable for another developer to assume that an instance method called `initialize` should be called on each new instance, and that is what the code in `Department` does. Unfortunately, the static field is shared between all instances of `Customer`, and so each time `initialize` is called, the old state is lost.\n\n\n```java\npublic class Customer {\n\tprivate static List<Customer> customers;\n\tpublic void initialize() {\n\t\t// AVOID: Static field is written to by instance method.\n\t\tcustomers = new ArrayList<Customer>();\n\t\tregister();\n\t}\n\tpublic static void add(Customer c) {\n\t\tcustomers.add(c);\n\t}\n}\n\n// ...\npublic class Department {\n\tpublic void addCustomer(String name) {\n\t\tCustomer c = new Customer(n);\n\t\t// The following call overwrites the list of customers\n\t\t// stored in 'Customer' (see above).\n\t\tc.initialize();\n\t\tCustomer.add(c);\n\t}\n}\n\n```\nThe solution is to extract the static initialization of `customers` to a static method, where it will happen exactly once.\n\n\n## References\n* Java Language Specification: [8.3.1.1 static Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1).\n",
                      "text": "# Static field written by instance method\nA static field represents state shared between all instances of a particular class. Typically, static methods are provided to manipulate this static state, and it is bad practice to modify the static state of a class from an instance method (or from a constructor).\n\nThere are several reasons why this is bad practice. It can be very difficult to keep the static state consistent when there are multiple instances through which it could be modified. Such modifications represent a readability issue: most programmers would expect a static method to affect static state, and an instance method to affect instance state.\n\n\n## Recommendation\nIf the field should be an instance field, ensure that it does not have a `static` modifier.\n\nIf the field does have to be static, evaluate the assumptions in the code. Does the field really have to be modified directly in an instance method? It might be better to access the field from within static methods, so that any concerns about synchronization can be addressed without numerous synchronization statements in the code. Perhaps the field modification is part of the static initialization of the class, and should be moved to a static initializer or method.\n\n\n## Example\nIn the following example, a static field, `customers`, is written to by an instance method, `initialize`. It is entirely reasonable for another developer to assume that an instance method called `initialize` should be called on each new instance, and that is what the code in `Department` does. Unfortunately, the static field is shared between all instances of `Customer`, and so each time `initialize` is called, the old state is lost.\n\n\n```java\npublic class Customer {\n\tprivate static List<Customer> customers;\n\tpublic void initialize() {\n\t\t// AVOID: Static field is written to by instance method.\n\t\tcustomers = new ArrayList<Customer>();\n\t\tregister();\n\t}\n\tpublic static void add(Customer c) {\n\t\tcustomers.add(c);\n\t}\n}\n\n// ...\npublic class Department {\n\tpublic void addCustomer(String name) {\n\t\tCustomer c = new Customer(n);\n\t\t// The following call overwrites the list of customers\n\t\t// stored in 'Customer' (see above).\n\t\tc.initialize();\n\t\tCustomer.add(c);\n\t}\n}\n\n```\nThe solution is to extract the static initialization of `customers` to a static method, where it will happen exactly once.\n\n\n## References\n* Java Language Specification: [8.3.1.1 static Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1).\n"
                    },
                    "id": "java/static-field-written-by-instance",
                    "name": "java/static-field-written-by-instance",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Statements/StaticFieldWrittenByInstance.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Static field written by instance method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended."
                    },
                    "help": {
                      "markdown": "# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n",
                      "text": "# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
                    },
                    "id": "java/string-buffer-char-init",
                    "name": "java/string-buffer-char-init",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/StringBufferCharInit.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Character passed to StringBuffer or StringBuilder constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Performing string concatenation in a loop that iterates many times may affect performance."
                    },
                    "help": {
                      "markdown": "# String concatenation in loop\nWhen string concatenation is performed using the \"+\" operator, the compiler translates this operation to a suitable manipulation, possibly constructing several intermediate strings. In general, because strings are immutable, at least one new string has to be constructed to hold the result.\n\nBuilding up a string one piece at a time in a loop requires a new string on every iteration, repeatedly copying longer and longer prefixes to fresh string objects. As a result, performance can be severely degraded.\n\n\n## Recommendation\nWhenever a string is constructed using a loop that iterates more than just a few times, it is usually better to create a `StringBuffer` or `StringBuilder` object and append to that. Because such buffers are based on mutable character arrays, which do not require a new string to be created for each concatenation, they can reduce the cost of repeatedly growing the string.\n\nTo choose between `StringBuffer` and `StringBuilder`, check if the new buffer object can possibly be accessed by several different threads while in use. If multi-thread safety is required, use a `StringBuffer`. For purely local string buffers, you can avoid the overhead of synchronization by using a `StringBuilder`.\n\n\n## Example\nThe following example shows a simple test that measures the time taken to construct a string. It constructs the same string of 65,536 binary digits, character-by-character, first by repeatedly appending to a string, and then by using a `StringBuilder`. The second method is three orders of magnitude faster.\n\n\n```java\npublic class ConcatenationInLoops {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random(123);\n\t\tlong start = System.currentTimeMillis();\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\ts += r.nextInt(2);\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints roughly 4500.\n\n\t\tr = new Random(123);\n\t\tstart = System.currentTimeMillis();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\tsb.append(r.nextInt(2));\n\t\ts = sb.toString();\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints 5.\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 51. Addison-Wesley, 2008.\n* Java API Specification: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n",
                      "text": "# String concatenation in loop\nWhen string concatenation is performed using the \"+\" operator, the compiler translates this operation to a suitable manipulation, possibly constructing several intermediate strings. In general, because strings are immutable, at least one new string has to be constructed to hold the result.\n\nBuilding up a string one piece at a time in a loop requires a new string on every iteration, repeatedly copying longer and longer prefixes to fresh string objects. As a result, performance can be severely degraded.\n\n\n## Recommendation\nWhenever a string is constructed using a loop that iterates more than just a few times, it is usually better to create a `StringBuffer` or `StringBuilder` object and append to that. Because such buffers are based on mutable character arrays, which do not require a new string to be created for each concatenation, they can reduce the cost of repeatedly growing the string.\n\nTo choose between `StringBuffer` and `StringBuilder`, check if the new buffer object can possibly be accessed by several different threads while in use. If multi-thread safety is required, use a `StringBuffer`. For purely local string buffers, you can avoid the overhead of synchronization by using a `StringBuilder`.\n\n\n## Example\nThe following example shows a simple test that measures the time taken to construct a string. It constructs the same string of 65,536 binary digits, character-by-character, first by repeatedly appending to a string, and then by using a `StringBuilder`. The second method is three orders of magnitude faster.\n\n\n```java\npublic class ConcatenationInLoops {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random(123);\n\t\tlong start = System.currentTimeMillis();\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\ts += r.nextInt(2);\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints roughly 4500.\n\n\t\tr = new Random(123);\n\t\tstart = System.currentTimeMillis();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\tsb.append(r.nextInt(2));\n\t\ts = sb.toString();\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints 5.\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 51. Addison-Wesley, 2008.\n* Java API Specification: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
                    },
                    "id": "java/string-concatenation-in-loop",
                    "name": "java/string-concatenation-in-loop",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/ConcatenationInLoops.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "String concatenation in loop"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling Swing methods from a thread other than the event-dispatching thread may result in multi-threading errors."
                    },
                    "help": {
                      "markdown": "# Thread safety\nBecause Swing components are not thread-safe (that is, they do not support concurrent access from multiple threads), Swing has a rule that states that method calls on Swing components that have been *realized* (see below) must be made from a special thread known as the *event-dispatching thread*. Failure to observe this rule may result in multiple threads accessing a Swing component concurrently, with the potential for deadlocks, race conditions and other errors related to multi-threading.\n\nA component is considered *realized* if its `paint` method has been, or could be, called at this point. Realization is triggered according to the following rules:\n\n* A top-level window is realized if `setVisible(true)`, `show` or `pack` is called on it.\n* Realizing a container realizes the components it contains.\nThere are a few exceptions to the rule. These are documented more fully in \\[The Swing Connection\\] but the key exceptions are:\n\n* It is safe to call the `repaint`, `revalidate` and `invalidate` methods on a Swing component from any thread.\n* It is safe to add and remove listeners from any thread. Therefore, any method of the form `add*Listener` or `remove*Listener` is thread-safe.\n\n## Recommendation\nEnsure that method calls on Swing components are made from the event-dispatching thread. If you need to call a method on a Swing component from another thread, you must do so using the event-dispatching thread. Swing provides a `SwingUtilities` class that you can use to ask the event-dispatching thread to run arbitrary code on your components, by calling one of two methods. Each method takes a `Runnable` as its only argument:\n\n* `SwingUtilities.invokeLater` asks the event-dispatching thread to run some code and then immediately returns (that is, it is non-blocking). The code is run at some indeterminate time in the future, but the thread that calls `invokeLater` does not wait for it.\n* `SwingUtilities.invokeAndWait` asks the event-dispatching thread to run some code and then waits for it to complete (that is, it is blocking).\n\n## Example\nIn the following example, there is a call from the main thread to a method, `setTitle`, on the `MyFrame` object after the object has been realized by the `setVisible(true)` call. This represents an unsafe call to a Swing method from a thread other than the event-dispatching thread.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class BrokenSwing {\n    private static void doStuff(MyFrame frame) {\n        // BAD: Direct call to a Swing component after it has been realized\n        frame.setTitle(\"Title\");\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n```\nIn the following modified example, the call to `setTitle` is instead called from within a call to `invokeLater`.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class GoodSwing {\n    private static void doStuff(final MyFrame frame) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                // GOOD: Call to Swing component made via the\n                // event-dispatching thread using 'invokeLater'\n                frame.setTitle(\"Title\");\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, p.28. O'Reilly, 1999.\n* Java Developer's Journal: [Building Thread-Safe GUIs with Swing](http://www.comscigate.com/JDJ/archives/0605/ford/index.html).\n* The Java Tutorials: [Concurrency in Swing](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html).\n* The Swing Connection: [Threads and Swing](https://www.comp.nus.edu.sg/~cs3283/ftp/Java/swingConnect/archive/tech_topics_arch/threads/threads.html).\n",
                      "text": "# Thread safety\nBecause Swing components are not thread-safe (that is, they do not support concurrent access from multiple threads), Swing has a rule that states that method calls on Swing components that have been *realized* (see below) must be made from a special thread known as the *event-dispatching thread*. Failure to observe this rule may result in multiple threads accessing a Swing component concurrently, with the potential for deadlocks, race conditions and other errors related to multi-threading.\n\nA component is considered *realized* if its `paint` method has been, or could be, called at this point. Realization is triggered according to the following rules:\n\n* A top-level window is realized if `setVisible(true)`, `show` or `pack` is called on it.\n* Realizing a container realizes the components it contains.\nThere are a few exceptions to the rule. These are documented more fully in \\[The Swing Connection\\] but the key exceptions are:\n\n* It is safe to call the `repaint`, `revalidate` and `invalidate` methods on a Swing component from any thread.\n* It is safe to add and remove listeners from any thread. Therefore, any method of the form `add*Listener` or `remove*Listener` is thread-safe.\n\n## Recommendation\nEnsure that method calls on Swing components are made from the event-dispatching thread. If you need to call a method on a Swing component from another thread, you must do so using the event-dispatching thread. Swing provides a `SwingUtilities` class that you can use to ask the event-dispatching thread to run arbitrary code on your components, by calling one of two methods. Each method takes a `Runnable` as its only argument:\n\n* `SwingUtilities.invokeLater` asks the event-dispatching thread to run some code and then immediately returns (that is, it is non-blocking). The code is run at some indeterminate time in the future, but the thread that calls `invokeLater` does not wait for it.\n* `SwingUtilities.invokeAndWait` asks the event-dispatching thread to run some code and then waits for it to complete (that is, it is blocking).\n\n## Example\nIn the following example, there is a call from the main thread to a method, `setTitle`, on the `MyFrame` object after the object has been realized by the `setVisible(true)` call. This represents an unsafe call to a Swing method from a thread other than the event-dispatching thread.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class BrokenSwing {\n    private static void doStuff(MyFrame frame) {\n        // BAD: Direct call to a Swing component after it has been realized\n        frame.setTitle(\"Title\");\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n```\nIn the following modified example, the call to `setTitle` is instead called from within a call to `invokeLater`.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class GoodSwing {\n    private static void doStuff(final MyFrame frame) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                // GOOD: Call to Swing component made via the\n                // event-dispatching thread using 'invokeLater'\n                frame.setTitle(\"Title\");\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, p.28. O'Reilly, 1999.\n* Java Developer's Journal: [Building Thread-Safe GUIs with Swing](http://www.comscigate.com/JDJ/archives/0605/ford/index.html).\n* The Java Tutorials: [Concurrency in Swing](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html).\n* The Swing Connection: [Threads and Swing](https://www.comp.nus.edu.sg/~cs3283/ftp/Java/swingConnect/archive/tech_topics_arch/threads/threads.html).\n"
                    },
                    "id": "java/swing-thread-safety",
                    "name": "java/swing-thread-safety",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/Swing/ThreadSafety.ql",
                      "tags": [
                        "frameworks/swing",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Thread safety"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A test case class whose test methods are not recognized by JUnit 3.8 as valid declarations is not used."
                    },
                    "help": {
                      "markdown": "# Test case has no tests\nA JUnit 3.8 test case class (that is, a non-abstract class that is a subtype of `junit.framework.TestCase`) should contain test methods, and each method must have the correct signature to be used by JUnit. Otherwise, the JUnit test runner will fail with an error message.\n\n\n## Recommendation\nEnsure that the test case class contains some test methods, and that each method is of the form:\n\n```\n\npublic void testXXX() {\n  // ...\n}\n\n```\nNote that the method name must start with `test` and the method must not take any parameters.\n\nIf the test case class is intended strictly for subclassing by other test case classes, consider making it abstract to document this intention. It will then no longer be flagged by this query.\n\nThis rule applies only to JUnit 3.8-style test case classes. In JUnit 4, it is no longer required to extend `junit.framework.TestCase` to mark test methods.\n\n\n## Example\nIn the following example, `TestCaseNoTests38` does not contain any valid JUnit test methods. However, `MyTests` contains two valid JUnit test methods.\n\n\n```java\n// BAD: This test case class does not have any valid JUnit 3.8 test methods.\npublic class TestCaseNoTests38 extends TestCase {\n\t// This is not a test case because it does not start with 'test'.\n\tpublic void simpleTest() {\n\t\t//...\n\t}\n\n\t// This is not a test case because it takes two parameters.\n\tpublic void testNotEquals(int i, int j) {\n\t\tassertEquals(i != j, true);\n\t}\n\n\t// This is recognized as a test, but causes JUnit to fail\n\t// when run because it is not public.\n\tvoid testEquals() {\n\t\t//...\n\t}\n}\n\n// GOOD: This test case class correctly declares test methods.\npublic class MyTests extends TestCase {\n\tpublic void testEquals() {\n\t\tassertEquals(1, 1);\n\t}\n\tpublic void testNotEquals() {\n\t\tassertFalse(1 == 2);\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# Test case has no tests\nA JUnit 3.8 test case class (that is, a non-abstract class that is a subtype of `junit.framework.TestCase`) should contain test methods, and each method must have the correct signature to be used by JUnit. Otherwise, the JUnit test runner will fail with an error message.\n\n\n## Recommendation\nEnsure that the test case class contains some test methods, and that each method is of the form:\n\n```\n\npublic void testXXX() {\n  // ...\n}\n\n```\nNote that the method name must start with `test` and the method must not take any parameters.\n\nIf the test case class is intended strictly for subclassing by other test case classes, consider making it abstract to document this intention. It will then no longer be flagged by this query.\n\nThis rule applies only to JUnit 3.8-style test case classes. In JUnit 4, it is no longer required to extend `junit.framework.TestCase` to mark test methods.\n\n\n## Example\nIn the following example, `TestCaseNoTests38` does not contain any valid JUnit test methods. However, `MyTests` contains two valid JUnit test methods.\n\n\n```java\n// BAD: This test case class does not have any valid JUnit 3.8 test methods.\npublic class TestCaseNoTests38 extends TestCase {\n\t// This is not a test case because it does not start with 'test'.\n\tpublic void simpleTest() {\n\t\t//...\n\t}\n\n\t// This is not a test case because it takes two parameters.\n\tpublic void testNotEquals(int i, int j) {\n\t\tassertEquals(i != j, true);\n\t}\n\n\t// This is recognized as a test, but causes JUnit to fail\n\t// when run because it is not public.\n\tvoid testEquals() {\n\t\t//...\n\t}\n}\n\n// GOOD: This test case class correctly declares test methods.\npublic class MyTests extends TestCase {\n\tpublic void testEquals() {\n\t\tassertEquals(1, 1);\n\t}\n\tpublic void testNotEquals() {\n\t\tassertFalse(1 == 2);\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/test-case-without-tests",
                    "name": "java/test-case-without-tests",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/TestCaseNoTests.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Test case has no tests"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A comment that contains 'TODO' or 'FIXME' may indicate code that is incomplete or broken, or it may highlight an ambiguity in the software's specification."
                    },
                    "help": {
                      "markdown": "# TODO/FIXME comments\nA comment that includes the word `TODO` or `FIXME` often marks a part of the code that is incomplete or broken, or highlights ambiguities in the software's specification.\n\nFor example, this list of comments is typical of those found in real programs:\n\n* `TODO: move this code somewhere else`\n* `FIXME: handle this case`\n* `FIXME: find a better solution to this workaround`\n* `TODO: test this`\n\n## Recommendation\nIt is very important that `TODO` or `FIXME` comments are not just removed from the code. Each of them must be addressed in some way.\n\nSimpler comments can usually be immediately addressed by fixing the code, adding a test, doing some refactoring, or clarifying the intended behavior of a feature.\n\nIn contrast, larger issues may require discussion, and a significant amount of work to address. In these cases it is a good idea to move the comment to an issue-tracking system, so that the issue can be tracked and prioritized relative to other defects and feature requests.\n\n\n## References\n* Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).\n* Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags), [Issue tracking system](http://en.wikipedia.org/wiki/Issue_tracking_system).\n* Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).\n",
                      "text": "# TODO/FIXME comments\nA comment that includes the word `TODO` or `FIXME` often marks a part of the code that is incomplete or broken, or highlights ambiguities in the software's specification.\n\nFor example, this list of comments is typical of those found in real programs:\n\n* `TODO: move this code somewhere else`\n* `FIXME: handle this case`\n* `FIXME: find a better solution to this workaround`\n* `TODO: test this`\n\n## Recommendation\nIt is very important that `TODO` or `FIXME` comments are not just removed from the code. Each of them must be addressed in some way.\n\nSimpler comments can usually be immediately addressed by fixing the code, adding a test, doing some refactoring, or clarifying the intended behavior of a feature.\n\nIn contrast, larger issues may require discussion, and a significant amount of work to address. In these cases it is a good idea to move the comment to an issue-tracking system, so that the issue can be tracked and prioritized relative to other defects and feature requests.\n\n\n## References\n* Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).\n* Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags), [Issue tracking system](http://en.wikipedia.org/wiki/Issue_tracking_system).\n* Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).\n"
                    },
                    "id": "java/todo-comment",
                    "name": "java/todo-comment",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Comments/TodoComments.ql",
                      "tags": [
                        "external/cwe/cwe-546",
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "TODO/FIXME comments"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'tostring' may be intended to be named 'toString'."
                    },
                    "help": {
                      "markdown": "# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/tostring-typo",
                    "name": "java/tostring-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/ToStringTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in toString"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using the 'transient' field modifier in non-serializable classes has no effect."
                    },
                    "help": {
                      "markdown": "# Transient field in non-serializable class\nThe `transient` modifier is used to identify fields that are not part of the persistent state of the class. As such, it only has an effect if the class is serializable, and has no purpose in a non-serializable class.\n\nA field that is marked `transient` in a non-serializable class is likely to be a leftover from a time when the class was serializable.\n\n\n## Recommendation\nIf the class is non-serializable, leave out the `transient` modifier. Otherwise, use the modifier, and ensure that the class (or a relevant supertype) implements `Serializable`.\n\n\n## Example\nThe following example shows two fields that are declared `transient`. The modifier only has an effect in the class that implements `Serializable`.\n\n\n```java\nclass State {\n\t// The 'transient' modifier has no effect here because\n\t// the 'State' class does not implement 'Serializable'.\n\tprivate transient int[] stateData;\n}\n\nclass PersistentState implements Serializable {\n\tprivate int[] stateData;\n\t// The 'transient' modifier indicates that this field is not part of\n\t// the persistent state and should therefore not be serialized.\n\tprivate transient int[] cachedComputedData;\n}\n```\n\n## References\n* Java Language Specification: [8.3.1.3 transient Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.3).\n* Java Object Serialization Specification: [1.5 Defining Serializable Fields for a Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#defining-serializable-fields-for-a-class).\n",
                      "text": "# Transient field in non-serializable class\nThe `transient` modifier is used to identify fields that are not part of the persistent state of the class. As such, it only has an effect if the class is serializable, and has no purpose in a non-serializable class.\n\nA field that is marked `transient` in a non-serializable class is likely to be a leftover from a time when the class was serializable.\n\n\n## Recommendation\nIf the class is non-serializable, leave out the `transient` modifier. Otherwise, use the modifier, and ensure that the class (or a relevant supertype) implements `Serializable`.\n\n\n## Example\nThe following example shows two fields that are declared `transient`. The modifier only has an effect in the class that implements `Serializable`.\n\n\n```java\nclass State {\n\t// The 'transient' modifier has no effect here because\n\t// the 'State' class does not implement 'Serializable'.\n\tprivate transient int[] stateData;\n}\n\nclass PersistentState implements Serializable {\n\tprivate int[] stateData;\n\t// The 'transient' modifier indicates that this field is not part of\n\t// the persistent state and should therefore not be serialized.\n\tprivate transient int[] cachedComputedData;\n}\n```\n\n## References\n* Java Language Specification: [8.3.1.3 transient Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.3).\n* Java Object Serialization Specification: [1.5 Defining Serializable Fields for a Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#defining-serializable-fields-for-a-class).\n"
                    },
                    "id": "java/transient-not-serializable",
                    "name": "java/transient-not-serializable",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/TransientNotSerializable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Transient field in non-serializable class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "If 'C' is a final class, a type bound such as '? extends C' is confusing because it implies that 'C' has subclasses, but a final class has no subclasses."
                    },
                    "help": {
                      "markdown": "# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n",
                      "text": "# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n"
                    },
                    "id": "java/type-bound-extends-final",
                    "name": "java/type-bound-extends-final",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/TypeVarExtendsFinalType.ql",
                      "tags": [
                        "maintainability",
                        "readability",
                        "types"
                      ]
                    },
                    "shortDescription": {
                      "text": "Type bound extends a final class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Testing whether 'this' is an instance of a derived type introduces a dependency cycle between the type of 'this' and the target type."
                    },
                    "help": {
                      "markdown": "# Dubious type test of 'this'\nTesting whether `this` is an instance of a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, the need for every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by testing the type of `this`.\n\n\n```java\npublic class DubiousTypeTestOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\t// violation\n\t\t\t\tthis.d = (Derived)this;\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n",
                      "text": "# Dubious type test of 'this'\nTesting whether `this` is an instance of a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, the need for every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by testing the type of `this`.\n\n\n```java\npublic class DubiousTypeTestOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\t// violation\n\t\t\t\tthis.d = (Derived)this;\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n"
                    },
                    "id": "java/type-test-of-this",
                    "name": "java/type-test-of-this",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/DubiousTypeTestOfThis.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dubious type test of 'this'"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A field that is never assigned a value (except possibly 'null') just returns the default value when it is read."
                    },
                    "help": {
                      "markdown": "# Field is never assigned a non-null value\nIt is good practice to initialize every field in a constructor explicitly. A field that is never assigned any value (except possibly `null`) just returns the default value when it is read, or throws a `NullPointerException`.\n\n\n## Recommendation\nA field whose value is always `null` (or the corresponding default value for primitive types, for example `0`) is not particularly useful. Ensure that the code contains an assignment or initialization for each field. To help satisfy this rule, it is good practice to explicitly initialize every field in the constructor, even if the default value is acceptable.\n\nIf the field is genuinely never expected to hold a non-default value, check the statements that read the field and ensure that they are not making incorrect assumptions about the value of the field. Consider completely removing the field and rewriting the statements that read it, as appropriate.\n\n\n## Example\nIn the following example, the private field `name` is not initialized in the constructor (and thus is implicitly set to `null`), but there is a getter method to access it.\n\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n```\nTherefore, the following code throws a `NullPointerException`:\n\n```java\nPerson p = new Person(\"Arthur Dent\", 30);\nint l = p.getName().length();\n```\nTo fix the code, `name` should be initialized in the constructor by adding the following line: `this.name = name;`\n\n",
                      "text": "# Field is never assigned a non-null value\nIt is good practice to initialize every field in a constructor explicitly. A field that is never assigned any value (except possibly `null`) just returns the default value when it is read, or throws a `NullPointerException`.\n\n\n## Recommendation\nA field whose value is always `null` (or the corresponding default value for primitive types, for example `0`) is not particularly useful. Ensure that the code contains an assignment or initialization for each field. To help satisfy this rule, it is good practice to explicitly initialize every field in the constructor, even if the default value is acceptable.\n\nIf the field is genuinely never expected to hold a non-default value, check the statements that read the field and ensure that they are not making incorrect assumptions about the value of the field. Consider completely removing the field and rewriting the statements that read it, as appropriate.\n\n\n## Example\nIn the following example, the private field `name` is not initialized in the constructor (and thus is implicitly set to `null`), but there is a getter method to access it.\n\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n```\nTherefore, the following code throws a `NullPointerException`:\n\n```java\nPerson p = new Person(\"Arthur Dent\", 30);\nint l = p.getName().length();\n```\nTo fix the code, `name` should be initialized in the constructor by adding the following line: `this.name = name;`\n\n"
                    },
                    "id": "java/unassigned-field",
                    "name": "java/unassigned-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/NonAssignedFields.ql",
                      "tags": [
                        "external/cwe/cwe-457",
                        "maintainability",
                        "reliability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Field is never assigned a non-null value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Use of a single underscore character as an identifier results in a compiler error with Java source level 9 or later."
                    },
                    "help": {
                      "markdown": "# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n",
                      "text": "# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n"
                    },
                    "id": "java/underscore-identifier",
                    "name": "java/underscore-identifier",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Compatibility/JDK9/UnderscoreIdentifier.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Underscore used as identifier"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that throws an exception but does not have a Javadoc tag for the exception affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for thrown exception\nA public method or constructor that throws an exception but does not have a Javadoc tag for the exception makes an API more difficult to understand and maintain. This includes checked exceptions in `throws` clauses and unchecked exceptions that are explicitly thrown in `throw` statements.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each thrown exception.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 44 and 62. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for thrown exception\nA public method or constructor that throws an exception but does not have a Javadoc tag for the exception makes an API more difficult to understand and maintain. This includes checked exceptions in `throws` clauses and unchecked exceptions that are explicitly thrown in `throw` statements.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each thrown exception.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 44 and 62. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-exception",
                    "name": "java/undocumented-exception",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocThrows.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for thrown exception"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that does not have a Javadoc comment affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for public method or constructor\nA public method or constructor that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic methods and constructors should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public methods and constructors.\n\nThe Javadoc comment should describe *what* the method or constructor does rather than *how*, to allow for any potential implementation change that is invisible to users of an API. It should include the following:\n\n* A description of any preconditions or postconditions\n* Javadoc tag elements that describe any parameters, return value, and thrown exceptions\n* Any other important aspects such as side-effects and thread safety\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the method does, its parameter, return value, and thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for public method or constructor\nA public method or constructor that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic methods and constructors should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public methods and constructors.\n\nThe Javadoc comment should describe *what* the method or constructor does rather than *how*, to allow for any potential implementation change that is invisible to users of an API. It should include the following:\n\n* A description of any preconditions or postconditions\n* Javadoc tag elements that describe any parameters, return value, and thrown exceptions\n* Any other important aspects such as side-effects and thread safety\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the method does, its parameter, return value, and thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-function",
                    "name": "java/undocumented-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocMethods.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for public method or constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that does not have a Javadoc tag for each parameter affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for parameter\nA public method or constructor that does not have a Javadoc tag for each parameter makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each parameter.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's parameter.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for parameter\nA public method or constructor that does not have a Javadoc tag for each parameter makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each parameter.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's parameter.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-parameter",
                    "name": "java/undocumented-parameter",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocParameters.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method that does not have a Javadoc tag for its return value affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for method return value\nA public method that does not have a Javadoc tag for its return value makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method should include a Javadoc tag element that describes the return value.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's return value.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for method return value\nA public method that does not have a Javadoc tag for its return value makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method should include a Javadoc tag element that describes the return value.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's return value.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-return-value",
                    "name": "java/undocumented-return-value",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocReturnValues.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for method return value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public class or interface that does not have a Javadoc comment affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for public type\nA public class or interface that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic classes and interfaces should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public classes and interfaces.\n\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the class does, its author, and version.\n\n\n```java\n/**\n * The Stack class represents a last-in-first-out stack of objects. \n *\n * @author  Joseph Bergin\n * @version 1.0, May 2000\n * Note that this version is not thread safe. \n */\npublic class Stack {\n// ...\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for public type\nA public class or interface that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic classes and interfaces should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public classes and interfaces.\n\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the class does, its author, and version.\n\n\n```java\n/**\n * The Stack class represents a last-in-first-out stack of objects. \n *\n * @author  Joseph Bergin\n * @version 1.0, May 2000\n * Note that this version is not thread safe. \n */\npublic class Stack {\n// ...\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-type",
                    "name": "java/undocumented-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocTypes.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for public type"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An interface method that is incompatible with a protected method on 'java.lang.Object' means that the interface cannot be implemented."
                    },
                    "help": {
                      "markdown": "# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n",
                      "text": "# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n"
                    },
                    "id": "java/unimplementable-interface",
                    "name": "java/unimplementable-interface",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/InterfaceCannotBeImplemented.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Interface cannot be implemented"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Javadoc @param tags that do not match any parameters in the method or constructor or any type parameters of the annotated class are confusing."
                    },
                    "help": {
                      "markdown": "# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n",
                      "text": "# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n"
                    },
                    "id": "java/unknown-javadoc-parameter",
                    "name": "java/unknown-javadoc-parameter",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/SpuriousJavadocParam.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Spurious Javadoc @param tags"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'this.getClass().getResource()' may yield unexpected results if called from a subclass in another package."
                    },
                    "help": {
                      "markdown": "# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n",
                      "text": "# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n"
                    },
                    "id": "java/unsafe-get-resource",
                    "name": "java/unsafe-get-resource",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/GetClassGetResource.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unsafe use of getResource"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A collection or map whose contents are never queried or accessed is useless."
                    },
                    "help": {
                      "markdown": "# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-container",
                    "name": "java/unused-container",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Collections/WriteOnlyContainer.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Container contents are never accessed"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A field that is never used is probably unnecessary."
                    },
                    "help": {
                      "markdown": "# Unused field\nA field that is neither public nor protected and never accessed is typically a leftover from old refactorings or a sign of incomplete or pending code changes.\n\nThis rule does not apply to a field in a serializable class because it may be accessed during serialization and deserialization.\n\nFields annotated with `@SuppressWarnings(\"unused\")` are also not reported.\n\n\n## Recommendation\nIf an unused field is a leftover from old refactorings, you should just remove it. If it indicates incomplete or pending code changes, finish making the changes and remove the field if it is not needed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused field\nA field that is neither public nor protected and never accessed is typically a leftover from old refactorings or a sign of incomplete or pending code changes.\n\nThis rule does not apply to a field in a serializable class because it may be accessed during serialization and deserialization.\n\nFields annotated with `@SuppressWarnings(\"unused\")` are also not reported.\n\n\n## Recommendation\nIf an unused field is a leftover from old refactorings, you should just remove it. If it indicates incomplete or pending code changes, finish making the changes and remove the field if it is not needed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-field",
                    "name": "java/unused-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnusedField.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A format call with a format string that refers to fewer arguments than the number of supplied arguments will silently ignore the additional arguments."
                    },
                    "help": {
                      "markdown": "# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n",
                      "text": "# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"
                    },
                    "id": "java/unused-format-argument",
                    "name": "java/unused-format-argument",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/UnusedFormatArg.ql",
                      "tags": [
                        "external/cwe/cwe-685",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused format argument"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A redundant 'import' statement introduces unnecessary and undesirable dependencies."
                    },
                    "help": {
                      "markdown": "# Unnecessary import\nAn `import` statement that is not necessary (because no part of the file that it is in uses any imported type) should be avoided. Although importing too many types does not affect performance, redundant `import` statements introduce unnecessary and undesirable dependencies in the code. If an imported type is renamed or deleted, the source code cannot be compiled because the `import` statement cannot be resolved.\n\nUnnecessary `import` statements are often an indication of incomplete refactoring.\n\n\n## Recommendation\nAvoid including an `import` statement that is not needed. Many modern IDEs have automated support for doing this, typically under the name 'Organize imports'. This sorts the `import` statements and removes any that are not used, and it is good practice to run such a command before every commit.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unnecessary import\nAn `import` statement that is not necessary (because no part of the file that it is in uses any imported type) should be avoided. Although importing too many types does not affect performance, redundant `import` statements introduce unnecessary and undesirable dependencies in the code. If an imported type is renamed or deleted, the source code cannot be compiled because the `import` statement cannot be resolved.\n\nUnnecessary `import` statements are often an indication of incomplete refactoring.\n\n\n## Recommendation\nAvoid including an `import` statement that is not needed. Many modern IDEs have automated support for doing this, typically under the name 'Organize imports'. This sorts the `import` statements and removes any that are not used, and it is good practice to run such a command before every commit.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-import",
                    "name": "java/unused-import",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/UnnecessaryImport.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unnecessary import"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An unused label for a loop or 'switch' statement is either redundant or indicates incorrect 'break' or 'continue' statements."
                    },
                    "help": {
                      "markdown": "# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-label",
                    "name": "java/unused-label",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnusedLabel.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused label"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Parameters that are not used add unnecessary complexity to an interface."
                    },
                    "help": {
                      "markdown": "# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-parameter",
                    "name": "java/unused-parameter",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/UselessParameter.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-public class or interface that is not used anywhere in the program wastes programmer resources."
                    },
                    "help": {
                      "markdown": "# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-reference-type",
                    "name": "java/unused-reference-type",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/DeadRefTypes.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused classes and interfaces"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic number, which is used instead of an existing named constant, makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic numbers: use defined constant\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nReplace the magic number with the existing named constant. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `internalPort`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint internalPort = 8080;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, internalPort, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'PORT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic numbers: use defined constant\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nReplace the magic number with the existing named constant. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `internalPort`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint internalPort = 8080;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, internalPort, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'PORT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/use-number-constant",
                    "name": "java/use-number-constant",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicNumbersUseConstant.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic numbers: use defined constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic string, which is used instead of an existing named constant, makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic strings: use defined constant\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nReplace the magic string with the existing named constant. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `internalIp`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString internalIp = \"127.0.0.1\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(internalIp, PORT, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  //Use 'IP' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic strings: use defined constant\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nReplace the magic string with the existing named constant. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `internalIp`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString internalIp = \"127.0.0.1\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(internalIp, PORT, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  //Use 'IP' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/use-string-constant",
                    "name": "java/use-string-constant",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicStringsUseConstant.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic strings: use defined constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method forwards calls to another method of the same name that is not called independently."
                    },
                    "help": {
                      "markdown": "# Pointless forwarding method\nIf a class contains two distinct methods of the same name such that:\n\n1. One method is only ever called from the other method.\n1. The calling method calls only the other method and nothing else.\nThen the first method is no more than a forwarding method for the second and the two methods can probably be merged.\n\nThere are several advantages to doing this:\n\n* It reduces the cognitive overhead involved in keeping track of the various different overloaded forms of a method.\n* If both methods are public, it simplifies the API of their containing class, making it more discoverable to other programmers.\n* It makes it clearer to other programmers that certain methods are called and other methods are not.\n\n## Example\nIn this example, the two `print` methods in `Bad` can be merged, as one is simply a forwarder for the other. The two classes `Better1` and `Better2` show two alternative ways of merging the methods.\n\n\n```java\nimport static java.lang.System.out;\n\npublic class PointlessForwardingMethod {\n\tprivate static class Bad {\n\t\t// Violation: This print does nothing but forward to the other one, which is not\n\t\t// called independently.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tprint(firstName + \" \" + lastName);\n\t\t}\n\n\t\tpublic void print(String fullName) {\n\t\t\tout.println(\"Pointless forwarding methods are bad, \"  + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better1 {\n\t\t// Better: Merge the methods, using local variables to replace the parameters in\n\t\t// the original version.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tString fullName = firstName + \" \" + lastName;\n\t\t\tout.println(\"Pointless forwarding methods are bad, \" + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better2 {\n\t\t// Better: If there's no complicated logic, you can often remove the extra\n\t\t// variables entirely.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tout.println(\n\t\t\t\t\"Pointless forwarding methods are bad, \" +\n\t\t\t\tfirstName + \" \" + lastName + \"...\"\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Bad().print(\"Foo\", \"Bar\");\n\t\tnew Better1().print(\"Foo\", \"Bar\");\n\t\tnew Better2().print(\"Foo\", \"Bar\");\n\t}\n}\n```\n",
                      "text": "# Pointless forwarding method\nIf a class contains two distinct methods of the same name such that:\n\n1. One method is only ever called from the other method.\n1. The calling method calls only the other method and nothing else.\nThen the first method is no more than a forwarding method for the second and the two methods can probably be merged.\n\nThere are several advantages to doing this:\n\n* It reduces the cognitive overhead involved in keeping track of the various different overloaded forms of a method.\n* If both methods are public, it simplifies the API of their containing class, making it more discoverable to other programmers.\n* It makes it clearer to other programmers that certain methods are called and other methods are not.\n\n## Example\nIn this example, the two `print` methods in `Bad` can be merged, as one is simply a forwarder for the other. The two classes `Better1` and `Better2` show two alternative ways of merging the methods.\n\n\n```java\nimport static java.lang.System.out;\n\npublic class PointlessForwardingMethod {\n\tprivate static class Bad {\n\t\t// Violation: This print does nothing but forward to the other one, which is not\n\t\t// called independently.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tprint(firstName + \" \" + lastName);\n\t\t}\n\n\t\tpublic void print(String fullName) {\n\t\t\tout.println(\"Pointless forwarding methods are bad, \"  + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better1 {\n\t\t// Better: Merge the methods, using local variables to replace the parameters in\n\t\t// the original version.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tString fullName = firstName + \" \" + lastName;\n\t\t\tout.println(\"Pointless forwarding methods are bad, \" + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better2 {\n\t\t// Better: If there's no complicated logic, you can often remove the extra\n\t\t// variables entirely.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tout.println(\n\t\t\t\t\"Pointless forwarding methods are bad, \" +\n\t\t\t\tfirstName + \" \" + lastName + \"...\"\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Bad().print(\"Foo\", \"Bar\");\n\t\tnew Better1().print(\"Foo\", \"Bar\");\n\t\tnew Better2().print(\"Foo\", \"Bar\");\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-forwarding-method",
                    "name": "java/useless-forwarding-method",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/PointlessForwardingMethod.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Pointless forwarding method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Checking whether an expression is null when that expression cannot possibly be null is useless."
                    },
                    "help": {
                      "markdown": "# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/useless-null-check",
                    "name": "java/useless-null-check",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessNullCheck.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless null check"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling 'toString' on a string is redundant."
                    },
                    "help": {
                      "markdown": "# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n",
                      "text": "# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n"
                    },
                    "id": "java/useless-tostring-call",
                    "name": "java/useless-tostring-call",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToStringToString.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless toString on String"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Testing whether a derived type is an instance of its base type is unnecessary."
                    },
                    "help": {
                      "markdown": "# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n",
                      "text": "# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-type-test",
                    "name": "java/useless-type-test",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessTypeTest.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless type test"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Upcasting a derived type to its base type is usually unnecessary."
                    },
                    "help": {
                      "markdown": "# Useless upcast\nIn most situations, casting an instance of a derived type to a base type serves no purpose, since the conversion can be done implicitly. In such cases, the redundant cast can simply be removed. However, an upcast is not redundant in the following situations:\n\n* It is being used to force a call to an overloaded callable that takes a parameter of the base type rather than one of the derived type.\n* It is being used to specify the type to use for the operands of a ternary expression.\nBoth of these special cases are illustrated in the example below. This rule ignores these special cases and highlights upcasts which appear to be redundant.\n\n\n## Recommendation\nRemove the unnecessary upcast to simplify the code.\n\n\n## Example\nThe following code includes an example of a redundant upcast that would be highlighted by this rule. In addition, three examples of upcasts that are required and are ignored by this rule.\n\n\n```java\npublic class UselessUpcast {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tprivate static void Foo(B b) { System.out.println(\"Foo(B)\"); }\n\tprivate static void Foo(D d) { System.out.println(\"Foo(D)\"); }\n\n\tprivate static class Expr {}\n\tprivate static class AddExpr extends Expr {}\n\tprivate static class SubExpr extends Expr {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tB b_ = (B)d;\t// violation: redundant cast, consider removing\n\n\t\tB b = new D();\n\t\tD d_ = (D)b;\t// non-violation: required downcast\n\n\t\tFoo(d);\n\t\tFoo((B)d);\t\t// non-violation: required to call Foo(B)\n\n\t\t// Non-violation: required to specify the type of the ternary operands.\n\t\tExpr e = d != null ? (Expr)new AddExpr() : new SubExpr();\n\t}\n}\n```\n",
                      "text": "# Useless upcast\nIn most situations, casting an instance of a derived type to a base type serves no purpose, since the conversion can be done implicitly. In such cases, the redundant cast can simply be removed. However, an upcast is not redundant in the following situations:\n\n* It is being used to force a call to an overloaded callable that takes a parameter of the base type rather than one of the derived type.\n* It is being used to specify the type to use for the operands of a ternary expression.\nBoth of these special cases are illustrated in the example below. This rule ignores these special cases and highlights upcasts which appear to be redundant.\n\n\n## Recommendation\nRemove the unnecessary upcast to simplify the code.\n\n\n## Example\nThe following code includes an example of a redundant upcast that would be highlighted by this rule. In addition, three examples of upcasts that are required and are ignored by this rule.\n\n\n```java\npublic class UselessUpcast {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tprivate static void Foo(B b) { System.out.println(\"Foo(B)\"); }\n\tprivate static void Foo(D d) { System.out.println(\"Foo(D)\"); }\n\n\tprivate static class Expr {}\n\tprivate static class AddExpr extends Expr {}\n\tprivate static class SubExpr extends Expr {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tB b_ = (B)d;\t// violation: redundant cast, consider removing\n\n\t\tB b = new D();\n\t\tD d_ = (D)b;\t// non-violation: required downcast\n\n\t\tFoo(d);\n\t\tFoo((B)d);\t\t// non-violation: required to call Foo(B)\n\n\t\t// Non-violation: required to specify the type of the ternary operands.\n\t\tExpr e = d != null ? (Expr)new AddExpr() : new SubExpr();\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-upcast",
                    "name": "java/useless-upcast",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessUpcast.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless upcast"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may even indicate a bug."
                    },
                    "help": {
                      "markdown": "# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n",
                      "text": "# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n"
                    },
                    "id": "java/whitespace-contradicts-precedence",
                    "name": "java/whitespace-contradicts-precedence",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/WhitespaceContradictsPrecedence.ql",
                      "tags": [
                        "external/cwe/cwe-783",
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Whitespace contradicts operator precedence"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not detected by JUnit."
                    },
                    "help": {
                      "markdown": "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/wrong-junit-suite-signature",
                    "name": "java/wrong-junit-suite-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/BadSuiteMethod.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Bad suite method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but does not use the correct signatures causes the default serialization mechanism to be used."
                    },
                    "help": {
                      "markdown": "# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n",
                      "text": "# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n"
                    },
                    "id": "java/wrong-object-serialization-signature",
                    "name": "java/wrong-object-serialization-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/IncorrectSerializableMethods.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serialization methods do not match required signature"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An implementation of 'readResolve' that does not have the signature that is expected by the Java serialization framework is not recognized by the serialization mechanism."
                    },
                    "help": {
                      "markdown": "# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n",
                      "text": "# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/wrong-readresolve-signature",
                    "name": "java/wrong-readresolve-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/ReadResolveObject.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "ReadResolve must have Object return type, not void"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "In a class that extends a Swing or Abstract Window Toolkit event adapter, an event handler that does not have exactly the same name as the event handler that it overrides means that the overridden event handler is not called."
                    },
                    "help": {
                      "markdown": "# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n",
                      "text": "# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n"
                    },
                    "id": "java/wrong-swing-event-adapter-signature",
                    "name": "java/wrong-swing-event-adapter-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/Swing/BadlyOverriddenAdapter.ql",
                      "tags": [
                        "frameworks/swing",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Bad implementation of an event Adapter"
                    }
                  }
                ],
                "semanticVersion": "0.7.5+2501a701ad93601b7f892d9f510edb65b7e4a2da"
              }
            ]
          },
          "versionControlProvenance": [
            {
              "branch": "refs/heads/main",
              "repositoryUri": "https://github.com/octodemo-db/simple-java-project",
              "revisionId": "8170e2f69f9d7c0e0f460d0b3fbb081fb6b15772"
            }
          ]
        }
      ],
      "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
      "version": "2.1.0"
    }
  },
  "base": {
    "ageInSeconds": 1447,
    "scan": {
      "ref": "refs/heads/main",
      "commit_sha": "d70a63d1f5bbdfc3b8c4e838edfee727be5b56ab",
      "analysis_key": ".github/workflows/code_quality_pack_expriment.yml:scan",
      "environment": "{}",
      "category": "sonar-like",
      "error": "",
      "created_at": "2023-10-02T13:04:41Z",
      "results_count": 51,
      "rules_count": 142,
      "id": 124911547,
      "url": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/analyses/124911547",
      "sarif_id": "3e48e47e-6124-11ee-8c70-0e3b0d6c0f8c",
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.14.6"
      },
      "deletable": false,
      "warning": ""
    },
    "sarif": {
      "runs": [
        {
          "artifacts": [
            {
              "location": {
                "index": 0,
                "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
              }
            },
            {
              "location": {
                "index": 1,
                "uri": "src/main/java/com/github/demo/DemoServer.java"
              }
            },
            {
              "location": {
                "index": 2,
                "uri": "src/main/java/com/github/demo/model/Book.java"
              }
            },
            {
              "location": {
                "index": 3,
                "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
              }
            },
            {
              "location": {
                "index": 4,
                "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
              }
            },
            {
              "location": {
                "index": 5,
                "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
              }
            },
            {
              "location": {
                "index": 6,
                "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
              }
            },
            {
              "location": {
                "index": 7,
                "uri": "src/main/java/com/github/demo/service/BookUtils.java"
              }
            },
            {
              "location": {
                "index": 8,
                "uri": "src/main/java/com/github/demo/service/BookService.java"
              }
            },
            {
              "location": {
                "index": 9,
                "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
              }
            },
            {
              "location": {
                "index": 10,
                "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
              }
            }
          ],
          "automationDetails": {
            "id": "sonar-like/"
          },
          "conversion": {
            "tool": {
              "driver": {
                "name": "GitHub Code Scanning"
              }
            }
          },
          "results": [
            {
              "correlationGuid": "f82862a7-2f7e-46b3-98c5-352af6a56167",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 20,
                      "startColumn": 20,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This method overrides [HttpServlet.doGet](1); it is advisable to add an Override annotation."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3c367b5f91bcd568:1"
              },
              "properties": {
                "github/alertNumber": 34,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/34"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "HttpServlet.doGet"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "file:/home/runner/.m2/repository/org/eclipse/jetty/toolchain/jetty-servlet-api/4.0.5/jetty-servlet-api-4.0.5.jar/javax/servlet/http/HttpServlet.class"
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/missing-override-annotation",
                "toolComponent": {
                  "index": 0
                },
                "index": 65
              },
              "ruleId": "java/missing-override-annotation"
            },
            {
              "correlationGuid": "c1c95d40-a8c7-4c14-b317-196886efc8dd",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 20,
                      "startColumn": 24,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "44494a2dbdb9a1ce:1"
              },
              "properties": {
                "github/alertNumber": 3,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/3"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "1cff28ce-7445-413b-97f3-214cb8afda17",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 29,
                      "endLine": 45,
                      "startColumn": 19,
                      "startLine": 45
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b9437607b3c632b3:1"
              },
              "properties": {
                "github/alertNumber": 8,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/8"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d73b5f2f-eaa7-485b-8636-bf3b85598d68",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 23,
                      "startColumn": 12,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "9b703bd20ed7eb58:1"
              },
              "properties": {
                "github/alertNumber": 11,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/11"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "705359b4-dce4-4315-b9f0-bc62b15253c2",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 18,
                      "startColumn": 12,
                      "startLine": 18
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "380395c0f8f81c59:1"
              },
              "properties": {
                "github/alertNumber": 12,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/12"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "042c0efb-240d-4874-a830-ed198ef1f32d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "518b735ee3a80e78:1"
              },
              "properties": {
                "github/alertNumber": 15,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/15"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d5f0a858-ddc8-41c7-8b88-506a0d62355e",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "97e33a1f8c216390:1"
              },
              "properties": {
                "github/alertNumber": 6,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/6"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "07a69cbc-3036-4b70-8667-0e339ea1ca24",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 10,
                      "startColumn": 17,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3a1cd0254b7cbcd0:1"
              },
              "properties": {
                "github/alertNumber": 4,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/4"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "bc8d45fa-9bb9-4f4d-a51c-fdfee27914a6",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 7,
                      "startColumn": 12,
                      "startLine": 7
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5cf2232a276f9ce0:1"
              },
              "properties": {
                "github/alertNumber": 5,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/5"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "949c13e2-f5b4-449d-8c31-bb6d4c4fc050",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 27,
                      "endLine": 75,
                      "startColumn": 20,
                      "startLine": 75
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "468b77760bb20c1b:1"
              },
              "properties": {
                "github/alertNumber": 13,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/13"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "cf525e6a-2a50-4ef7-ad63-a5896d22a257",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 50,
                      "startColumn": 12,
                      "startLine": 50
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bfbc8cdb38ca8cba:1"
              },
              "properties": {
                "github/alertNumber": 14,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/14"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d9820c6e-063e-4473-9897-c849466daacb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 46,
                      "startColumn": 12,
                      "startLine": 46
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "81f57cf77b6c5b72:1"
              },
              "properties": {
                "github/alertNumber": 16,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/16"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "e9a29948-eb3b-4f4c-a167-99949edda617",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 18,
                      "endLine": 14,
                      "startColumn": 10,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b3b40cc112193332:1"
              },
              "properties": {
                "github/alertNumber": 7,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/7"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "f17b2441-342a-4f20-982d-3109b4392824",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 12,
                      "startColumn": 16,
                      "startLine": 12
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "dae1616c3d3d6eb1:1"
              },
              "properties": {
                "github/alertNumber": 9,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/9"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "8ee15b28-fc96-4f76-b21f-95e97bec1f7f",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 22,
                      "endLine": 10,
                      "startColumn": 16,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "3360404f8d27224b:1"
              },
              "properties": {
                "github/alertNumber": 10,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/10"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "2ff8ae78-8726-4957-897d-96e7ad53a6cd",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
                    },
                    "region": {
                      "endColumn": 32,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "569e915f9b444017:1"
              },
              "properties": {
                "github/alertNumber": 17,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/17"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "23f241fd-95ef-40bb-a5e4-6636bcdbac70",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 6,
                      "uri": "src/main/java/com/github/demo/service/BookServiceException.java"
                    },
                    "region": {
                      "endColumn": 32,
                      "endLine": 10,
                      "startColumn": 12,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "8f5181d5fcc3b37c:1"
              },
              "properties": {
                "github/alertNumber": 18,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/18"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "e69e66a9-472e-4542-ae28-c8ceeb281dd7",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 7,
                      "uri": "src/main/java/com/github/demo/service/BookUtils.java"
                    },
                    "region": {
                      "endColumn": 44,
                      "endLine": 10,
                      "startColumn": 30,
                      "startLine": 10
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "f20fd2ff4a3e0fe0:1"
              },
              "properties": {
                "github/alertNumber": 20,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/20"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "4c088064-061d-41c3-963f-5b7b011073cc",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "c7e3f380813e4f4d:1"
              },
              "properties": {
                "github/alertNumber": 19,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/19"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "00a746e2-d9b3-4acc-a7b2-7db25f22564c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 23,
                      "startColumn": 23,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This method does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "d3826bb5326123f5:1"
              },
              "properties": {
                "github/alertNumber": 21,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/21"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "d06feebf-e295-4519-aff1-d1b6b099eddb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 11,
                      "startColumn": 12,
                      "startLine": 11
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5a7395da5f6169ca:1"
              },
              "properties": {
                "github/alertNumber": 22,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/22"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "b9b6c229-461a-4a72-9278-7757ee1cf9dc",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 9,
                      "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
                    },
                    "region": {
                      "endColumn": 26,
                      "endLine": 15,
                      "startColumn": 12,
                      "startLine": 15
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "433ec78c10747a8e:1"
              },
              "properties": {
                "github/alertNumber": 24,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/24"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "81ccf8b9-f94e-4815-808f-cac471f7b93c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 31,
                      "startColumn": 12,
                      "startLine": 31
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "ca136ea197a5612d:1"
              },
              "properties": {
                "github/alertNumber": 23,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/23"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "c1c68b5d-98f6-4417-b406-fce4c74b01a1",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/servlet/StatusServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 17,
                      "startColumn": 12,
                      "startLine": 17
                    }
                  }
                }
              ],
              "message": {
                "text": "This constructor does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "2ee210f8987e4d4c:1"
              },
              "properties": {
                "github/alertNumber": 25,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/25"
              },
              "rule": {
                "id": "java/undocumented-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 116
              },
              "ruleId": "java/undocumented-function"
            },
            {
              "correlationGuid": "60793fe3-0c3c-4d8f-be92-cbb7daebcb36",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 24,
                      "endLine": 16,
                      "startColumn": 14,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "940645f2719e526c:1"
              },
              "properties": {
                "github/alertNumber": 26,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/26"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "e20cc37f-d6de-4c1c-935b-f2ae59ca5685",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 5,
                      "startColumn": 14,
                      "startLine": 5
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "394a65fc17100873:1"
              },
              "properties": {
                "github/alertNumber": 27,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/27"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "27cc4208-8221-4ebf-86cd-21e22d9828f8",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 30,
                      "endLine": 8,
                      "startColumn": 18,
                      "startLine": 8
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "1ffb2d89569dd73a:1"
              },
              "properties": {
                "github/alertNumber": 28,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/28"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "156ed08b-b8ba-4393-b7b1-fc5741bd69c0",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 30,
                      "endLine": 20,
                      "startColumn": 14,
                      "startLine": 20
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "ea764871e1e011c:1"
              },
              "properties": {
                "github/alertNumber": 29,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/29"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "cf995fba-d367-4b79-9aed-70f38fcd909d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 7,
                      "uri": "src/main/java/com/github/demo/service/BookUtils.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 8,
                      "startColumn": 14,
                      "startLine": 8
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "8be943fa16995f8b:1"
              },
              "properties": {
                "github/alertNumber": 31,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/31"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "d790dfe6-ec65-4db4-8825-631c6b248a0b",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 7,
                      "startColumn": 14,
                      "startLine": 7
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "13d2f681f7702725:1"
              },
              "properties": {
                "github/alertNumber": 30,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/30"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "cd2dc000-2e6d-48f1-ba7e-5c720fde6723",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 9,
                      "uri": "src/main/java/com/github/demo/servlet/InvalidServlet.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 11,
                      "startColumn": 14,
                      "startLine": 11
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "d9c3924db2087e03:1"
              },
              "properties": {
                "github/alertNumber": 33,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/33"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "6851edbc-e00b-4be7-8da4-c66ea69f191d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 23,
                      "startColumn": 14,
                      "startLine": 23
                    }
                  }
                }
              ],
              "message": {
                "text": "This type does not have a non-trivial Javadoc comment."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "63c211b65be41211:1"
              },
              "properties": {
                "github/alertNumber": 32,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/32"
              },
              "rule": {
                "id": "java/undocumented-type",
                "toolComponent": {
                  "index": 0
                },
                "index": 119
              },
              "ruleId": "java/undocumented-type"
            },
            {
              "correlationGuid": "8e16bd59-3fe7-4724-8432-da807f586cc9",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 5,
                      "startColumn": 14,
                      "startLine": 5
                    }
                  }
                }
              ],
              "message": {
                "text": "The class BrokenModel is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "394a65fc17100873:1"
              },
              "properties": {
                "github/alertNumber": 2,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/2"
              },
              "rule": {
                "id": "java/dead-class",
                "toolComponent": {
                  "index": 0
                },
                "index": 17
              },
              "ruleId": "java/dead-class"
            },
            {
              "correlationGuid": "051815fe-076c-40bb-a811-e91f68f164d9",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 53,
                      "startColumn": 17,
                      "startLine": 53
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setCover is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "51ebf0292ad0eb0f:1"
              },
              "properties": {
                "github/alertNumber": 35,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/35"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "bcdba47b-9037-4bc7-be9c-782532f6f617",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 29,
                      "endLine": 45,
                      "startColumn": 19,
                      "startLine": 45
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getDetails is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "b9437607b3c632b3:1"
              },
              "properties": {
                "github/alertNumber": 36,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/36"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "fb2525e5-6942-4556-9fc6-bedc92dfb1b7",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 26,
                      "endLine": 41,
                      "startColumn": 17,
                      "startLine": 41
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setAuthor is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "35f91ee75930f986:1"
              },
              "properties": {
                "github/alertNumber": 37,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/37"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "84e16bf8-7b0b-406f-8c59-f34673d73932",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 25,
                      "endLine": 33,
                      "startColumn": 17,
                      "startLine": 33
                    }
                  }
                }
              ],
              "message": {
                "text": "The method setTitle is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5887a7b23df0e772:1"
              },
              "properties": {
                "github/alertNumber": 38,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/38"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "c2c89122-7d5b-4e08-b8c6-429a42346ccb",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 18,
                      "startColumn": 12,
                      "startLine": 18
                    }
                  }
                }
              ],
              "message": {
                "text": "The method Book is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "380395c0f8f81c59:1"
              },
              "properties": {
                "github/alertNumber": 39,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/39"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "4cb66fac-06a4-4e14-a838-0b1d6120950c",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 2,
                      "uri": "src/main/java/com/github/demo/model/Book.java"
                    },
                    "region": {
                      "endColumn": 16,
                      "endLine": 14,
                      "startColumn": 12,
                      "startLine": 14
                    }
                  }
                }
              ],
              "message": {
                "text": "The method Book is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "518b735ee3a80e78:1"
              },
              "properties": {
                "github/alertNumber": 40,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/40"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "1a908b0f-216f-48e3-b11c-54bfbcdff3c5",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "message": {
                "text": "The method destroy is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "97e33a1f8c216390:1"
              },
              "properties": {
                "github/alertNumber": 41,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/41"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "968a7768-23af-48bc-9571-cdb40fb3836a",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 24,
                      "endLine": 148,
                      "startColumn": 17,
                      "startLine": 148
                    }
                  }
                }
              ],
              "message": {
                "text": "The method destroy is only used from dead code originating at [destroy](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bcf960f7da0b54d3:1"
              },
              "properties": {
                "github/alertNumber": 42,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/42"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "destroy"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 17,
                      "endLine": 16,
                      "startColumn": 10,
                      "startLine": 16
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "a758429c-90f8-4baa-8157-e4ea6c7ecc7d",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 38,
                      "endLine": 107,
                      "startColumn": 23,
                      "startLine": 107
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getBooksByTitle is only used from dead code originating at [searchBooks](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "37d0497d51ef382c:1"
              },
              "properties": {
                "github/alertNumber": 43,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/43"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "searchBooks"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "4db6fd4a-5777-4ea5-9e95-d81c998bcae8",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 28,
                      "endLine": 46,
                      "startColumn": 12,
                      "startLine": 46
                    }
                  }
                }
              ],
              "message": {
                "text": "The method BookDatabaseImpl is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "81f57cf77b6c5b72:1"
              },
              "properties": {
                "github/alertNumber": 44,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/44"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "05c03252-d66b-4bb0-8a8f-ca3ae0b2180f",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 3,
                      "uri": "src/main/java/com/github/demo/service/BookDatabase.java"
                    },
                    "region": {
                      "endColumn": 31,
                      "endLine": 12,
                      "startColumn": 16,
                      "startLine": 12
                    }
                  }
                }
              ],
              "message": {
                "text": "The method getBooksByTitle is only used from dead code originating at [searchBooks](1)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "dae1616c3d3d6eb1:1"
              },
              "properties": {
                "github/alertNumber": 45,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/45"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "searchBooks"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "b387c0d5-04fe-4732-ad03-f642b60dae60",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 8,
                      "uri": "src/main/java/com/github/demo/service/BookService.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 27,
                      "startColumn": 23,
                      "startLine": 27
                    }
                  }
                }
              ],
              "message": {
                "text": "The method searchBooks is entirely unused."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "c7e3f380813e4f4d:1"
              },
              "properties": {
                "github/alertNumber": 46,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/46"
              },
              "rule": {
                "id": "java/dead-function",
                "toolComponent": {
                  "index": 0
                },
                "index": 20
              },
              "ruleId": "java/dead-function"
            },
            {
              "correlationGuid": "e35d28b9-ea37-4328-83b6-110b0e60be26",
              "level": "warning",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 36,
                      "endLine": 29,
                      "startColumn": 25,
                      "startLine": 29
                    }
                  }
                }
              ],
              "message": {
                "text": "This field is in a serializable class, but is not serializable itself because BookService is not serializable."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "bd202652310c17e5:1"
              },
              "properties": {
                "github/alertNumber": 50,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/50"
              },
              "rule": {
                "id": "java/non-serializable-field",
                "toolComponent": {
                  "index": 0
                },
                "index": 74
              },
              "ruleId": "java/non-serializable-field"
            },
            {
              "correlationGuid": "49dc577b-5a00-4767-9bee-2fba011ac240",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 1,
                      "uri": "src/main/java/com/github/demo/DemoServer.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 6,
                      "startColumn": 1,
                      "startLine": 6
                    }
                  }
                }
              ],
              "message": {
                "text": "It is advisable to make imports explicit."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "aad9b6b129b12fef:1"
              },
              "properties": {
                "github/alertNumber": 51,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/51"
              },
              "rule": {
                "id": "java/implicit-import",
                "toolComponent": {
                  "index": 0
                },
                "index": 37
              },
              "ruleId": "java/implicit-import"
            },
            {
              "correlationGuid": "fcc48a6d-4046-473c-ab1f-74e8f64d278b",
              "level": "warning",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 10,
                      "uri": "src/main/java/com/github/demo/servlet/BookServlet.java"
                    },
                    "region": {
                      "endColumn": 85,
                      "endLine": 52,
                      "startColumn": 32,
                      "startLine": 52
                    }
                  }
                }
              ],
              "message": {
                "text": "The idiom getClass().getResource() is unsafe for classes that may be extended."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "5d23010d6c3bf340:1"
              },
              "properties": {
                "github/alertNumber": 52,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/52"
              },
              "rule": {
                "id": "java/unsafe-get-resource",
                "toolComponent": {
                  "index": 0
                },
                "index": 122
              },
              "ruleId": "java/unsafe-get-resource"
            },
            {
              "correlationGuid": "e65be450-9cd5-427f-a0b7-859d7c91fb95",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 38,
                      "endLine": 224,
                      "startColumn": 9,
                      "startLine": 224
                    }
                  }
                }
              ],
              "message": {
                "text": "This local variable shadows field [connection](1), which is not used in method [getConnection](2)."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "a263339cb745e0bc:1"
              },
              "properties": {
                "github/alertNumber": 53,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/53"
              },
              "relatedLocations": [
                {
                  "id": 1,
                  "message": {
                    "text": "connection"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 34,
                      "endLine": 31,
                      "startColumn": 24,
                      "startLine": 31
                    }
                  }
                },
                {
                  "id": 2,
                  "message": {
                    "text": "getConnection"
                  },
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 0,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 37,
                      "endLine": 223,
                      "startColumn": 24,
                      "startLine": 223
                    }
                  }
                }
              ],
              "rule": {
                "id": "java/local-shadows-field-unused",
                "toolComponent": {
                  "index": 0
                },
                "index": 49
              },
              "ruleId": "java/local-shadows-field-unused"
            },
            {
              "correlationGuid": "2cf4d6a6-bf1b-4ee0-9170-93ba7c437005",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 5,
                      "uri": "src/main/java/com/github/demo/service/BookDatabaseImpl.java"
                    },
                    "region": {
                      "endColumn": 41,
                      "endLine": 64,
                      "startColumn": 13,
                      "startLine": 64
                    }
                  }
                }
              ],
              "message": {
                "text": "Assignment to parameters may decrease code readability."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "27ae0193b728089b:1"
              },
              "properties": {
                "github/alertNumber": 54,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/54"
              },
              "rule": {
                "id": "java/assignment-to-parameter",
                "toolComponent": {
                  "index": 0
                },
                "index": 4
              },
              "ruleId": "java/assignment-to-parameter"
            },
            {
              "correlationGuid": "28bbe2ed-55ee-4447-95de-473fc6153924",
              "level": "note",
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "index": 4,
                      "uri": "src/main/java/com/github/demo/model/BrokenModel.java"
                    },
                    "region": {
                      "endColumn": 23,
                      "endLine": 3,
                      "startColumn": 1,
                      "startLine": 3
                    }
                  }
                }
              ],
              "message": {
                "text": "Import of 'import List' is not used."
              },
              "partialFingerprints": {
                "primaryLocationLineHash": "7ae9ae674ca3b8f5:1"
              },
              "properties": {
                "github/alertNumber": 55,
                "github/alertUrl": "https://api.github.com/repos/octodemo-db/simple-java-project/code-scanning/alerts/55"
              },
              "rule": {
                "id": "java/unused-import",
                "toolComponent": {
                  "index": 0
                },
                "index": 126
              },
              "ruleId": "java/unused-import"
            }
          ],
          "tool": {
            "driver": {
              "name": "CodeQL",
              "semanticVersion": "2.14.6"
            },
            "extensions": [
              {
                "name": "codeql/java-queries",
                "rules": [
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'Math.abs' to find the absolute value of a randomly generated integer is not guaranteed to return a non-negative integer."
                    },
                    "help": {
                      "markdown": "# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n",
                      "text": "# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n"
                    },
                    "id": "java/abs-of-random",
                    "name": "java/abs-of-random",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/BadAbsOfRandom.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Incorrect absolute value of random number"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A cast from an abstract collection to a concrete implementation type makes the code brittle."
                    },
                    "help": {
                      "markdown": "# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n",
                      "text": "# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
                    },
                    "id": "java/abstract-to-concrete-cast",
                    "name": "java/abstract-to-concrete-cast",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/AbstractToConcreteCollection.ql",
                      "tags": [
                        "external/cwe/cwe-485",
                        "maintainability",
                        "modularity",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Cast from abstract to concrete collection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Extending or implementing an annotation is unlikely to be what the programmer intends."
                    },
                    "help": {
                      "markdown": "# Annotation is extended or implemented\nAlthough an annotation type is a special kind of interface that can be implemented by a concrete class, this is not its intended use. It is more likely that an annotation type should be used to annotate a class.\n\n\n## Recommendation\nEnsure that any annotations are used to annotate a class, unless they are really supposed to be extended or implemented by the class.\n\n\n## Example\nIn the following example, the annotation `Deprecated` is implemented by the class `ImplementsAnnotation`.\n\n\n```java\npublic abstract class ImplementsAnnotation implements Deprecated {\n\t// ...\n}\n```\nThe following example shows the intended use of annotations: to annotate the class `ImplementsAnnotationFix`.\n\n\n```java\n@Deprecated\npublic abstract class ImplementsAnnotationFix {\n\t// ...\n}\n```\n\n## References\n* Java Language Specification: [Annotation Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6).\n* The Java Tutorials: [Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n",
                      "text": "# Annotation is extended or implemented\nAlthough an annotation type is a special kind of interface that can be implemented by a concrete class, this is not its intended use. It is more likely that an annotation type should be used to annotate a class.\n\n\n## Recommendation\nEnsure that any annotations are used to annotate a class, unless they are really supposed to be extended or implemented by the class.\n\n\n## Example\nIn the following example, the annotation `Deprecated` is implemented by the class `ImplementsAnnotation`.\n\n\n```java\npublic abstract class ImplementsAnnotation implements Deprecated {\n\t// ...\n}\n```\nThe following example shows the intended use of annotations: to annotate the class `ImplementsAnnotationFix`.\n\n\n```java\n@Deprecated\npublic abstract class ImplementsAnnotationFix {\n\t// ...\n}\n```\n\n## References\n* Java Language Specification: [Annotation Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6).\n* The Java Tutorials: [Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
                    },
                    "id": "java/annotation-subtype",
                    "name": "java/annotation-subtype",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/ImplementsAnnotation.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Annotation is extended or implemented"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Assigning to a local variable in a 'return' statement has no effect."
                    },
                    "help": {
                      "markdown": "# Assignment in return statement\nAn assignment is an expression. The value of an assignment expression is the value assigned to the variable. This can be useful, for example, when initializing two or more variables at once (for example, `a = b = 0;`). However, assigning to a local variable in the expression of a return statement is redundant because that value can never be read.\n\n\n## Recommendation\nRemove the redundant assignment from the `return` statement, leaving just the right-hand side of the assignment.\n\n\n## Example\nIn the following example, consider the second assignment to `ret`. The variable goes out of scope when the method returns, and the value assigned to it is never read. Therefore, the assignment is redundant. Instead, the last line of the method can be changed to `return Math.max(ret, c);`\n\n\n```java\npublic class Utilities\n{\n\tpublic static int max(int a, int b, int c) {\n\t\tint ret = Math.max(a, b)\n\t\treturn ret = Math.max(ret, c);  // Redundant assignment\n\t}\n}\n```\n\n## References\n* Java Language Specification: [ 14.17 The return Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.17), [ 15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).\n",
                      "text": "# Assignment in return statement\nAn assignment is an expression. The value of an assignment expression is the value assigned to the variable. This can be useful, for example, when initializing two or more variables at once (for example, `a = b = 0;`). However, assigning to a local variable in the expression of a return statement is redundant because that value can never be read.\n\n\n## Recommendation\nRemove the redundant assignment from the `return` statement, leaving just the right-hand side of the assignment.\n\n\n## Example\nIn the following example, consider the second assignment to `ret`. The variable goes out of scope when the method returns, and the value assigned to it is never read. Therefore, the assignment is redundant. Instead, the last line of the method can be changed to `return Math.max(ret, c);`\n\n\n```java\npublic class Utilities\n{\n\tpublic static int max(int a, int b, int c) {\n\t\tint ret = Math.max(a, b)\n\t\treturn ret = Math.max(ret, c);  // Redundant assignment\n\t}\n}\n```\n\n## References\n* Java Language Specification: [ 14.17 The return Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.17), [ 15.26 Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26).\n"
                    },
                    "id": "java/assignment-in-return",
                    "name": "java/assignment-in-return",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/AssignmentInReturn.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assignment in return statement"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Changing a parameter's value in a method or constructor may decrease code readability."
                    },
                    "help": {
                      "markdown": "# Assignment to parameter\nProgrammers usually assume that the value of a parameter is the value that was passed in to the method or constructor. Assigning a different value to a parameter in a method or constructor invalidates that assumption.\n\n\n## Recommendation\nAvoid assignment to parameters by doing one of the following:\n\n* Introduce a local variable and assign to that instead.\n* Use an expression directly rather than assigning it to a parameter.\n\n## Example\nIn the following example, the first method shows assignment to the parameter `miles`. The second method shows how to avoid this by using the expression `miles * KM_PER_MILE`. The third method shows how to avoid the assignment by declaring a local variable `kilometres` and assigning to that.\n\n\n```java\nfinal private static double KM_PER_MILE = 1.609344;\n\n// AVOID: Example that assigns to a parameter\npublic double milesToKM(double miles) {\n\tmiles *= KM_PER_MILE;\n\treturn miles;\n}\n\n// GOOD: Example of using an expression instead\npublic double milesToKM(double miles) {\n\treturn miles * KM_PER_MILE;\n}\n\n// GOOD: Example of using a local variable\npublic double milesToKM(double miles) {\n\tdouble kilometres = miles * KM_PER_MILE;\n\treturn kilometres;\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Basics: [Methods 4 - Local variables](https://web.archive.org/web/20200223080939/http://leepoint.net/JavaBasics/methods/methods-22-local-variables.html).\n",
                      "text": "# Assignment to parameter\nProgrammers usually assume that the value of a parameter is the value that was passed in to the method or constructor. Assigning a different value to a parameter in a method or constructor invalidates that assumption.\n\n\n## Recommendation\nAvoid assignment to parameters by doing one of the following:\n\n* Introduce a local variable and assign to that instead.\n* Use an expression directly rather than assigning it to a parameter.\n\n## Example\nIn the following example, the first method shows assignment to the parameter `miles`. The second method shows how to avoid this by using the expression `miles * KM_PER_MILE`. The third method shows how to avoid the assignment by declaring a local variable `kilometres` and assigning to that.\n\n\n```java\nfinal private static double KM_PER_MILE = 1.609344;\n\n// AVOID: Example that assigns to a parameter\npublic double milesToKM(double miles) {\n\tmiles *= KM_PER_MILE;\n\treturn miles;\n}\n\n// GOOD: Example of using an expression instead\npublic double milesToKM(double miles) {\n\treturn miles * KM_PER_MILE;\n}\n\n// GOOD: Example of using a local variable\npublic double milesToKM(double miles) {\n\tdouble kilometres = miles * KM_PER_MILE;\n\treturn kilometres;\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Basics: [Methods 4 - Local variables](https://web.archive.org/web/20200223080939/http://leepoint.net/JavaBasics/methods/methods-22-local-variables.html).\n"
                    },
                    "id": "java/assignment-to-parameter",
                    "name": "java/assignment-to-parameter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/ParameterAssignment.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assignment to parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling the default implementation of 'toString' returns a value that is unlikely to be what you expect."
                    },
                    "help": {
                      "markdown": "# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/call-to-object-tostring",
                    "name": "java/call-to-object-tostring",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/DefaultToString.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use of default toString()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Casting 'this' to a type parameter of the current type masks an implicit type constraint that should be explicitly stated."
                    },
                    "help": {
                      "markdown": "# Cast of 'this' to a type parameter\nCasting `this` to a type parameter usually suggests that there is an implicit type constraint - the programmer probably wanted to express the notion that `this` could be converted to the type parameter (when using the enclosing method from derived types). However, casting to the desired type, relies on derived types to ensure that the cast will succeed without the compiler forcing them to do so.\n\n\n## Recommendation\nThe solution is to enforce the constraint by adding an abstract method on the base type (see example below). Each derived type must then implement this method, which makes the constraint checkable by the compiler and removes the need for a cast.\n\n\n## Example\nIn this example `BadBaseNode` relies on derived types to use the right pattern.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class BadBaseNode<T extends BadBaseNode<T>> {\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// BAD: relies on derived types to use the right pattern\n\t\t\tT cur = (T)this;\n\t\t\twhile(cur.getParent() != null) {\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n}\n```\nThis constraint is better enforced by adding an abstract method on the base type. Implementing this method makes the constraint checkable by the compiler.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class GoodBaseNode<T extends GoodBaseNode<T>> {\n\t\tpublic abstract T getSelf();\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// GOOD: introduce an abstract method to enforce the constraint\n\t\t\t// that 'this' can be converted to T for derived types\n\t\t\tT cur = getSelf();\n\t\t\twhile(cur.getParent() != null)\n\t\t\t{\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tprivate static class GoodConcreteNode extends GoodBaseNode<GoodConcreteNode> {\n\t\tprivate String name;\n\t\tprivate GoodConcreteNode parent;\n\n\t\tpublic GoodConcreteNode(String name, GoodConcreteNode parent)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getSelf() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGoodConcreteNode a = new GoodConcreteNode(\"a\", null);\n\t\tGoodConcreteNode b = new GoodConcreteNode(\"b\", a);\n\t\tGoodConcreteNode c = new GoodConcreteNode(\"c\", a);\n\t\tGoodConcreteNode d = new GoodConcreteNode(\"d\", b);\n\t\tGoodConcreteNode root = d.getRoot();\n\t\tSystem.out.println(a + \" \" + root);\n\t}\n}\n```\n",
                      "text": "# Cast of 'this' to a type parameter\nCasting `this` to a type parameter usually suggests that there is an implicit type constraint - the programmer probably wanted to express the notion that `this` could be converted to the type parameter (when using the enclosing method from derived types). However, casting to the desired type, relies on derived types to ensure that the cast will succeed without the compiler forcing them to do so.\n\n\n## Recommendation\nThe solution is to enforce the constraint by adding an abstract method on the base type (see example below). Each derived type must then implement this method, which makes the constraint checkable by the compiler and removes the need for a cast.\n\n\n## Example\nIn this example `BadBaseNode` relies on derived types to use the right pattern.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class BadBaseNode<T extends BadBaseNode<T>> {\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// BAD: relies on derived types to use the right pattern\n\t\t\tT cur = (T)this;\n\t\t\twhile(cur.getParent() != null) {\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n}\n```\nThis constraint is better enforced by adding an abstract method on the base type. Implementing this method makes the constraint checkable by the compiler.\n\n\n```java\npublic class CastThisToTypeParameter {\n\tprivate abstract static class GoodBaseNode<T extends GoodBaseNode<T>> {\n\t\tpublic abstract T getSelf();\n\t\tpublic abstract T getParent();\n\n\t\tpublic T getRoot() {\n\t\t\t// GOOD: introduce an abstract method to enforce the constraint\n\t\t\t// that 'this' can be converted to T for derived types\n\t\t\tT cur = getSelf();\n\t\t\twhile(cur.getParent() != null)\n\t\t\t{\n\t\t\t\tcur = cur.getParent();\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tprivate static class GoodConcreteNode extends GoodBaseNode<GoodConcreteNode> {\n\t\tprivate String name;\n\t\tprivate GoodConcreteNode parent;\n\n\t\tpublic GoodConcreteNode(String name, GoodConcreteNode parent)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getSelf() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic GoodConcreteNode getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGoodConcreteNode a = new GoodConcreteNode(\"a\", null);\n\t\tGoodConcreteNode b = new GoodConcreteNode(\"b\", a);\n\t\tGoodConcreteNode c = new GoodConcreteNode(\"c\", a);\n\t\tGoodConcreteNode d = new GoodConcreteNode(\"d\", b);\n\t\tGoodConcreteNode root = d.getRoot();\n\t\tSystem.out.println(a + \" \" + root);\n\t}\n}\n```\n"
                    },
                    "id": "java/cast-of-this-to-type-parameter",
                    "name": "java/cast-of-this-to-type-parameter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/CastThisToTypeParameter.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Cast of 'this' to a type parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Long sequences of type tests on a variable are difficult to maintain."
                    },
                    "help": {
                      "markdown": "# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n",
                      "text": "# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n"
                    },
                    "id": "java/chained-type-tests",
                    "name": "java/chained-type-tests",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/ChainedInstanceof.ql",
                      "tags": [
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Chain of 'instanceof' tests"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A class that has the same name as its superclass may be confusing."
                    },
                    "help": {
                      "markdown": "# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n",
                      "text": "# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/class-name-matches-super-class",
                    "name": "java/class-name-matches-super-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/SameNameAsSuper.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Class has same name as super class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Commented-out code makes the remaining code more difficult to read."
                    },
                    "help": {
                      "markdown": "# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n",
                      "text": "# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n"
                    },
                    "id": "java/commented-out-code",
                    "name": "java/commented-out-code",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Comments/CommentedCode.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Commented-out code"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A block that contains too many complex statements becomes unreadable and unmaintainable."
                    },
                    "help": {
                      "markdown": "# Block with too many statements\nCode has a tendency to become more complex over time. A method that is initially simple may need to be extended to accommodate additional functionality or to address defects. Before long it becomes unreadable and unmaintainable, with many complex statements nested within each other.\n\nThis rule applies to a block that contains a significant number of complex statements. Note that this is quite different from just considering the number of statements in a block, because each complex statement is potentially a candidate for being extracted to a new method as part of refactoring. For the purposes of this rule, loops and switch statements are considered to be complex.\n\n\n## Recommendation\nTo make the code more understandable and less complex, identify logical units and extract them to new methods. As a result, the top-level logic becomes clearer.\n\n\n## References\n* M. Fowler, *Refactoring: Improving the Design of Existing Code*. Addison-Wesley Professional, 1999.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n",
                      "text": "# Block with too many statements\nCode has a tendency to become more complex over time. A method that is initially simple may need to be extended to accommodate additional functionality or to address defects. Before long it becomes unreadable and unmaintainable, with many complex statements nested within each other.\n\nThis rule applies to a block that contains a significant number of complex statements. Note that this is quite different from just considering the number of statements in a block, because each complex statement is potentially a candidate for being extracted to a new method as part of refactoring. For the purposes of this rule, loops and switch statements are considered to be complex.\n\n\n## Recommendation\nTo make the code more understandable and less complex, identify logical units and extract them to new methods. As a result, the top-level logic becomes clearer.\n\n\n## References\n* M. Fowler, *Refactoring: Improving the Design of Existing Code*. Addison-Wesley Professional, 1999.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/complex-block",
                    "name": "java/complex-block",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Complexity/BlockWithTooManyStatements.ql",
                      "tags": [
                        "complexity",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Block with too many statements"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Methods in the same class whose names differ only in capitalization are confusing."
                    },
                    "help": {
                      "markdown": "# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n",
                      "text": "# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/confusing-method-name",
                    "name": "java/confusing-method-name",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingMethodNames.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing method names because of capitalization"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Overloaded methods that have the same number of parameters, where each pair of corresponding parameter types is convertible by casting or autoboxing, may be confusing."
                    },
                    "help": {
                      "markdown": "# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n",
                      "text": "# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n"
                    },
                    "id": "java/confusing-method-signature",
                    "name": "java/confusing-method-signature",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingOverloading.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing overloading of methods"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that would override another method but does not, because the name is capitalized differently, is confusing and may be a mistake."
                    },
                    "help": {
                      "markdown": "# Confusing method names because of overriding\nIf a method that would override another method but does not because the name is capitalized differently, there are two possibilities:\n\n* The programmer intends the method to override the other method, and the difference in capitalization is a typographical error.\n* The programmer does not intend the method to override the other method, in which case the similarity of the names is very confusing.\n\n## Recommendation\nIf overriding *is* intended, make the capitalization of the two methods the same.\n\nIf overriding is *not* intended, consider naming the methods to make the distinction between them clear.\n\n\n## Example\nIn the following example, `toString` has been wrongly capitalized as `tostring`. This means that objects of type `Customer` do not print correctly.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // Incorrect capitalization of 'toString'\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n",
                      "text": "# Confusing method names because of overriding\nIf a method that would override another method but does not because the name is capitalized differently, there are two possibilities:\n\n* The programmer intends the method to override the other method, and the difference in capitalization is a typographical error.\n* The programmer does not intend the method to override the other method, in which case the similarity of the names is very confusing.\n\n## Recommendation\nIf overriding *is* intended, make the capitalization of the two methods the same.\n\nIf overriding is *not* intended, consider naming the methods to make the distinction between them clear.\n\n\n## Example\nIn the following example, `toString` has been wrongly capitalized as `tostring`. This means that objects of type `Customer` do not print correctly.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // Incorrect capitalization of 'toString'\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n"
                    },
                    "id": "java/confusing-override-name",
                    "name": "java/confusing-override-name",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/ConfusingOverridesNames.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing method names because of overriding"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Implementing an interface (or extending an abstract class) only to put a number of constant definitions into scope is considered bad practice."
                    },
                    "help": {
                      "markdown": "# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n",
                      "text": "# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/constants-only-interface",
                    "name": "java/constants-only-interface",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Declarations/NoConstantsOnly.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Constant interface anti-pattern"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that has the same name as its declaring type may have been intended to be a constructor."
                    },
                    "help": {
                      "markdown": "# Typo in constructor\nA method that has the same name as its declaring type may be intended to be a constructor, not a method.\n\n\n## Example\nThe following example shows how the singleton design pattern is often misimplemented. The programmer intends the constructor of `MasterSingleton` to be protected so that it cannot be instantiated (because the singleton instance should be retrieved using `getInstance`). However, the programmer accidentally wrote `void` in front of the constructor name, which makes it a method rather than a constructor.\n\n\n```java\nclass MasterSingleton\n{\n\t// ...\n\n\tprivate static MasterSingleton singleton = new MasterSingleton();\n\tpublic static MasterSingleton getInstance() { return singleton; }\n\n\t// Make the constructor 'protected' to prevent this class from being instantiated.\n\tprotected void MasterSingleton() { }\n}\n\n```\n\n## Recommendation\nEnsure that methods that have the same name as their declaring type are intended to be methods. Even if they are intended to be methods, it may be better to rename them to avoid confusion.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 63. Addison-Wesley, 2005.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design Patterns: Elements of Reusable Objection-Oriented Software*, &sect;3. Addison-Wesley Longman Publishing Co. Inc., 1995.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4 Method Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4), [8.8 Constructor Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8).\n",
                      "text": "# Typo in constructor\nA method that has the same name as its declaring type may be intended to be a constructor, not a method.\n\n\n## Example\nThe following example shows how the singleton design pattern is often misimplemented. The programmer intends the constructor of `MasterSingleton` to be protected so that it cannot be instantiated (because the singleton instance should be retrieved using `getInstance`). However, the programmer accidentally wrote `void` in front of the constructor name, which makes it a method rather than a constructor.\n\n\n```java\nclass MasterSingleton\n{\n\t// ...\n\n\tprivate static MasterSingleton singleton = new MasterSingleton();\n\tpublic static MasterSingleton getInstance() { return singleton; }\n\n\t// Make the constructor 'protected' to prevent this class from being instantiated.\n\tprotected void MasterSingleton() { }\n}\n\n```\n\n## Recommendation\nEnsure that methods that have the same name as their declaring type are intended to be methods. Even if they are intended to be methods, it may be better to rename them to avoid confusion.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 63. Addison-Wesley, 2005.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design Patterns: Elements of Reusable Objection-Oriented Software*, &sect;3. Addison-Wesley Longman Publishing Co. Inc., 1995.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4 Method Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4), [8.8 Constructor Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8).\n"
                    },
                    "id": "java/constructor-typo",
                    "name": "java/constructor-typo",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/ConstructorTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Two otherwise unrelated classes that share too much information about each other are difficult to maintain, change and understand."
                    },
                    "help": {
                      "markdown": "# Inappropriate Intimacy\n*Inappropriate intimacy* is an anti-pattern that describes a pair of otherwise unrelated classes that are too tightly coupled: each class uses a significant number of methods and fields of the other. This makes both classes difficult to maintain, change and understand. Inappropriate intimacy is the same as the \"feature envy\" anti-pattern but in both directions: each class is \"envious\" of some functionality or data defined in the other class.\n\n\n## Recommendation\nThe solution might be as simple as moving some misplaced methods to their rightful place, or perhaps some tangled bits of code need to be extracted to their own methods first before being moved.\n\nSometimes the entangled parts (both fields and methods) indicate a missing object or level of abstraction. It might make sense to combine them into a new type that can be used in both classes. You may need to introduce delegation to hide some implementation details.\n\nIt may be necessary to convert the bidirectional association into a unidirectional relationship, possibly by using dependency inversion.\n\nModern IDEs provide refactoring support for this sort of issue, usually with the names \"Move method\", \"Extract method\" or \"Extract class\".\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 95&ndash;96. Addison-Wesley Professional, 2004.\n",
                      "text": "# Inappropriate Intimacy\n*Inappropriate intimacy* is an anti-pattern that describes a pair of otherwise unrelated classes that are too tightly coupled: each class uses a significant number of methods and fields of the other. This makes both classes difficult to maintain, change and understand. Inappropriate intimacy is the same as the \"feature envy\" anti-pattern but in both directions: each class is \"envious\" of some functionality or data defined in the other class.\n\n\n## Recommendation\nThe solution might be as simple as moving some misplaced methods to their rightful place, or perhaps some tangled bits of code need to be extracted to their own methods first before being moved.\n\nSometimes the entangled parts (both fields and methods) indicate a missing object or level of abstraction. It might make sense to combine them into a new type that can be used in both classes. You may need to introduce delegation to hide some implementation details.\n\nIt may be necessary to convert the bidirectional association into a unidirectional relationship, possibly by using dependency inversion.\n\nModern IDEs provide refactoring support for this sort of issue, usually with the names \"Move method\", \"Extract method\" or \"Extract class\".\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 95&ndash;96. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/coupled-types",
                    "name": "java/coupled-types",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/InappropriateIntimacy.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inappropriate Intimacy"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead classes add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead class\nClasses that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nClasses are considered dead if at runtime:\n\n* No methods declared in the class, or a sub-type, are called.\n* No fields declared in the class, or a sub-type, are read.\n* The class is never constructed.\nAny class which is not dead is considered to be \"live\". Nested classes are considered and listed separately, as a live nested class within a dead outer class can be moved to a separate file, allowing the outer class to be deleted.\n\nA special exception is made for \"namespace classes\". A namespace class is used only to group static fields, methods and nested classes - it is never instantiated, has no public constructor and has no instance methods. If a class is considered to be a namespace class, then it is live if at least one of the static members of that class is live - including static nested classes.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the class is not required by verifying that the only dependencies on the class are from other dead classes and methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the class is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the class is not required, remove the class. You will also need to remove any references to this class, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nNested classes within this type should be moved, either to a new top-level type, or to another type, unless they are also marked as dead, in which case they can also be removed. Alternatively, if there are some live nested classes within the dead class, the class can be retained by converting all live nested classes to static members, and removing all instance methods and fields, and all dead static members (see Example 2).\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of classes, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\tString firstName = /*...*/; String lastName = /*...*/;\n\t// Construct a customer\n\tCustomer customer = new Customer();\n\t// Set important properties (but not the address)\n\tcustomer.setName(firstName, lastName);\n\t// Save the customer\n\tcustomer.save();\n}\n\npublic class Customer {\n\tprivate Address address;\n\t// ...\n\n\t// This setter and getter are unused, and so may be deleted.\n\tpublic void addAddress(String line1, String line2, String line3) {\n\t\taddress = new Address(line1, line2, line3);\n\t}\n\tpublic Address getAddress() { return address; }\n}\n\n/*\n * This class is only constructed from dead code, and may be deleted.\n */\npublic class Address {\n\t// ...\n\tpublic Address(String line1, String line2, String line3) {\n\t\t// ...\n\t}\n}\n\n```\nThe class `Customer` is constructed in the main method, and is therefore live. The class `Address` is constructed in `setAddress`, so we might think that it would also be live. However, `setAddress` is never called by the main method, so, assuming that this is the entire program, an `Address` is never constructed at runtime. Therefore, the `Address` class is dead and can be removed without changing the meaning of this program. To delete the `Address` class we will also need to delete the `setAddress` and `getAddress` methods, and the `address` field, otherwise the program will not compile.\n\n\n## Example 2\nIn the next example, we have a `CustomerActions` class containing `Action`s that affect customers. For example, this could be a Java Swing application, and the `Action`s could be actions that are available in the user interface.\n\n\n```java\n/*\n * This class is dead because it is never constructed, and the instance methods are not\n * called.\n */\npublic class CustomerActions {\n\tpublic CustomerActions() {\n\t}\n\n\t// This method is never called,\n\tpublic Action createAddCustomerAction () {\n\t\treturn new AddCustomerAction();\n\t}\n\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\nThe `CustomerActions` class has a constructor and an instance method, which are never called. Instead, actions are instantiated directly. Although this makes the nested `Action` classes live, live nested classes do not make the outer class live. Therefore, the `CustomerActions` class is marked as dead.\n\nThere are two ways to resolve the dead `CustomerActions` class:\n\n* Move each nested static action that is used by the program to a new file, or nest it within a different class, then delete the dead `CustomerActions` class.\n* Convert the `CustomerActions` class to a *namespace class*. First convert the constructor to a *suppressed constructor* by making it private, preventing the class from being instantiated, then remove the instance method `createAddCustomerAction`.\nTaking the second approach, this is the final result.\n\n\n```java\n// This class is now live - it is used as a namespace class\npublic class CustomerActions {\n\t/*\n\t * This constructor is suppressing construction of this class, so is not considered\n\t * dead.\n\t */\n\tprivate CustomerActions() { }\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead class\nClasses that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nClasses are considered dead if at runtime:\n\n* No methods declared in the class, or a sub-type, are called.\n* No fields declared in the class, or a sub-type, are read.\n* The class is never constructed.\nAny class which is not dead is considered to be \"live\". Nested classes are considered and listed separately, as a live nested class within a dead outer class can be moved to a separate file, allowing the outer class to be deleted.\n\nA special exception is made for \"namespace classes\". A namespace class is used only to group static fields, methods and nested classes - it is never instantiated, has no public constructor and has no instance methods. If a class is considered to be a namespace class, then it is live if at least one of the static members of that class is live - including static nested classes.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the class is not required by verifying that the only dependencies on the class are from other dead classes and methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the class is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the class is not required, remove the class. You will also need to remove any references to this class, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nNested classes within this type should be moved, either to a new top-level type, or to another type, unless they are also marked as dead, in which case they can also be removed. Alternatively, if there are some live nested classes within the dead class, the class can be retained by converting all live nested classes to static members, and removing all instance methods and fields, and all dead static members (see Example 2).\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of classes, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\tString firstName = /*...*/; String lastName = /*...*/;\n\t// Construct a customer\n\tCustomer customer = new Customer();\n\t// Set important properties (but not the address)\n\tcustomer.setName(firstName, lastName);\n\t// Save the customer\n\tcustomer.save();\n}\n\npublic class Customer {\n\tprivate Address address;\n\t// ...\n\n\t// This setter and getter are unused, and so may be deleted.\n\tpublic void addAddress(String line1, String line2, String line3) {\n\t\taddress = new Address(line1, line2, line3);\n\t}\n\tpublic Address getAddress() { return address; }\n}\n\n/*\n * This class is only constructed from dead code, and may be deleted.\n */\npublic class Address {\n\t// ...\n\tpublic Address(String line1, String line2, String line3) {\n\t\t// ...\n\t}\n}\n\n```\nThe class `Customer` is constructed in the main method, and is therefore live. The class `Address` is constructed in `setAddress`, so we might think that it would also be live. However, `setAddress` is never called by the main method, so, assuming that this is the entire program, an `Address` is never constructed at runtime. Therefore, the `Address` class is dead and can be removed without changing the meaning of this program. To delete the `Address` class we will also need to delete the `setAddress` and `getAddress` methods, and the `address` field, otherwise the program will not compile.\n\n\n## Example 2\nIn the next example, we have a `CustomerActions` class containing `Action`s that affect customers. For example, this could be a Java Swing application, and the `Action`s could be actions that are available in the user interface.\n\n\n```java\n/*\n * This class is dead because it is never constructed, and the instance methods are not\n * called.\n */\npublic class CustomerActions {\n\tpublic CustomerActions() {\n\t}\n\n\t// This method is never called,\n\tpublic Action createAddCustomerAction () {\n\t\treturn new AddCustomerAction();\n\t}\n\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\nThe `CustomerActions` class has a constructor and an instance method, which are never called. Instead, actions are instantiated directly. Although this makes the nested `Action` classes live, live nested classes do not make the outer class live. Therefore, the `CustomerActions` class is marked as dead.\n\nThere are two ways to resolve the dead `CustomerActions` class:\n\n* Move each nested static action that is used by the program to a new file, or nest it within a different class, then delete the dead `CustomerActions` class.\n* Convert the `CustomerActions` class to a *namespace class*. First convert the constructor to a *suppressed constructor* by making it private, preventing the class from being instantiated, then remove the instance method `createAddCustomerAction`.\nTaking the second approach, this is the final result.\n\n\n```java\n// This class is now live - it is used as a namespace class\npublic class CustomerActions {\n\t/*\n\t * This constructor is suppressing construction of this class, so is not considered\n\t * dead.\n\t */\n\tprivate CustomerActions() { }\n\t// These two are used directly\n\tpublic static class AddCustomerAction extends Action { /* ... */ }\n\tpublic static class RemoveCustomerAction extends Action { /* ... */ }\n}\n\npublic static void main(String[] args) {\n\t// Construct the actions directly\n\tAction action = new CustomerActions.AddCustomerAction();\n\taction.run();\n\tAction action = new CustomerActions.RemoveCustomerAction();\n\taction.run();\n}\n\n```\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-class",
                    "name": "java/dead-class",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadClass.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead enum constants add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead enum constant\nEnum constants that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nAn enum constant is considered dead if at runtime it is never used, or only used in comparisons. Any enum constant which is not dead is considered to be \"live\".\n\nAn enum constant that is only used in a comparison is considered dead because the comparison will always produce the same result. This is because no variable holds the value of the enum constant, so the comparison of any variable against the constant will always return the same result.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the enum constant is not required by verifying that the enum constant is never used. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the enum constant is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the enum constant is not required, remove the enum constant. You will also need to remove any references to this enum constant, which may, in turn, require removing other dead code.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example\nIn the following example, we have an enum class called `Result`, intended to report the result of some operation:\n\n\n```java\npublic enum Result {\n\tSUCCESS,\n\tFAILURE,\n\tERROR\n}\n\npublic Result runOperation(String value) {\n\tif (value == 1) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\npublic static void main(String[] args) {\n\tResult operationResult = runOperation(args[0]);\n\tif (operationResult == Result.ERROR) {\n\t\texit(1);\n\t} else {\n\t\texit(0);\n\t}\n\n}\n```\nThe method `runOperation` performs some operation, and returns a `Result` depending on whether the operation succeeded. However, it only returns either `SUCCESS` or `FAILURE`, and never `ERROR`. The `main` method calls `runOperation`, and checks whether the returned result is the `ERROR`. However, this check will always return the same result - `false`. This is because the `operationResult` can never hold `ERROR`, because `ERROR` is never stored or returned anywhere in the program. Therefore, `ERROR` is dead and can be removed, along with the comparison check, and the `exit(1);`.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead enum constant\nEnum constants that are never used at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nAn enum constant is considered dead if at runtime it is never used, or only used in comparisons. Any enum constant which is not dead is considered to be \"live\".\n\nAn enum constant that is only used in a comparison is considered dead because the comparison will always produce the same result. This is because no variable holds the value of the enum constant, so the comparison of any variable against the constant will always return the same result.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the enum constant is not required by verifying that the enum constant is never used. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the enum constant is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the enum constant is not required, remove the enum constant. You will also need to remove any references to this enum constant, which may, in turn, require removing other dead code.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example\nIn the following example, we have an enum class called `Result`, intended to report the result of some operation:\n\n\n```java\npublic enum Result {\n\tSUCCESS,\n\tFAILURE,\n\tERROR\n}\n\npublic Result runOperation(String value) {\n\tif (value == 1) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\npublic static void main(String[] args) {\n\tResult operationResult = runOperation(args[0]);\n\tif (operationResult == Result.ERROR) {\n\t\texit(1);\n\t} else {\n\t\texit(0);\n\t}\n\n}\n```\nThe method `runOperation` performs some operation, and returns a `Result` depending on whether the operation succeeded. However, it only returns either `SUCCESS` or `FAILURE`, and never `ERROR`. The `main` method calls `runOperation`, and checks whether the returned result is the `ERROR`. However, this check will always return the same result - `false`. This is because the `operationResult` can never hold `ERROR`, because `ERROR` is never stored or returned anywhere in the program. Therefore, `ERROR` is dead and can be removed, along with the comparison check, and the `exit(1);`.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-enum-constant",
                    "name": "java/dead-enum-constant",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadEnumConstant.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead enum constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Fields that are never read are likely unnecessary."
                    },
                    "help": {
                      "markdown": "# Dead field\nFields that are never read at runtime are unnecessary and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nFields are considered dead if at runtime they are never read directly or indirectly, for example through a framework or a use of reflection. Any field which is not dead is considered to be \"live\".\n\nFields are considered to be dead if they are only written to, and never read.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the field is not required by verifying that the field is only read from dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the field is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the field is not required, remove the field. You will also need to remove any references to this field, which may, in turn, require removing other unused classes, methods and fields.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a class containing a single field called `deadField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int deadField;\n\n\tprivate int getDeadField() {\n\t\treturn deadField;\n\t}\n}\n```\nThe field is only read from the method `getDeadField`. However, `getDeadField` is never called, so the field is never read at runtime. The field is therefore marked as dead.\n\n\n## Example 2\nIn this example, we have another class containing a single field called `writtenToField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int writtenToField;\n\n\tpublic void runThing() {\n\t\twrittenToField = 2;\n\t\tcallOtherThing();\n\t}\n\n\tpublic static main(String[] args) {\n\t\trunThing();\n\t}\n}\n```\nThe field is written to in the method `runThing`, which is live because it is called by the `main` method. However, the field is never read at runtime, only written to. The field is therefore marked as dead.\n\n\n## Example 3\nIn this example, we have a class representing something that can be serialized to and from XML:\n\n\n```java\n@XmlRootElement\npublic class SerializableClass {\n\t@XmlAttribute\n\tprivate String field;\n\n\tpublic void setField(String field) {\n\t\tthis.field = field;\n\t}\n}\n```\nThe field `field` is written and read by the serialization framework in order to store the contents of the object in an XML file, or to construct an instance of the object from an XML file. The field is therefore considered to be read at runtime, which makes the field live.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead field\nFields that are never read at runtime are unnecessary and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nFields are considered dead if at runtime they are never read directly or indirectly, for example through a framework or a use of reflection. Any field which is not dead is considered to be \"live\".\n\nFields are considered to be dead if they are only written to, and never read.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the field is not required by verifying that the field is only read from dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the field is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the field is not required, remove the field. You will also need to remove any references to this field, which may, in turn, require removing other unused classes, methods and fields.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a class containing a single field called `deadField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int deadField;\n\n\tprivate int getDeadField() {\n\t\treturn deadField;\n\t}\n}\n```\nThe field is only read from the method `getDeadField`. However, `getDeadField` is never called, so the field is never read at runtime. The field is therefore marked as dead.\n\n\n## Example 2\nIn this example, we have another class containing a single field called `writtenToField`:\n\n\n```java\npublic class FieldOnlyRead {\n\tprivate int writtenToField;\n\n\tpublic void runThing() {\n\t\twrittenToField = 2;\n\t\tcallOtherThing();\n\t}\n\n\tpublic static main(String[] args) {\n\t\trunThing();\n\t}\n}\n```\nThe field is written to in the method `runThing`, which is live because it is called by the `main` method. However, the field is never read at runtime, only written to. The field is therefore marked as dead.\n\n\n## Example 3\nIn this example, we have a class representing something that can be serialized to and from XML:\n\n\n```java\n@XmlRootElement\npublic class SerializableClass {\n\t@XmlAttribute\n\tprivate String field;\n\n\tpublic void setField(String field) {\n\t\tthis.field = field;\n\t}\n}\n```\nThe field `field` is written and read by the serialization framework in order to store the contents of the object in an XML file, or to construct an instance of the object from an XML file. The field is therefore considered to be read at runtime, which makes the field live.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-field",
                    "name": "java/dead-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadField.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Dead methods add unnecessary complexity."
                    },
                    "help": {
                      "markdown": "# Dead method\nMethods that are never called at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nMethods are considered dead if at runtime they are never called, either directly, by a method call, or indirectly, through a framework or use of reflection. Any method which is not dead is considered to be \"live\".\n\nThe results can include methods, constructors and initializers. Initializers come in two forms, instance initializers and static initializers. For each class there will be at most one dead initializer of each type, representing all the initialization of that type in the class.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the method is not required by verifying that the only dependencies on the method are from other dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the method is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the method is not required, remove the method. You will also need to remove any references to this method, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nIf the result is a static initializer, then all `static { ... }` blocks and initializers on static fields are dead within that class. In addition, the lack of static initialization implies that all static methods and fields are also dead and can be removed. These methods and fields will also be reported separately. In contrast, static nested classes may still be live, because constructing or accessing the nested static class does not trigger static initialization of the outer class.\n\nIf the result is an instance initializer, then all instance initializer `{ ... }` blocks and initializers on instance fields are dead. In addition, the lack of instance initialization implies that the class is never constructed, which means that all instance methods and fields are also dead and can be removed. These methods and fields will also be reported separately.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of methods, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\t// Only call the live method\n\tliveMethod();\n}\n\n/** This method is live because it is called by main(..) */\npublic static void liveMethod() {\n\totherLiveMethod()\n}\n\n/** This method is live because it is called by a live method */\npublic static void otherLiveMethod() {\n}\n\n\n/** This method is dead because it is never called */\npublic static void deadMethod() {\n\totherDeadMethod();\n}\n\n/** This method is dead because it is only called by dead methods */\npublic static void otherDeadMethod() {\n}\n```\nThe method `liveMethod` is called from the main method, and is therefore considered live. `liveMethod` calls `otherLiveMethod`, which also makes that live.\n\nIn contrast, `deadMethod` is never called, and does not represent an entry point, so is marked as dead. Likewise, `otherDeadMethod` is only called from the `deadMethod`, so is also marked as dead.\n\n\n## Example 2\nIn this example, we have a test class containing a number of methods.\n\n\n```java\npublic class TestClass {\n\n\t@Before\n\tpublic void setUp() {\n\t\t// ...\n\t}\n\n\t@Test\n\tpublic void testCustomer() {\n\t\t// ...\n\t}\n}\n```\nIn this case, no methods are called directly. However, the annotations on the methods indicate that this is a test class - specifically, JUnit - and that the methods will be called by the test framework when running the tests. `testCustomer` and `setUp` are therefore considered to be \"live\".\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Dead method\nMethods that are never called at runtime are redundant and should be removed.\n\nRedundant, or \"dead\", code imposes a burden on those reading or maintaining the software project. It can make it harder to understand the structure of the code, as well as increasing the complexity of adding new features or fixing bugs. It can also affect compilation and build times for the project, as dead code will still be compiled and built even if it is never used. In some cases it may also affect runtime performance - for example, fields that are written to but never read from, where the value written to the field is expensive to compute. Removing dead code should not change the meaning of the program.\n\nMethods are considered dead if at runtime they are never called, either directly, by a method call, or indirectly, through a framework or use of reflection. Any method which is not dead is considered to be \"live\".\n\nThe results can include methods, constructors and initializers. Initializers come in two forms, instance initializers and static initializers. For each class there will be at most one dead initializer of each type, representing all the initialization of that type in the class.\n\nA class, method, or field may be dead even if it has dependencies from other parts of the program, if those dependencies are from code that is also considered to be dead. We can also consider this from the opposite side - an element is live, if and only if there is an entry point - such as a `main` method - that eventually calls the method, reads the field or constructs the class.\n\nWhen identifying dead code, we make an assumption that the snapshot of the project includes all possible callers of the code. If the project is a library project, this may not be the case, and code may be flagged as dead when it is only used by other projects not included in the snapshot.\n\nYou can customize the results by defining additional \"entry points\" or by identifying fields that are accessed using reflection. You may also wish to \"whitelist\" classes, methods or fields that should be excluded from the results. Please refer to the Semmle documentation for more information.\n\n\n## Recommendation\nBefore making any changes, confirm that the method is not required by verifying that the only dependencies on the method are from other dead methods. This confirmation is necessary because there may be project-specific frameworks or techniques which can introduce hidden dependencies. If this project is for a library, then consider whether the method is part of the external API, and may be used in external projects that are not included in the snapshot.\n\nAfter confirming that the method is not required, remove the method. You will also need to remove any references to this method, which may, in turn, require removing other unused classes, methods and fields (see Example 1).\n\nIf the result is a static initializer, then all `static { ... }` blocks and initializers on static fields are dead within that class. In addition, the lack of static initialization implies that all static methods and fields are also dead and can be removed. These methods and fields will also be reported separately. In contrast, static nested classes may still be live, because constructing or accessing the nested static class does not trigger static initialization of the outer class.\n\nIf the result is an instance initializer, then all instance initializer `{ ... }` blocks and initializers on instance fields are dead. In addition, the lack of instance initialization implies that the class is never constructed, which means that all instance methods and fields are also dead and can be removed. These methods and fields will also be reported separately.\n\nIf you observe a large number of false positives, you may need to add extra entry points to identify hidden dependencies caused by the use of a particular framework or technique, or to identify library project entry points. Please refer to the Semmle documentation for more information on how to do this.\n\n\n## Example 1\nIn the following example, we have a number of methods, and an \"entry point\" in the form of a main method.\n\n\n```java\npublic static void main(String[] args) {\n\t// Only call the live method\n\tliveMethod();\n}\n\n/** This method is live because it is called by main(..) */\npublic static void liveMethod() {\n\totherLiveMethod()\n}\n\n/** This method is live because it is called by a live method */\npublic static void otherLiveMethod() {\n}\n\n\n/** This method is dead because it is never called */\npublic static void deadMethod() {\n\totherDeadMethod();\n}\n\n/** This method is dead because it is only called by dead methods */\npublic static void otherDeadMethod() {\n}\n```\nThe method `liveMethod` is called from the main method, and is therefore considered live. `liveMethod` calls `otherLiveMethod`, which also makes that live.\n\nIn contrast, `deadMethod` is never called, and does not represent an entry point, so is marked as dead. Likewise, `otherDeadMethod` is only called from the `deadMethod`, so is also marked as dead.\n\n\n## Example 2\nIn this example, we have a test class containing a number of methods.\n\n\n```java\npublic class TestClass {\n\n\t@Before\n\tpublic void setUp() {\n\t\t// ...\n\t}\n\n\t@Test\n\tpublic void testCustomer() {\n\t\t// ...\n\t}\n}\n```\nIn this case, no methods are called directly. However, the annotations on the methods indicate that this is a test class - specifically, JUnit - and that the methods will be called by the test framework when running the tests. `testCustomer` and `setUp` are therefore considered to be \"live\".\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/dead-function",
                    "name": "java/dead-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/DeadMethod.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dead method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a method or constructor that has been marked as deprecated may be dangerous or fail to take advantage of a better method or constructor."
                    },
                    "help": {
                      "markdown": "# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n",
                      "text": "# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n"
                    },
                    "id": "java/deprecated-call",
                    "name": "java/deprecated-call",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Deprecated%20Code/AvoidDeprecatedCallableAccess.ql",
                      "tags": [
                        "external/cwe/cwe-477",
                        "maintainability",
                        "non-attributable"
                      ]
                    },
                    "shortDescription": {
                      "text": "Deprecated method or constructor invocation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Casting 'this' to a derived type introduces a dependency cycle between the type of 'this' and the target type."
                    },
                    "help": {
                      "markdown": "# Dubious downcast of 'this'\nDowncasting `this` to a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, abstract classes may require every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by coercing the type of `this` to a derived type.\n\n\n```java\npublic class DubiousDowncastOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\n\t\t\t\tthis.d = (Derived)this;\t\t// violation\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n",
                      "text": "# Dubious downcast of 'this'\nDowncasting `this` to a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, abstract classes may require every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by coercing the type of `this` to a derived type.\n\n\n```java\npublic class DubiousDowncastOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\n\t\t\t\tthis.d = (Derived)this;\t\t// violation\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n"
                    },
                    "id": "java/downcast-of-this",
                    "name": "java/downcast-of-this",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/DubiousDowncastOfThis.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dubious downcast of 'this'"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Duplicated anonymous classes indicate that refactoring is necessary."
                    },
                    "help": {
                      "markdown": "# Duplicate anonymous class\nAnonymous classes are a common way of creating implementations of an interface or abstract class whose functionality is really only needed once. Duplicating the definition of an anonymous class in several places is usually a sign that refactoring is necessary.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nIntroduce a concrete class that contains the definition just once, and replace the anonymous classes with instances of this concrete class.\n\n\n## Example\nIn the following example, the definition of the class `addActionListener` is duplicated for each button that needs to use it. A better solution is shown that defines just one class, `MultiplexingListener`, which is used by each button.\n\n\n```java\n// BAD: Duplicate anonymous classes:\nbutton1.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\nbutton2.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\n// ... and so on.\n\n// GOOD: Better solution:\nclass MultiplexingListener implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        for (ActionListener listener : listeners)\n            listener.actionPerformed(e);\n    }\n}\n\nbutton1.addActionListener(new MultiplexingListener());\nbutton2.addActionListener(new MultiplexingListener());\n// ... and so on.\n\n```\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Duplicate anonymous class\nAnonymous classes are a common way of creating implementations of an interface or abstract class whose functionality is really only needed once. Duplicating the definition of an anonymous class in several places is usually a sign that refactoring is necessary.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nIntroduce a concrete class that contains the definition just once, and replace the anonymous classes with instances of this concrete class.\n\n\n## Example\nIn the following example, the definition of the class `addActionListener` is duplicated for each button that needs to use it. A better solution is shown that defines just one class, `MultiplexingListener`, which is used by each button.\n\n\n```java\n// BAD: Duplicate anonymous classes:\nbutton1.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\nbutton2.addActionListener(new ActionListener() {\n    public void actionPerfored(ActionEvent e)\n    {\n        for (ActionListener listener: listeners)\n            listeners.actionPerformed(e);\n    }\n});\n\n// ... and so on.\n\n// GOOD: Better solution:\nclass MultiplexingListener implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        for (ActionListener listener : listeners)\n            listener.actionPerformed(e);\n    }\n}\n\nbutton1.addActionListener(new MultiplexingListener());\nbutton2.addActionListener(new MultiplexingListener());\n// ... and so on.\n\n```\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-anonymous-class",
                    "name": "java/duplicate-anonymous-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/DuplicateAnonymous.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Duplicate anonymous class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Classes in which most of the methods are duplicated in another class make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate class\nWhen most of the methods in one class are duplicated in one or more other classes, the classes themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated classes are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many methods between two classes, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two classes serve different purposes but many of their methods are duplicated, this indicates that there is a missing level of abstraction. Introducing a common super-class to define the common methods is likely to prevent many problems in the long term. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n* If the two classes serve the same purpose and are different only as a result of inconsistent updates then treat the classes as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate class\nWhen most of the methods in one class are duplicated in one or more other classes, the classes themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated classes are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many methods between two classes, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two classes serve different purposes but many of their methods are duplicated, this indicates that there is a missing level of abstraction. Introducing a common super-class to define the common methods is likely to prevent many problems in the long term. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n* If the two classes serve the same purpose and are different only as a result of inconsistent updates then treat the classes as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-class",
                    "name": "java/duplicate-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateClass.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Files in which most of the lines are duplicated in another file make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate file\nWhen most of the lines in one file are duplicated in one or more other files, the files themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated files are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them. A common exception is generated code that simply occurs in several places in the source tree.\n\nIt is more common to see duplication of many lines between two files, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two files serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways to share the functionality, either by extracting a utility class for parts of it or by encapsulating the common parts into a new super class of any classes involved.\n* If the two files serve the same purpose and are different only as a result of inconsistent updates then treat the files as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate file\nWhen most of the lines in one file are duplicated in one or more other files, the files themselves are regarded as *mostly duplicate*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated files are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them. A common exception is generated code that simply occurs in several places in the source tree.\n\nIt is more common to see duplication of many lines between two files, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies:\n\n* If the two files serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways to share the functionality, either by extracting a utility class for parts of it or by encapsulating the common parts into a new super class of any classes involved.\n* If the two files serve the same purpose and are different only as a result of inconsistent updates then treat the files as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-file",
                    "name": "java/duplicate-file",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateFile.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Duplicated methods make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Duplicate method\nA method should never be duplicated exactly in several places in the code. The severity of this problem is higher for longer methods than for extremely short methods of one or two statements, but there are usually better ways of achieving the same effect.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAt its simplest, the duplication can be addressed by simply removing all but one of the duplicate method definitions, and changing calls to the removed methods so that they call the remaining function instead.\n\nThis may not be possible because of visibility or accessibility. A common example is where two classes implement the same functionality but neither is a subtype of the other, so it is not possible to inherit a single method definition. In such cases, introducing a common superclass to share the duplicated code is a possible option. Alternatively, if the methods do not need access to private object state, they can be moved to a shared utility class that just provides the functionality itself.\n\n\n## Example\nIn the following example, `RowWidget` and `ColumnWidget` contain duplicate methods. The `collectChildren` method should probably be moved into the superclass, `Widget`, and shared between `RowWidget` and `ColumnWidget`.\n\n\n```java\nclass RowWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ColumnWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n```\nAlternatively, if not all kinds of `Widget` actually need `collectChildren` (for example, not all of them have children), it might be necessary to introduce a new, possibly abstract, class under `Widget`. For example, the new class might be called `ContainerWidget` and include a single definition of `collectChildren`. Both `RowWidget` and `ColumnWidget` could extend the class and inherit `collectChildren`.\n\nModern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Duplicate method\nA method should never be duplicated exactly in several places in the code. The severity of this problem is higher for longer methods than for extremely short methods of one or two statements, but there are usually better ways of achieving the same effect.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAt its simplest, the duplication can be addressed by simply removing all but one of the duplicate method definitions, and changing calls to the removed methods so that they call the remaining function instead.\n\nThis may not be possible because of visibility or accessibility. A common example is where two classes implement the same functionality but neither is a subtype of the other, so it is not possible to inherit a single method definition. In such cases, introducing a common superclass to share the duplicated code is a possible option. Alternatively, if the methods do not need access to private object state, they can be moved to a shared utility class that just provides the functionality itself.\n\n\n## Example\nIn the following example, `RowWidget` and `ColumnWidget` contain duplicate methods. The `collectChildren` method should probably be moved into the superclass, `Widget`, and shared between `RowWidget` and `ColumnWidget`.\n\n\n```java\nclass RowWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ColumnWidget extends Widget {\n\t// ...\n\tpublic void collectChildren(Set<Widget> result) {\n\t\tfor (Widget child : this.children) {\n\t\t\tif (child.isVisible()) {\n\t\t\t\tresult.add(children);\n\t\t\t\tchild.collectChildren(result);\n\t\t\t}\n\t\t}\n\t}\n}\n```\nAlternatively, if not all kinds of `Widget` actually need `collectChildren` (for example, not all of them have children), it might be necessary to introduce a new, possibly abstract, class under `Widget`. For example, the new class might be called `ContainerWidget` and include a single definition of `collectChildren`. Both `RowWidget` and `ColumnWidget` could extend the class and inherit `collectChildren`.\n\nModern IDEs may provide refactoring support for this sort of issue, usually with the names \"Pull up\" or \"Extract supertype\".\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/duplicate-method",
                    "name": "java/duplicate-method",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/DuplicateMethod.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Duplicate method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Querying the contents of a collection or map that is never initialized is not normally useful."
                    },
                    "help": {
                      "markdown": "# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/empty-container",
                    "name": "java/empty-container",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Collections/ReadOnlyContainer.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "reliability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Container contents are never initialized"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An empty statement hinders readability."
                    },
                    "help": {
                      "markdown": "# Empty statement\nAn *empty statement* is a single semicolon `;` that does not terminate another statement. Such a statement hinders readability and has no effect on its own.\n\n\n## Recommendation\nAvoid empty statements. If a loop is intended to have an empty body, it is better to mark that fact explicitly by using a pair of braces `{}` containing an explanatory comment for the body, rather than a single semicolon.\n\n\n## Example\nIn the following example, there is an empty statement on line 3, where an additional semicolon is used. On line 6, the `for` statement has an empty body because the condition is immediately followed by a semicolon. In this case, it is better to include a pair of braces `{}` containing an explanatory comment for the body instead.\n\n\n```java\npublic class Cart {\n\t// AVOID: Empty statement\n\tList<Item> items = new ArrayList<Cart>();;\n\tpublic void applyDiscount(float discount) {\n\t\t// AVOID: Empty statement as loop body\n\t\tfor (int i = 0; i < items.size(); items.get(i++).applyDiscount(discount));\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n",
                      "text": "# Empty statement\nAn *empty statement* is a single semicolon `;` that does not terminate another statement. Such a statement hinders readability and has no effect on its own.\n\n\n## Recommendation\nAvoid empty statements. If a loop is intended to have an empty body, it is better to mark that fact explicitly by using a pair of braces `{}` containing an explanatory comment for the body, rather than a single semicolon.\n\n\n## Example\nIn the following example, there is an empty statement on line 3, where an additional semicolon is used. On line 6, the `for` statement has an empty body because the condition is immediately followed by a semicolon. In this case, it is better to include a pair of braces `{}` containing an explanatory comment for the body instead.\n\n\n```java\npublic class Cart {\n\t// AVOID: Empty statement\n\tList<Item> items = new ArrayList<Cart>();;\n\tpublic void applyDiscount(float discount) {\n\t\t// AVOID: Empty statement as loop body\n\t\tfor (int i = 0; i < items.size(); items.get(i++).applyDiscount(discount));\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"
                    },
                    "id": "java/empty-statement",
                    "name": "java/empty-statement",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/EmptyStatement.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Empty statement"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'equal' may be intended to be named 'equals'."
                    },
                    "help": {
                      "markdown": "# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n",
                      "text": "# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"
                    },
                    "id": "java/equals-typo",
                    "name": "java/equals-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/EqualsTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in equals"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An expression that always evaluates to the same value, but which has a non-constant subexpression, indicates a mistake."
                    },
                    "help": {
                      "markdown": "# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n",
                      "text": "# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n"
                    },
                    "id": "java/evaluation-to-constant",
                    "name": "java/evaluation-to-constant",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/ConstantExpAppearsNonConstant.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Expression always evaluates to the same value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that uses more methods or variables from another (unrelated) class than from its own class violates the principle of putting data and behavior in the same place."
                    },
                    "help": {
                      "markdown": "# Feature envy\n*Feature envy* refers to situations where a method is \"in the wrong place\", because it does not use many methods or variables of its own class, but uses a whole range of methods or variables from some other class. This violates the principle of putting data and behavior in the same place, and exposes internals of the other class to the method.\n\n\n## Recommendation\nFor each method that may exhibit feature envy, see if it needs to be declared in its present location, or if you can move it to the class it is \"envious\" of. A common example is a method that calls a large number of getters on another class to perform a calculation that does not rely on anything from its own class. In such cases, you should move the method to the class containing the data. If the calculation depends on some values from the method's current class, they can either be passed as arguments or accessed using getters from the other class.\n\nIf it is inappropriate to move the entire method, see if all the dependencies on the other class are concentrated in just one part of the method. If so, you can move them into a method of their own. You can then move this method to the other class and call it from the original method.\n\nIf a class is envious of functionality defined in a superclass, perhaps the superclass needs to be rewritten to become more extensible and allow its subtypes to define new behavior without them depending so deeply on the superclass's implementation. The *template method* pattern may be useful in achieving this.\n\nModern IDEs provide several refactorings that may be useful in addressing instances of feature envy, typically under the names of \"Move method\" and \"Extract method\".\n\nOccasionally, behavior can be misinterpreted as feature envy when in fact it is justified. The most common examples are complex design patterns like *visitor* or *strategy*, where the goal is to separate data from behavior.\n\n\n## Example\nIn the following example, initially the method `getTotalPrice` is in the `Basket` class, but it only uses data belonging to the `Item` class. Therefore, it represents an instance of feature envy. To refactor it, `getTotalPrice` can be moved to `Item` and its parameter can be removed. The resulting code is easier to understand and keep consistent.\n\n\n```java\n// Before refactoring:\nclass Item { .. }\nclass Basket {\n\t// ..\n\tfloat getTotalPrice(Item i) {\n\t\tfloat price = i.getPrice() + i.getTax();\n\t\tif (i.isOnSale())\n\t\t\tprice = price - i.getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n\n// After refactoring:\nclass Item {\n\t// ..\n\tfloat getTotalPrice() {\n\t\tfloat price = getPrice() + getTax();\n\t\tif (isOnSale())\n\t\t\tprice = price - getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n```\nThe refactored code is still appropriate, even if some data from the `Basket` class is necessary for the computation of the total price. For example, if the `Basket` class applies a bulk discount when a sufficient number of items are in the basket, an \"additional discount\" parameter can be added to `Item.getTotalPrice(..)`. Alternatively, the application of the discount can be performed in a method in `Basket` that calls `Item.getTotalPrice`.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 93&ndash;94. Addison-Wesley Professional, 2004.\n",
                      "text": "# Feature envy\n*Feature envy* refers to situations where a method is \"in the wrong place\", because it does not use many methods or variables of its own class, but uses a whole range of methods or variables from some other class. This violates the principle of putting data and behavior in the same place, and exposes internals of the other class to the method.\n\n\n## Recommendation\nFor each method that may exhibit feature envy, see if it needs to be declared in its present location, or if you can move it to the class it is \"envious\" of. A common example is a method that calls a large number of getters on another class to perform a calculation that does not rely on anything from its own class. In such cases, you should move the method to the class containing the data. If the calculation depends on some values from the method's current class, they can either be passed as arguments or accessed using getters from the other class.\n\nIf it is inappropriate to move the entire method, see if all the dependencies on the other class are concentrated in just one part of the method. If so, you can move them into a method of their own. You can then move this method to the other class and call it from the original method.\n\nIf a class is envious of functionality defined in a superclass, perhaps the superclass needs to be rewritten to become more extensible and allow its subtypes to define new behavior without them depending so deeply on the superclass's implementation. The *template method* pattern may be useful in achieving this.\n\nModern IDEs provide several refactorings that may be useful in addressing instances of feature envy, typically under the names of \"Move method\" and \"Extract method\".\n\nOccasionally, behavior can be misinterpreted as feature envy when in fact it is justified. The most common examples are complex design patterns like *visitor* or *strategy*, where the goal is to separate data from behavior.\n\n\n## Example\nIn the following example, initially the method `getTotalPrice` is in the `Basket` class, but it only uses data belonging to the `Item` class. Therefore, it represents an instance of feature envy. To refactor it, `getTotalPrice` can be moved to `Item` and its parameter can be removed. The resulting code is easier to understand and keep consistent.\n\n\n```java\n// Before refactoring:\nclass Item { .. }\nclass Basket {\n\t// ..\n\tfloat getTotalPrice(Item i) {\n\t\tfloat price = i.getPrice() + i.getTax();\n\t\tif (i.isOnSale())\n\t\t\tprice = price - i.getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n\n// After refactoring:\nclass Item {\n\t// ..\n\tfloat getTotalPrice() {\n\t\tfloat price = getPrice() + getTax();\n\t\tif (isOnSale())\n\t\t\tprice = price - getSaleDiscount() * price;\n\t\treturn price;\n\t}\n}\n```\nThe refactored code is still appropriate, even if some data from the `Basket` class is necessary for the computation of the total price. For example, if the `Basket` class applies a bulk discount when a sufficient number of items are in the basket, an \"additional discount\" parameter can be added to `Item.getTotalPrice(..)`. Alternatively, the application of the discount can be performed in a method in `Basket` that calls `Item.getTotalPrice`.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*, pp. 93&ndash;94. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/feature-envy",
                    "name": "java/feature-envy",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/FeatureEnvy.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Feature envy"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Hiding a field in a superclass by redeclaring it in a subclass might be unintentional, especially if references to the hidden field are not qualified using 'super'."
                    },
                    "help": {
                      "markdown": "# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n",
                      "text": "# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n"
                    },
                    "id": "java/field-masks-super-field",
                    "name": "java/field-masks-super-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/FieldMasksSuperField.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Field masks field in super class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Setting fields to 'null' in a finalizer does not cause the object to be collected by the garbage collector any earlier, and may adversely affect performance."
                    },
                    "help": {
                      "markdown": "# Finalizer nulls fields\nA finalizer does not need to set an object's fields to `null` to help the garbage collector. At the point in the Java object life-cycle when the `finalize` method is called, the object is no longer reachable from the garbage collection roots. Explicitly setting the object's fields to `null` does not cause the referenced objects to be collected by the garbage collector any earlier, and may even adversely affect performance.\n\nThe life-cycle of a Java object has 7 stages:\n\n* **Created** : Memory is allocated for the object and the initializers and constructors have been run.\n* **In use** : The object is reachable through a chain of strong references from a garbage collection root. A garbage collection root is a special class of variable (which includes variables on the stack of any thread, static variables of any class, and references from Java Native Interface code).\n* **Invisible** : The object has already gone out of scope, but the stack frame of the method that contained the scope is still in memory. Not all objects transition into this state.\n* **Unreachable** : The object is no longer reachable through a chain of strong references. It becomes a candidate for garbage collection.\n* **Collected** : The garbage collector has identified that the object can be deallocated. If it has a finalizer, it is marked for finalization. Otherwise, it is deallocated.\n* **Finalized** : An object with a `finalize` method transitions to this state after the finalize method is completed and the object still remains unreachable.\n* **Deallocated** : The object is a candidate for deallocation.\nThe call to the `finalize` method occurs when the object is in the 'Collected' stage. At that point, it is already unreachable from the garbage collection roots so any of its references to other objects no longer contribute to their reference counts.\n\n\n## Recommendation\nEnsure that the finalizer does not contain any `null` assignments because they are unlikely to help garbage collection.\n\nIf a finalizer does nothing but nullify an object's fields, it is best to completely remove the finalizer. Objects with finalizers severely affect performance, and you should avoid defining `finalize` where possible.\n\n\n## Example\nIn the following example, `finalize` unnecessarily assigns the object's fields to null.\n\n\n```java\nclass FinalizedClass {\n\tObject o = new Object();\n\tString s = \"abcdefg\";\n\tInteger i = Integer.valueOf(2);\n\t\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\t\t//No need to nullify fields\n\t\tthis.o = null;\n\t\tthis.s = null;\n\t\tthis.i = null;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* IBM developerWorks: [Java theory and practice: Explicit nulling](https://web.archive.org/web/20201111184342/https://www.ibm.com/developerworks/java/library/j-jtp01274/index.html#3.2).\n* Oracle Technology Network: [ How to Handle Java Finalization's Memory-Retention Issues ](https://www.oracle.com/technical-resources/articles/javase/finalization.html).\n* S. Wilson and J. Kesselman, *Java Platform Performance: Strategies and Tactics, 1st ed.*, Appendix A. Prentice Hall, 2001.\n",
                      "text": "# Finalizer nulls fields\nA finalizer does not need to set an object's fields to `null` to help the garbage collector. At the point in the Java object life-cycle when the `finalize` method is called, the object is no longer reachable from the garbage collection roots. Explicitly setting the object's fields to `null` does not cause the referenced objects to be collected by the garbage collector any earlier, and may even adversely affect performance.\n\nThe life-cycle of a Java object has 7 stages:\n\n* **Created** : Memory is allocated for the object and the initializers and constructors have been run.\n* **In use** : The object is reachable through a chain of strong references from a garbage collection root. A garbage collection root is a special class of variable (which includes variables on the stack of any thread, static variables of any class, and references from Java Native Interface code).\n* **Invisible** : The object has already gone out of scope, but the stack frame of the method that contained the scope is still in memory. Not all objects transition into this state.\n* **Unreachable** : The object is no longer reachable through a chain of strong references. It becomes a candidate for garbage collection.\n* **Collected** : The garbage collector has identified that the object can be deallocated. If it has a finalizer, it is marked for finalization. Otherwise, it is deallocated.\n* **Finalized** : An object with a `finalize` method transitions to this state after the finalize method is completed and the object still remains unreachable.\n* **Deallocated** : The object is a candidate for deallocation.\nThe call to the `finalize` method occurs when the object is in the 'Collected' stage. At that point, it is already unreachable from the garbage collection roots so any of its references to other objects no longer contribute to their reference counts.\n\n\n## Recommendation\nEnsure that the finalizer does not contain any `null` assignments because they are unlikely to help garbage collection.\n\nIf a finalizer does nothing but nullify an object's fields, it is best to completely remove the finalizer. Objects with finalizers severely affect performance, and you should avoid defining `finalize` where possible.\n\n\n## Example\nIn the following example, `finalize` unnecessarily assigns the object's fields to null.\n\n\n```java\nclass FinalizedClass {\n\tObject o = new Object();\n\tString s = \"abcdefg\";\n\tInteger i = Integer.valueOf(2);\n\t\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\t\t//No need to nullify fields\n\t\tthis.o = null;\n\t\tthis.s = null;\n\t\tthis.i = null;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* IBM developerWorks: [Java theory and practice: Explicit nulling](https://web.archive.org/web/20201111184342/https://www.ibm.com/developerworks/java/library/j-jtp01274/index.html#3.2).\n* Oracle Technology Network: [ How to Handle Java Finalization's Memory-Retention Issues ](https://www.oracle.com/technical-resources/articles/javase/finalization.html).\n* S. Wilson and J. Kesselman, *Java Platform Performance: Strategies and Tactics, 1st ed.*, Appendix A. Prentice Hall, 2001.\n"
                    },
                    "id": "java/finalizer-nulls-fields",
                    "name": "java/finalizer-nulls-fields",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/FinalizerNullsFields.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Finalizer nulls fields"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Triggering garbage collection explicitly may either have no effect or may trigger unnecessary garbage collection."
                    },
                    "help": {
                      "markdown": "# Explicit garbage collection\nYou should avoid making calls to explicit garbage collection methods (`Runtime.gc` and `System.gc`). The calls are not guaranteed to trigger garbage collection, and they may also trigger unnecessary garbage collection passes that lead to decreased performance.\n\n\n## Recommendation\nIt is better to let the Java Virtual Machine (JVM) handle garbage collection. If it becomes necessary to control how the JVM handles memory, it is better to use the JVM's memory and garbage collection options (for example, `-Xmx`, `-XX:NewRatio`, `-XX:Use*GC`) than to trigger garbage collection in the application.\n\nThe memory management classes that are used by Real-Time Java are an exception to this rule, because they are designed to handle garbage collection differently from the JVM default.\n\n\n## Example\nThe following example shows code that makes connection requests, and tries to trigger garbage collection after it has processed each request.\n\n\n```java\nclass RequestHandler extends Thread {\n\tprivate boolean isRunning;\n\tprivate Connection conn = new Connection();\n\t\n\tpublic void run() {\n\t\twhile (isRunning) {\n\t\t\tRequest req = conn.getRequest();\n\t\t\t// Process the request ...\n\t\t\t\n\t\t\tSystem.gc();  // This call may cause a garbage collection after each request.\n\t\t\t\t\t\t  // This will likely reduce the throughput of the RequestHandler\n\t\t\t\t\t\t  // because the JVM spends time on unnecessary garbage collection passes.\n\t\t}\n\t}\n}\n```\nIt is better to remove the call to `System.gc` and rely on the JVM to dispose of the connection.\n\n\n## References\n* Java API Specification: [System.gc()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#gc()).\n* Java Documentation: [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html).\n",
                      "text": "# Explicit garbage collection\nYou should avoid making calls to explicit garbage collection methods (`Runtime.gc` and `System.gc`). The calls are not guaranteed to trigger garbage collection, and they may also trigger unnecessary garbage collection passes that lead to decreased performance.\n\n\n## Recommendation\nIt is better to let the Java Virtual Machine (JVM) handle garbage collection. If it becomes necessary to control how the JVM handles memory, it is better to use the JVM's memory and garbage collection options (for example, `-Xmx`, `-XX:NewRatio`, `-XX:Use*GC`) than to trigger garbage collection in the application.\n\nThe memory management classes that are used by Real-Time Java are an exception to this rule, because they are designed to handle garbage collection differently from the JVM default.\n\n\n## Example\nThe following example shows code that makes connection requests, and tries to trigger garbage collection after it has processed each request.\n\n\n```java\nclass RequestHandler extends Thread {\n\tprivate boolean isRunning;\n\tprivate Connection conn = new Connection();\n\t\n\tpublic void run() {\n\t\twhile (isRunning) {\n\t\t\tRequest req = conn.getRequest();\n\t\t\t// Process the request ...\n\t\t\t\n\t\t\tSystem.gc();  // This call may cause a garbage collection after each request.\n\t\t\t\t\t\t  // This will likely reduce the throughput of the RequestHandler\n\t\t\t\t\t\t  // because the JVM spends time on unnecessary garbage collection passes.\n\t\t}\n\t}\n}\n```\nIt is better to remove the call to `System.gc` and rely on the JVM to dispose of the connection.\n\n\n## References\n* Java API Specification: [System.gc()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#gc()).\n* Java Documentation: [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html).\n"
                    },
                    "id": "java/garbage-collection",
                    "name": "java/garbage-collection",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/GarbageCollection.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Explicit garbage collection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'hashcode' may be intended to be named 'hashCode'."
                    },
                    "help": {
                      "markdown": "# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n",
                      "text": "# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"
                    },
                    "id": "java/hashcode-typo",
                    "name": "java/hashcode-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/HashCodeTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in hashCode"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Hub classes, which are classes that use, and are used by, many other classes, are complex and difficult to change without affecting the rest of the system."
                    },
                    "help": {
                      "markdown": "# Hub classes\nA *hub class* is a class that depends on many other classes, and on which many other classes depend.\n\nFor the purposes of this rule, a *dependency* is any use of one class in another. Examples include:\n\n* Using another class as the declared type of a variable or field\n* Using another class as an argument type for a method\n* Using another class as a superclass in the `extends` declaration\n* Calling a method defined in the class\nA class can be regarded as a hub class when both the incoming dependencies and the outgoing source dependencies are particularly high. (Outgoing source dependencies are dependencies on other source classes, rather than library classes like `java.lang.Object`.)\n\nIt is undesirable to have many hub classes because they are extremely difficult to maintain. This is because many other classes depend on a hub class, and so the other classes have to be tested and possibly adapted after each change to the hub class. Also, when one of a hub class's direct dependencies changes, the behavior of the hub class and all of its dependencies has to be checked and possibly adapted.\n\n\n## Recommendation\nOne common reason for a class to be regarded as a hub class is that it tries to do too much, including unrelated functionality that depends on different parts of the code base. If possible, split such classes into several better encapsulated classes.\n\nAnother common reason is that the class is a \"struct-like\" class that has many fields of different types. Introducing some intermediate grouping containers to make it clearer what fields belong together may be a good option.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n",
                      "text": "# Hub classes\nA *hub class* is a class that depends on many other classes, and on which many other classes depend.\n\nFor the purposes of this rule, a *dependency* is any use of one class in another. Examples include:\n\n* Using another class as the declared type of a variable or field\n* Using another class as an argument type for a method\n* Using another class as a superclass in the `extends` declaration\n* Calling a method defined in the class\nA class can be regarded as a hub class when both the incoming dependencies and the outgoing source dependencies are particularly high. (Outgoing source dependencies are dependencies on other source classes, rather than library classes like `java.lang.Object`.)\n\nIt is undesirable to have many hub classes because they are extremely difficult to maintain. This is because many other classes depend on a hub class, and so the other classes have to be tested and possibly adapted after each change to the hub class. Also, when one of a hub class's direct dependencies changes, the behavior of the hub class and all of its dependencies has to be checked and possibly adapted.\n\n\n## Recommendation\nOne common reason for a class to be regarded as a hub class is that it tries to do too much, including unrelated functionality that depends on different parts of the code base. If possible, split such classes into several better encapsulated classes.\n\nAnother common reason is that the class is a \"struct-like\" class that has many fields of different types. Introducing some intermediate grouping containers to make it clearer what fields belong together may be a good option.\n\n\n## References\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1995.\n* W. C. Wake, *Refactoring Workbook*. Addison-Wesley Professional, 2004.\n"
                    },
                    "id": "java/hub-class",
                    "name": "java/hub-class",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Refactoring%20Opportunities/HubClasses.ql",
                      "tags": [
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Hub classes"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An implicit import obscures the dependencies of a file and may cause confusing compile-time errors."
                    },
                    "help": {
                      "markdown": "# Implicit import\nImports can be categorized as *explicit* (for example `import java.util.List;`) or *implicit* (also known as 'on-demand', for example `import java.util.*;`):\n\n* Implicit imports give access to all visible types in the type (or package) that precedes the \".\\*\"; types imported in this way never shadow other types.\n* Explicit imports give access to just the named type; they can shadow other types that would normally be visible through an implicit import, or through the normal package visibility rules.\nIt is often considered bad practice to use implicit imports. The only advantage to doing so is making the code more concise, and there are a number of disadvantages:\n\n* The exact dependencies of a file are not visible at a glance.\n* Confusing compile-time errors can be introduced if a type name is used that could originate from several implicit imports.\n\n## Recommendation\nFor readability, it is recommended to use explicit imports instead of implicit imports. Many modern IDEs provide automatic functionality to help achieve this, typically under the name \"Organize imports\". They can also fold away the import declarations, and automatically manage imports: adding them when a particular type is auto-completed by the editor, and removing them when they are not necessary. This functionality makes implicit imports mainly redundant.\n\n\n## Example\nThe following example uses implicit imports. This means that it is not clear to a programmer where the `List` type on line 5 is imported from.\n\n\n```java\nimport java.util.*;  // AVOID: Implicit import statements\nimport java.awt.*;\n\npublic class Customers {\n\tpublic List getCustomers() {  // Compiler error: 'List' is ambiguous.\n\t\t...\n\t}\n}\n```\nTo improve readability, the implicit imports should be replaced by explicit imports. For example, `import java.util.*;` should be replaced by `import java.util.List;` on line 1.\n\n\n## References\n* Java Language Specification: [6.4.1 Shadowing](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4.1), [7.5.2 Type-Import-on-Demand Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.5.2).\n",
                      "text": "# Implicit import\nImports can be categorized as *explicit* (for example `import java.util.List;`) or *implicit* (also known as 'on-demand', for example `import java.util.*;`):\n\n* Implicit imports give access to all visible types in the type (or package) that precedes the \".\\*\"; types imported in this way never shadow other types.\n* Explicit imports give access to just the named type; they can shadow other types that would normally be visible through an implicit import, or through the normal package visibility rules.\nIt is often considered bad practice to use implicit imports. The only advantage to doing so is making the code more concise, and there are a number of disadvantages:\n\n* The exact dependencies of a file are not visible at a glance.\n* Confusing compile-time errors can be introduced if a type name is used that could originate from several implicit imports.\n\n## Recommendation\nFor readability, it is recommended to use explicit imports instead of implicit imports. Many modern IDEs provide automatic functionality to help achieve this, typically under the name \"Organize imports\". They can also fold away the import declarations, and automatically manage imports: adding them when a particular type is auto-completed by the editor, and removing them when they are not necessary. This functionality makes implicit imports mainly redundant.\n\n\n## Example\nThe following example uses implicit imports. This means that it is not clear to a programmer where the `List` type on line 5 is imported from.\n\n\n```java\nimport java.util.*;  // AVOID: Implicit import statements\nimport java.awt.*;\n\npublic class Customers {\n\tpublic List getCustomers() {  // Compiler error: 'List' is ambiguous.\n\t\t...\n\t}\n}\n```\nTo improve readability, the implicit imports should be replaced by explicit imports. For example, `import java.util.*;` should be replaced by `import java.util.List;` on line 1.\n\n\n## References\n* Java Language Specification: [6.4.1 Shadowing](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4.1), [7.5.2 Type-Import-on-Demand Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.5.2).\n"
                    },
                    "id": "java/implicit-import",
                    "name": "java/implicit-import",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Declarations/MakeImportsExplicit.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Implicit import"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Javadoc that incorrectly claims a method or constructor can throw an exception is misleading."
                    },
                    "help": {
                      "markdown": "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n",
                      "text": "# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n"
                    },
                    "id": "java/inconsistent-javadoc-throws",
                    "name": "java/inconsistent-javadoc-throws",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/ImpossibleJavadocThrows.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Javadoc has impossible 'throws' tag"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A 'serialVersionUID' field that is declared in a serializable class but is of the wrong type cannot be used by the serialization framework."
                    },
                    "help": {
                      "markdown": "# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n",
                      "text": "# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n"
                    },
                    "id": "java/incorrect-serial-version-uid",
                    "name": "java/incorrect-serial-version-uid",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/IncorrectSerialVersionUID.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Incorrect serialVersionUID field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling the constructor of a boxed type is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n",
                      "text": "# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n"
                    },
                    "id": "java/inefficient-boxed-constructor",
                    "name": "java/inefficient-boxed-constructor",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientPrimConstructor.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient primitive constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Checking a string for equality with an empty string is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n",
                      "text": "# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n"
                    },
                    "id": "java/inefficient-empty-string-test",
                    "name": "java/inefficient-empty-string-test",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientEmptyStringTest.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient empty string test"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Iterating through the values of a map using the key set is inefficient."
                    },
                    "help": {
                      "markdown": "# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n",
                      "text": "# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n"
                    },
                    "id": "java/inefficient-key-set-iterator",
                    "name": "java/inefficient-key-set-iterator",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InefficientKeySetIterator.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient use of key set iterator"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using the 'String(String)' constructor is less memory efficient than using the constructor argument directly."
                    },
                    "help": {
                      "markdown": "# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n",
                      "text": "# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n"
                    },
                    "id": "java/inefficient-string-constructor",
                    "name": "java/inefficient-string-constructor",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/NewStringString.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inefficient String constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An object that accidentally exposes its internal representation may allow the object's fields to be modified in ways that the object is not prepared to handle."
                    },
                    "help": {
                      "markdown": "# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n",
                      "text": "# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"
                    },
                    "id": "java/internal-representation-exposure",
                    "name": "java/internal-representation-exposure",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/ExposeRepresentation.ql",
                      "tags": [
                        "external/cwe/cwe-485",
                        "maintainability",
                        "modularity",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Exposing internal representation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Use of unsupported JDK-internal APIs may cause compatibility issues when upgrading to newer versions of Java, in particular Java 9."
                    },
                    "help": {
                      "markdown": "# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n",
                      "text": "# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n"
                    },
                    "id": "java/jdk-internal-api-access",
                    "name": "java/jdk-internal-api-access",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Compatibility/JDK9/JdkInternalAccess.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Access to unsupported JDK-internal API"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A JUnit 3.8 test method that overrides 'tearDown' but does not call 'super.tearDown' may result in subsequent tests failing, or allow the current state to persist and affect subsequent tests."
                    },
                    "help": {
                      "markdown": "# TestCase implements tearDown but doesn't call super.tearDown()\nA JUnit 3.8 test method that overrides a non-empty `tearDown` method should call `super.tearDown` to make sure that the superclass performs its de-initialization routines. Not calling `tearDown` may result in test failures in subsequent tests, or allow the current state to persist and affect any following tests.\n\n\n## Recommendation\nCall `super.tearDown` at the end of the overriding `tearDown` method.\n\n\n## Example\nIn the following example, `TearDownNoSuper.tearDown` does not call `super.tearDown`, which may cause subsequent tests to fail, or allow the internal state to be maintained. However, `TearDownSuper.tearDown` *does* call `super.tearDown`, at the end of the method, to enable `FrameworkTestCase.tearDown` to perform de-initialization.\n\n\n```java\n// Abstract class that initializes then shuts down the\n// framework after each set of tests\nabstract class FrameworkTestCase extends TestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tFramework.init();\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tFramework.shutdown();\n\t}\n}\n\n// The following classes extend 'FrameworkTestCase' to reuse the\n// 'setUp' and 'tearDown' methods of the framework.\n\npublic class TearDownNoSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// BAD: Does not call 'super.tearDown'. May cause later tests to fail\n\t\t// when they try to re-initialize an already initialized framework.\n\t\t// Even if the framework allows re-initialization, it may maintain the\n\t\t// internal state, which could affect the results of succeeding tests.\n\t\tSystem.out.println(\"Tests complete\");\n\t}\n}\n\npublic class TearDownSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// GOOD: Correctly calls 'super.tearDown' to shut down the\n\t\t// framework.\n\t\tSystem.out.println(\"Tests complete\");\n\t\tsuper.tearDown();\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# TestCase implements tearDown but doesn't call super.tearDown()\nA JUnit 3.8 test method that overrides a non-empty `tearDown` method should call `super.tearDown` to make sure that the superclass performs its de-initialization routines. Not calling `tearDown` may result in test failures in subsequent tests, or allow the current state to persist and affect any following tests.\n\n\n## Recommendation\nCall `super.tearDown` at the end of the overriding `tearDown` method.\n\n\n## Example\nIn the following example, `TearDownNoSuper.tearDown` does not call `super.tearDown`, which may cause subsequent tests to fail, or allow the internal state to be maintained. However, `TearDownSuper.tearDown` *does* call `super.tearDown`, at the end of the method, to enable `FrameworkTestCase.tearDown` to perform de-initialization.\n\n\n```java\n// Abstract class that initializes then shuts down the\n// framework after each set of tests\nabstract class FrameworkTestCase extends TestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tFramework.init();\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tFramework.shutdown();\n\t}\n}\n\n// The following classes extend 'FrameworkTestCase' to reuse the\n// 'setUp' and 'tearDown' methods of the framework.\n\npublic class TearDownNoSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// BAD: Does not call 'super.tearDown'. May cause later tests to fail\n\t\t// when they try to re-initialize an already initialized framework.\n\t\t// Even if the framework allows re-initialization, it may maintain the\n\t\t// internal state, which could affect the results of succeeding tests.\n\t\tSystem.out.println(\"Tests complete\");\n\t}\n}\n\npublic class TearDownSuper extends FrameworkTestCase {\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\tpublic void testFramework() {\n\t\t//...\n\t}\n\t\n\tpublic void testFramework2() {\n\t\t//...\n\t}\n\t\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\t// GOOD: Correctly calls 'super.tearDown' to shut down the\n\t\t// framework.\n\t\tSystem.out.println(\"Tests complete\");\n\t\tsuper.tearDown();\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/junit-teardown-without-super",
                    "name": "java/junit-teardown-without-super",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/TearDownNoSuper.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "TestCase implements tearDown but doesn't call super.tearDown()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'System.exit', 'Runtime.halt', or 'Runtime.exit' may make code harder to reuse and prevent important cleanup steps from running."
                    },
                    "help": {
                      "markdown": "# Forcible JVM termination\nCalling one of the methods `System.exit`, `Runtime.halt`, and `Runtime.exit` immediately terminates the Java Virtual Machine (JVM), effectively killing all threads without giving any of them a chance to perform cleanup actions or recover. As such, it is a dangerous thing to do: firstly, it can terminate the entire program inadvertently, and secondly, it can prevent important resources from being released or program state from being written to disk consistently.\n\nIt is sometimes considered acceptable to call `System.exit` from a program's `main` method in order to indicate the overall exit status of the program. Such calls are an exception to this rule.\n\n\n## Recommendation\nIt is usually preferable to use a different mechanism for reporting failure conditions. Consider returning a special value (perhaps `null`) that users of the current method check for and recover from appropriately. Alternatively, throw a suitable exception, which unwinds the stack and allows properly written code to clean up after itself, while leaving other threads undisturbed.\n\n\n## Example\nIn the following example, problem 1 shows that `FileOutput.write` tries to write some data to disk and terminates the JVM if this fails. This leaves the partially-written file on disk without any cleanup code running. It would be better to either return `false` to indicate the failure, or let the `IOException` propagate upwards and be handled by a method that knows how to recover.\n\nProblem 2 is more subtle. In this example, there is just one entry point to the program (the `main` method), which constructs an `Action` and performs it. `Action.run` calls `System.exit` to indicate successful completion. Consider, however, how this code might be integrated in an application server that constructs `Action` instances and calls `run` on them without going through `main`. The fact that `run` terminates the JVM instead of returning its exit code as an integer makes that use-case impossible.\n\n\n```java\n// Problem 1: Miss out cleanup code \nclass FileOutput {\n    boolean write(String[] s) {\n        try {\n            output.write(s.getBytes());\n        } catch (IOException e) {\n            System.exit(1);\n        }\n        return true;\n    }\n}\n\n// Problem 2: Make code reuse difficult\nclass Action {\n    public void run() {\n        // ...\n        // Perform tasks ...\n        // ...\n        System.exit(0);\n    }\n    public static void main(String[] args) {\n        new Action(args).run();\n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 232. Addison-Wesley, 2008.\n* Java API Specification: [System.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#exit(int)), [Runtime.halt(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#halt(int)), [Runtime.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#exit(int)).\n* Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).\n",
                      "text": "# Forcible JVM termination\nCalling one of the methods `System.exit`, `Runtime.halt`, and `Runtime.exit` immediately terminates the Java Virtual Machine (JVM), effectively killing all threads without giving any of them a chance to perform cleanup actions or recover. As such, it is a dangerous thing to do: firstly, it can terminate the entire program inadvertently, and secondly, it can prevent important resources from being released or program state from being written to disk consistently.\n\nIt is sometimes considered acceptable to call `System.exit` from a program's `main` method in order to indicate the overall exit status of the program. Such calls are an exception to this rule.\n\n\n## Recommendation\nIt is usually preferable to use a different mechanism for reporting failure conditions. Consider returning a special value (perhaps `null`) that users of the current method check for and recover from appropriately. Alternatively, throw a suitable exception, which unwinds the stack and allows properly written code to clean up after itself, while leaving other threads undisturbed.\n\n\n## Example\nIn the following example, problem 1 shows that `FileOutput.write` tries to write some data to disk and terminates the JVM if this fails. This leaves the partially-written file on disk without any cleanup code running. It would be better to either return `false` to indicate the failure, or let the `IOException` propagate upwards and be handled by a method that knows how to recover.\n\nProblem 2 is more subtle. In this example, there is just one entry point to the program (the `main` method), which constructs an `Action` and performs it. `Action.run` calls `System.exit` to indicate successful completion. Consider, however, how this code might be integrated in an application server that constructs `Action` instances and calls `run` on them without going through `main`. The fact that `run` terminates the JVM instead of returning its exit code as an integer makes that use-case impossible.\n\n\n```java\n// Problem 1: Miss out cleanup code \nclass FileOutput {\n    boolean write(String[] s) {\n        try {\n            output.write(s.getBytes());\n        } catch (IOException e) {\n            System.exit(1);\n        }\n        return true;\n    }\n}\n\n// Problem 2: Make code reuse difficult\nclass Action {\n    public void run() {\n        // ...\n        // Perform tasks ...\n        // ...\n        System.exit(0);\n    }\n    public static void main(String[] args) {\n        new Action(args).run();\n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 232. Addison-Wesley, 2008.\n* Java API Specification: [System.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#exit(int)), [Runtime.halt(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#halt(int)), [Runtime.exit(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html#exit(int)).\n* Common Weakness Enumeration: [CWE-382](https://cwe.mitre.org/data/definitions/382.html).\n"
                    },
                    "id": "java/jvm-exit",
                    "name": "java/jvm-exit",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToSystemExit.ql",
                      "tags": [
                        "external/cwe/cwe-382",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Forcible JVM termination"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method in which a variable is declared with the same name as a field is difficult to understand."
                    },
                    "help": {
                      "markdown": "# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n",
                      "text": "# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"
                    },
                    "id": "java/local-shadows-field",
                    "name": "java/local-shadows-field",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/LocalShadowsFieldConfusing.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Possible confusion of local and field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "If a local variable shadows a field of the same name, each use of the name is harder to read."
                    },
                    "help": {
                      "markdown": "# Local variable shadows field\nThis query finds local variables that shadow like-named field declarations. This is confusing since it might easily lead to assignments to the local variable that should have been to the corresponding field.\n\n\n## How to Address the Query Results\nFor clarity, it may be better to rename the variable to avoid shadowing.\n\n\n## References\n",
                      "text": "# Local variable shadows field\nThis query finds local variables that shadow like-named field declarations. This is confusing since it might easily lead to assignments to the local variable that should have been to the corresponding field.\n\n\n## How to Address the Query Results\nFor clarity, it may be better to rename the variable to avoid shadowing.\n\n\n## References\n"
                    },
                    "id": "java/local-shadows-field-unused",
                    "name": "java/local-shadows-field-unused",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Naming%20Conventions/LocalShadowsField.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Local variable shadows field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A local variable that is never read is redundant."
                    },
                    "help": {
                      "markdown": "# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/local-variable-is-never-read",
                    "name": "java/local-variable-is-never-read",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnreadLocal.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unread local variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic number makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic numbers\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nAssign the magic number to a new named constant, and use this instead. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `timeout`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint timeout = 60000;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, timeout);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;  // Magic number is replaced by named constant\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'TIMEOUT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic numbers\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nAssign the magic number to a new named constant, and use this instead. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `timeout`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint timeout = 60000;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, timeout);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;  // Magic number is replaced by named constant\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'TIMEOUT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/magic-number",
                    "name": "java/magic-number",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicConstantsNumbers.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic numbers"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic string makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic strings\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nAssign the magic string to a new named constant, and use this instead. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `username`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString username = \"test\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(IP, PORT, username, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int USERNAME = \"test\";  // Magic string is replaced by named constant\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'USERNAME' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic strings\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nAssign the magic string to a new named constant, and use this instead. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `username`. This should be replaced by a new named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString username = \"test\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(IP, PORT, username, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final int USERNAME = \"test\";  // Magic string is replaced by named constant\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'USERNAME' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/magic-string",
                    "name": "java/magic-string",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicConstantsString.ql",
                      "tags": [
                        "maintainability",
                        "non-attributable",
                        "readability",
                        "statistical"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic strings"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "If a control structure does not use braces, misleading indentation makes it difficult to see which statements are within its scope."
                    },
                    "help": {
                      "markdown": "# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n",
                      "text": "# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n"
                    },
                    "id": "java/misleading-indentation",
                    "name": "java/misleading-indentation",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Statements/UseBraces.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misleading indentation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A static, final field name that contains lowercase letters decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed static final field\nA static, final field name that contains lowercase letters does not follow standard naming conventions, which decreases code readability. For example, `Min_Width`.\n\n\n## Recommendation\nUse uppercase letters throughout a static, final field name, and use underscores to separate words within the field name. For example, `MIN_WIDTH`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed static final field\nA static, final field name that contains lowercase letters does not follow standard naming conventions, which decreases code readability. For example, `Min_Width`.\n\n\n## Recommendation\nUse uppercase letters throughout a static, final field name, and use underscores to separate words within the field name. For example, `MIN_WIDTH`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-constant",
                    "name": "java/misnamed-constant",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsConstants.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed static final field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method name that begins with an uppercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed method\nA method name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Getbackground`.\n\n\n## Recommendation\nBegin the method name with a lowercase letter and use camel case: capitalize the first letter of each word within the method name. For example, `getBackground`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed method\nA method name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Getbackground`.\n\n\n## Recommendation\nBegin the method name with a lowercase letter and use camel case: capitalize the first letter of each word within the method name. For example, `getBackground`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-function",
                    "name": "java/misnamed-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsMethods.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A package name that contains uppercase letters decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed package\nA package name that contains uppercase letters does not follow standard naming conventions, which decreases code readability. For example, `Com.Sun.Eng`.\n\n\n## Recommendation\nUse lowercase letters throughout a package name. For example, `com.sun.eng`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed package\nA package name that contains uppercase letters does not follow standard naming conventions, which decreases code readability. For example, `Com.Sun.Eng`.\n\n\n## Recommendation\nUse lowercase letters throughout a package name. For example, `com.sun.eng`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-package",
                    "name": "java/misnamed-package",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsPackages.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed package"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A class or interface name that begins with a lowercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed class or interface\nA class or interface name that begins with a lowercase letter does not follow standard naming conventions, which decreases code readability. For example, `hotelbooking`.\n\n\n## Recommendation\nBegin the class name with an uppercase letter and use camel case: capitalize the first letter of each word within the class name. For example, `HotelBooking`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed class or interface\nA class or interface name that begins with a lowercase letter does not follow standard naming conventions, which decreases code readability. For example, `hotelbooking`.\n\n\n## Recommendation\nBegin the class name with an uppercase letter and use camel case: capitalize the first letter of each word within the class name. For example, `HotelBooking`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-type",
                    "name": "java/misnamed-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsRefTypes.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed class or interface"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A variable name that begins with an uppercase letter decreases readability."
                    },
                    "help": {
                      "markdown": "# Misnamed variable\nA variable name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Numberofguests`. This applies to local variables, parameters, and non-constant fields.\n\n\n## Recommendation\nBegin the variable name with a lowercase letter and use camel case: capitalize the first letter of each word within the variable name. For example, `numberOfGuests`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n",
                      "text": "# Misnamed variable\nA variable name that begins with an uppercase letter does not follow standard naming conventions, which decreases code readability. For example, `Numberofguests`. This applies to local variables, parameters, and non-constant fields.\n\n\n## Recommendation\nBegin the variable name with a lowercase letter and use camel case: capitalize the first letter of each word within the variable name. For example, `numberOfGuests`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 56. Addison-Wesley, 2008.\n* Java Language Specification: [6.1. Declarations](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.1).\n* Java SE Documentation: [9 - Naming Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).\n"
                    },
                    "id": "java/misnamed-variable",
                    "name": "java/misnamed-variable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Naming/NamingConventionsVariables.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Misnamed variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An 'if' statement where both branches either (a) return or (b) write to the same variable can often be expressed more clearly using the '?' operator."
                    },
                    "help": {
                      "markdown": "# Missed ternary opportunity\nAn `if` statement where both branches do nothing but return or write to a variable can be better expressed using the ternary `?` operator.\n\n\n\nUse of the ternary operator enhances readability in two ways:\n\n* It focuses the reader's attention on the intent of the code (to return or write) rather than the testing of a condition.\n* It is more concise, reducing the amount of code that needs to be read.\n* You can initialize a variable conditionally on the line on which it is declared, rather than assigning to it after initialization. This ensures that you initialize the variable as you intended.\n\n## Recommendation\nConsider using a ternary operator in this situation.\n\n\n## Example\nThe following code includes two examples of `if` statements, `myAbs1` and `1`, which can be simplified using the ternary operator. `myAbs2` and `s2` show how the statements can be improved.\n\n\n```java\npublic class MissedTernaryOpportunity {\n\tprivate static int myAbs1(int x) {\n\t\t// Violation\n\t\tif(x >= 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn -x;\n\t}\n\n\tprivate static int myAbs2(int x) {\n\t\t// Better\n\t\treturn x >= 0 ? x : -x;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint i = 23;\n\n\t\t// Violation\n\t\tString s1;\n\t\tif(i == 23)\n\t\t\ts1 = \"Foo\";\n\t\telse\n\t\t\ts1 = \"Bar\";\n\t\tSystem.out.println(s1);\n\n\t\t// Better\n\t\tString s2 = i == 23 ? \"Foo\" : \"Bar\";\n\t\tSystem.out.println(s2);\n\t}\n}\n```\n",
                      "text": "# Missed ternary opportunity\nAn `if` statement where both branches do nothing but return or write to a variable can be better expressed using the ternary `?` operator.\n\n\n\nUse of the ternary operator enhances readability in two ways:\n\n* It focuses the reader's attention on the intent of the code (to return or write) rather than the testing of a condition.\n* It is more concise, reducing the amount of code that needs to be read.\n* You can initialize a variable conditionally on the line on which it is declared, rather than assigning to it after initialization. This ensures that you initialize the variable as you intended.\n\n## Recommendation\nConsider using a ternary operator in this situation.\n\n\n## Example\nThe following code includes two examples of `if` statements, `myAbs1` and `1`, which can be simplified using the ternary operator. `myAbs2` and `s2` show how the statements can be improved.\n\n\n```java\npublic class MissedTernaryOpportunity {\n\tprivate static int myAbs1(int x) {\n\t\t// Violation\n\t\tif(x >= 0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn -x;\n\t}\n\n\tprivate static int myAbs2(int x) {\n\t\t// Better\n\t\treturn x >= 0 ? x : -x;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint i = 23;\n\n\t\t// Violation\n\t\tString s1;\n\t\tif(i == 23)\n\t\t\ts1 = \"Foo\";\n\t\telse\n\t\t\ts1 = \"Bar\";\n\t\tSystem.out.println(s1);\n\n\t\t// Better\n\t\tString s2 = i == 23 ? \"Foo\" : \"Bar\";\n\t\tSystem.out.println(s2);\n\t}\n}\n```\n"
                    },
                    "id": "java/missed-ternary-operator",
                    "name": "java/missed-ternary-operator",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/MissedTernaryOpportunity.ql",
                      "tags": [
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missed ternary opportunity"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A 'clone' method that is overridden in a subclass, and that does not itself call 'super.clone', causes calls to the subclass's 'clone' method to return an object of the wrong type."
                    },
                    "help": {
                      "markdown": "# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n",
                      "text": "# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n"
                    },
                    "id": "java/missing-call-to-super-clone",
                    "name": "java/missing-call-to-super-clone",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Cloning/MissingCallToSuperClone.ql",
                      "tags": [
                        "external/cwe/cwe-580",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing super clone"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A class that implements 'Cloneable' but does not override the 'clone' method will have undesired behavior."
                    },
                    "help": {
                      "markdown": "# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n",
                      "text": "# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n"
                    },
                    "id": "java/missing-clone-method",
                    "name": "java/missing-clone-method",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Cloning/MissingMethodClone.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "No clone method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling 'String.toUpperCase()' or 'String.toLowerCase()' without specifying the locale may cause unexpected results for certain default locales."
                    },
                    "help": {
                      "markdown": "# Missing Locale parameter to toUpperCase() or toLowerCase()\nThe parameterless versions of `String.toUpperCase()` and `String.toLowerCase()` use the default locale of the Java Virtual Machine when transforming strings. This can cause unexpected behavior for certain locales.\n\n\n## Recommendation\nUse the corresponding methods with explicit locale parameters to ensure that the results are consistent across all locales. For example:\n\n`System.out.println(\"I\".toLowerCase(java.util.Locale.ENGLISH));`\n\nprints `i`, regardless of the default locale.\n\n\n## Example\nIn the following example, the calls to the parameterless functions may return different strings for different locales. For example, if the default locale is ENGLISH, the function `toLowerCase()` converts a capital `I` to `i`; if the default locale is TURKISH, the function `toLowerCase()` converts a capital `I` to the Unicode Character \"Latin small letter dotless i\" (U+0131).\n\nTo ensure that an English string is returned, regardless of the default locale, the example shows how to call `toLowerCase` and pass `locale.ENGLISH` as the argument. (This assumes that the text is English. If the text is Turkish, you should pass `locale.TURKISH` as the argument.)\n\n\n```java\npublic static void main(String args[]) {\n    String phrase = \"I miss my home in Mississippi.\";\n\n    // AVOID: Calling 'toLowerCase()' or 'toUpperCase()'\n    // produces different results depending on what the default locale is.\n    System.out.println(phrase.toUpperCase());\n    System.out.println(phrase.toLowerCase());\n\n    // GOOD: Explicitly setting the locale when calling 'toLowerCase()' or\n    // 'toUpperCase()' ensures that the resulting string is\n    // English, regardless of the default locale.\n    System.out.println(phrase.toLowerCase(Locale.ENGLISH));\n    System.out.println(phrase.toUpperCase(Locale.ENGLISH));\n}\n```\n\n## References\n* Java API Specification: [String.toUpperCase()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toUpperCase()).\n",
                      "text": "# Missing Locale parameter to toUpperCase() or toLowerCase()\nThe parameterless versions of `String.toUpperCase()` and `String.toLowerCase()` use the default locale of the Java Virtual Machine when transforming strings. This can cause unexpected behavior for certain locales.\n\n\n## Recommendation\nUse the corresponding methods with explicit locale parameters to ensure that the results are consistent across all locales. For example:\n\n`System.out.println(\"I\".toLowerCase(java.util.Locale.ENGLISH));`\n\nprints `i`, regardless of the default locale.\n\n\n## Example\nIn the following example, the calls to the parameterless functions may return different strings for different locales. For example, if the default locale is ENGLISH, the function `toLowerCase()` converts a capital `I` to `i`; if the default locale is TURKISH, the function `toLowerCase()` converts a capital `I` to the Unicode Character \"Latin small letter dotless i\" (U+0131).\n\nTo ensure that an English string is returned, regardless of the default locale, the example shows how to call `toLowerCase` and pass `locale.ENGLISH` as the argument. (This assumes that the text is English. If the text is Turkish, you should pass `locale.TURKISH` as the argument.)\n\n\n```java\npublic static void main(String args[]) {\n    String phrase = \"I miss my home in Mississippi.\";\n\n    // AVOID: Calling 'toLowerCase()' or 'toUpperCase()'\n    // produces different results depending on what the default locale is.\n    System.out.println(phrase.toUpperCase());\n    System.out.println(phrase.toLowerCase());\n\n    // GOOD: Explicitly setting the locale when calling 'toLowerCase()' or\n    // 'toUpperCase()' ensures that the resulting string is\n    // English, regardless of the default locale.\n    System.out.println(phrase.toLowerCase(Locale.ENGLISH));\n    System.out.println(phrase.toUpperCase(Locale.ENGLISH));\n}\n```\n\n## References\n* Java API Specification: [String.toUpperCase()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toUpperCase()).\n"
                    },
                    "id": "java/missing-locale-argument",
                    "name": "java/missing-locale-argument",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/I18N/MissingLocaleArgument.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Locale parameter to toUpperCase() or toLowerCase()"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A class that implements 'Externalizable' but does not have a public no-argument constructor causes an 'InvalidClassException' to be thrown."
                    },
                    "help": {
                      "markdown": "# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n",
                      "text": "# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n"
                    },
                    "id": "java/missing-no-arg-constructor-on-externalizable",
                    "name": "java/missing-no-arg-constructor-on-externalizable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/MissingVoidConstructorOnExternalizable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Externalizable but no public no-argument constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A non-serializable, immediate superclass of a serializable class that does not itself declare an accessible, no-argument constructor causes deserialization to fail."
                    },
                    "help": {
                      "markdown": "# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n",
                      "text": "# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/missing-no-arg-constructor-on-serializable",
                    "name": "java/missing-no-arg-constructor-on-serializable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/MissingVoidConstructorsOnSerializable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serializable but no void constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method that overrides a method in a superclass but does not have an 'Override' annotation cannot take advantage of compiler checks, and makes code less readable."
                    },
                    "help": {
                      "markdown": "# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n",
                      "text": "# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n"
                    },
                    "id": "java/missing-override-annotation",
                    "name": "java/missing-override-annotation",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Declarations/MissingOverrideAnnotation.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Override annotation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A 'finalize' method that does not call 'super.finalize' may leave cleanup actions undone."
                    },
                    "help": {
                      "markdown": "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n",
                      "text": "# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"
                    },
                    "id": "java/missing-super-finalize",
                    "name": "java/missing-super-finalize",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Finalization/NullifiedSuperFinalize.ql",
                      "tags": [
                        "external/cwe/cwe-568",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Finalizer inconsistency"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "More than one statement per line decreases readability."
                    },
                    "help": {
                      "markdown": "# Multiple statements on line\nCode where each statement is defined on a separate line is much easier for programmers to read than code where multiple statements are defined on the same line.\n\n\n## Recommendation\nSeparate statements by a newline character.\n\n\n## References\n* Java SE Documentation: [7.1 Simple Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#431).\n",
                      "text": "# Multiple statements on line\nCode where each statement is defined on a separate line is much easier for programmers to read than code where multiple statements are defined on the same line.\n\n\n## Recommendation\nSeparate statements by a newline character.\n\n\n## References\n* Java SE Documentation: [7.1 Simple Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#431).\n"
                    },
                    "id": "java/multiple-statements-on-same-line",
                    "name": "java/multiple-statements-on-same-line",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Statements/OneStatementPerLine.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Multiple statements on line"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Using the remainder operator with the multiplication operator without adding parentheses to clarify precedence may cause confusion."
                    },
                    "help": {
                      "markdown": "# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n",
                      "text": "# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n"
                    },
                    "id": "java/multiplication-of-remainder",
                    "name": "java/multiplication-of-remainder",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/MultiplyRemainder.ql",
                      "tags": [
                        "correctness",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Multiplication of remainder"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Mutual dependency between types makes code difficult to understand and test."
                    },
                    "help": {
                      "markdown": "# Mutually-dependent types\nA mutual dependency exists when two code entities (for example, types or packages) depend directly on each other. Mutual dependencies are caused by unwanted dependencies in one or both directions. There are many different kinds of dependency; here are a few examples of how an inter-type dependency from `T1` to `T2` can occur:\n\n* `T1` derives from a type involving `T2`, for example `T2` itself or `List<T2>`.\n* `T1` declares a field of a type involving `T2`.\n* `T1` declares a method whose return type involves `T2`.\n* A method of `T1` declares a local variable whose type involves `T2`.\n* A method of `T1` catches an exception of a type involving `T2`.\nMutual dependencies prevent you from considering either entity in isolation, affecting readability and testability. For example, if types `T1` and `T2` depend on each other, then it is generally impossible to fully understand `T1` without understanding `T2`, and vice-versa. Moreover, neither type can be tested without the other being present. Whilst mocking can alleviate this latter problem to some extent, breaking the mutual dependency is a better solution. For example, suppose we could remove all of the dependencies from `T2` to `T1` - in that case, we would be able to test `T2` in isolation, and completely side-step the need to provide a `T1`, mocked or otherwise.\n\n\n## Recommendation\nBreaking mutual dependencies involves finding ways of removing the unwanted individual dependencies that cause them. The way to do this depends on the kind of dependency in question, with some kinds (for example, dependencies caused by inheritance) being much harder to break than others. A full list of ways to break cycles is beyond the scope of this help topic, however, a few high-level techniques for breaking a dependency from `T1` to `T2` include:\n\n* Introducing an interface that is implemented by `T2`. `T1` can then be refactored to use `T2` only via the interface, which breaks the cycle.\n* Moving the depended-on code in `T2` to a third (possibly new) entity. `T1` can then depend on this third entity instead of on `T2`, breaking the cycle. `T2` is allowed to depend on the third entity as well, although it does not have to if there is no need.\n* Merging `T1` and `T2` together (for example, if there was an artificial separation between two parts of the same concept). This is not a generally-applicable solution, but is sometimes the right thing to do. It has the effect of internalizing the cycle, which is sufficient to solve the problem.\nFor more information on how to break unwanted dependencies, see the references (particularly \\[Lakos\\]).\n\n\n## Example\nIn this example `BadModel` and `BadView` are mutually dependent.\n\n\n```java\npublic class MutualDependency {\n\t// Violation: BadModel and BadView are mutually dependent\n\tprivate static class BadModel {\n\t\tprivate int i;\n\t\tprivate BadView view;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif(view != null) view.modelChanged();\n\t\t}\n\n\t\tpublic void setView(BadView view) {\n\t\t\tthis.view = view;\n\t\t}\n\t}\n\n\tprivate static class BadView {\n\t\tprivate BadModel model;\n\n\t\tpublic BadView(BadModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n}\n```\nThe interface technique can be used to break the dependency between the model and the view. The `ModelListener` interface allows `BetterView` to interact with `BetterModel` without dependency.\n\n\n```java\npublic class NoMutualDependency {\n\t// Better: A new interface breaks the dependency\n\t// from the model to the view\n\tprivate interface ModelListener {\n\t\tvoid modelChanged();\n\t}\n\n\tprivate static class BetterModel {\n\t\tprivate int i;\n\t\tprivate ModelListener listener;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif (listener != null) listener.modelChanged();\n\t\t}\n\n\t\tpublic void setListener(ModelListener listener) {\n\t\t\tthis.listener = listener;\n\t\t}\n\t}\n\n\tprivate static class BetterView implements ModelListener {\n\t\tprivate BetterModel model;\n\n\t\tpublic BetterView(BetterModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBadModel badModel = new BadModel();\n\t\tBadView badView = new BadView(badModel);\n\t\tbadModel.setView(badView);\n\t\tbadModel.setI(23);\n\t\tbadModel.setI(9);\n\n\t\tBetterModel betterModel = new BetterModel();\n\t\tBetterView betterView = new BetterView(betterModel);\n\t\tbetterModel.setListener(betterView);\n\t\tbetterModel.setI(24);\n\t\tbetterModel.setI(12);\n\t}\n}\n```\n\n## References\n* J. Lakos. *Large-Scale C++ Software Design*. Addison-Wesley, 1996.\n* M. Fowler. *Refactoring*. Addison-Wesley, 1999.\n",
                      "text": "# Mutually-dependent types\nA mutual dependency exists when two code entities (for example, types or packages) depend directly on each other. Mutual dependencies are caused by unwanted dependencies in one or both directions. There are many different kinds of dependency; here are a few examples of how an inter-type dependency from `T1` to `T2` can occur:\n\n* `T1` derives from a type involving `T2`, for example `T2` itself or `List<T2>`.\n* `T1` declares a field of a type involving `T2`.\n* `T1` declares a method whose return type involves `T2`.\n* A method of `T1` declares a local variable whose type involves `T2`.\n* A method of `T1` catches an exception of a type involving `T2`.\nMutual dependencies prevent you from considering either entity in isolation, affecting readability and testability. For example, if types `T1` and `T2` depend on each other, then it is generally impossible to fully understand `T1` without understanding `T2`, and vice-versa. Moreover, neither type can be tested without the other being present. Whilst mocking can alleviate this latter problem to some extent, breaking the mutual dependency is a better solution. For example, suppose we could remove all of the dependencies from `T2` to `T1` - in that case, we would be able to test `T2` in isolation, and completely side-step the need to provide a `T1`, mocked or otherwise.\n\n\n## Recommendation\nBreaking mutual dependencies involves finding ways of removing the unwanted individual dependencies that cause them. The way to do this depends on the kind of dependency in question, with some kinds (for example, dependencies caused by inheritance) being much harder to break than others. A full list of ways to break cycles is beyond the scope of this help topic, however, a few high-level techniques for breaking a dependency from `T1` to `T2` include:\n\n* Introducing an interface that is implemented by `T2`. `T1` can then be refactored to use `T2` only via the interface, which breaks the cycle.\n* Moving the depended-on code in `T2` to a third (possibly new) entity. `T1` can then depend on this third entity instead of on `T2`, breaking the cycle. `T2` is allowed to depend on the third entity as well, although it does not have to if there is no need.\n* Merging `T1` and `T2` together (for example, if there was an artificial separation between two parts of the same concept). This is not a generally-applicable solution, but is sometimes the right thing to do. It has the effect of internalizing the cycle, which is sufficient to solve the problem.\nFor more information on how to break unwanted dependencies, see the references (particularly \\[Lakos\\]).\n\n\n## Example\nIn this example `BadModel` and `BadView` are mutually dependent.\n\n\n```java\npublic class MutualDependency {\n\t// Violation: BadModel and BadView are mutually dependent\n\tprivate static class BadModel {\n\t\tprivate int i;\n\t\tprivate BadView view;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif(view != null) view.modelChanged();\n\t\t}\n\n\t\tpublic void setView(BadView view) {\n\t\t\tthis.view = view;\n\t\t}\n\t}\n\n\tprivate static class BadView {\n\t\tprivate BadModel model;\n\n\t\tpublic BadView(BadModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n}\n```\nThe interface technique can be used to break the dependency between the model and the view. The `ModelListener` interface allows `BetterView` to interact with `BetterModel` without dependency.\n\n\n```java\npublic class NoMutualDependency {\n\t// Better: A new interface breaks the dependency\n\t// from the model to the view\n\tprivate interface ModelListener {\n\t\tvoid modelChanged();\n\t}\n\n\tprivate static class BetterModel {\n\t\tprivate int i;\n\t\tprivate ModelListener listener;\n\n\t\tpublic int getI() {\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic void setI(int i) {\n\t\t\tthis.i = i;\n\t\t\tif (listener != null) listener.modelChanged();\n\t\t}\n\n\t\tpublic void setListener(ModelListener listener) {\n\t\t\tthis.listener = listener;\n\t\t}\n\t}\n\n\tprivate static class BetterView implements ModelListener {\n\t\tprivate BetterModel model;\n\n\t\tpublic BetterView(BetterModel model) {\n\t\t\tthis.model = model;\n\t\t}\n\n\t\tpublic void modelChanged() {\n\t\t\tSystem.out.println(\"Model Changed: \" + model.getI());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBadModel badModel = new BadModel();\n\t\tBadView badView = new BadView(badModel);\n\t\tbadModel.setView(badView);\n\t\tbadModel.setI(23);\n\t\tbadModel.setI(9);\n\n\t\tBetterModel betterModel = new BetterModel();\n\t\tBetterView betterView = new BetterView(betterModel);\n\t\tbetterModel.setListener(betterView);\n\t\tbetterModel.setI(24);\n\t\tbetterModel.setI(12);\n\t}\n}\n```\n\n## References\n* J. Lakos. *Large-Scale C++ Software Design*. Addison-Wesley, 1996.\n* M. Fowler. *Refactoring*. Addison-Wesley, 1999.\n"
                    },
                    "id": "java/mutually-dependent-types",
                    "name": "java/mutually-dependent-types",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Architecture/Dependencies/MutualDependency.ql",
                      "tags": [
                        "maintainability",
                        "modularity",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mutually-dependent types"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Nested loops in which the iteration variable is the same for each loop are difficult to understand."
                    },
                    "help": {
                      "markdown": "# Nested loops with same variable\nThe behavior of nested loops in which the iteration variable is the same for both loops is difficult to understand because the inner loop affects the iteration variable of the outer loop. This is probably a typographical error.\n\n\n## Recommendation\nEnsure that a different iteration variable is used for each loop.\n\n\n## References\n* Java Language Specification: [The basic for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.1).\n",
                      "text": "# Nested loops with same variable\nThe behavior of nested loops in which the iteration variable is the same for both loops is difficult to understand because the inner loop affects the iteration variable of the outer loop. This is probably a typographical error.\n\n\n## Recommendation\nEnsure that a different iteration variable is used for each loop.\n\n\n## References\n* Java Language Specification: [The basic for Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.1).\n"
                    },
                    "id": "java/nested-loops-with-same-variable",
                    "name": "java/nested-loops-with-same-variable",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/NestedLoopsSameVariable.ql",
                      "tags": [
                        "correctness",
                        "logic",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Nested loops with same variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method that appears to override another method but does not, because the declaring classes are in different packages, is potentially confusing."
                    },
                    "help": {
                      "markdown": "# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n",
                      "text": "# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n"
                    },
                    "id": "java/non-overriding-package-private",
                    "name": "java/non-overriding-package-private",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/OverridePackagePrivate.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Confusing non-overriding of package-private method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-constant field that is not declared 'private', but is not accessed outside of its declaring type, may decrease code maintainability."
                    },
                    "help": {
                      "markdown": "# Non-private field\nA non-final or non-static field that is not declared `private`, but is not accessed outside of its declaring type, may decrease code maintainability. This is because a field that is accessible from outside the class that it is declared in tends to restrict the class to a particular implementation.\n\n\n## Recommendation\nIn the spirit of encapsulation, it is generally advisable to choose the most restrictive access modifier (`private`) for a field, unless there is a good reason to increase its visibility.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 13. Addison-Wesley, 2008.\n* The Java Tutorials: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html).\n",
                      "text": "# Non-private field\nA non-final or non-static field that is not declared `private`, but is not accessed outside of its declaring type, may decrease code maintainability. This is because a field that is accessible from outside the class that it is declared in tends to restrict the class to a particular implementation.\n\n\n## Recommendation\nIn the spirit of encapsulation, it is generally advisable to choose the most restrictive access modifier (`private`) for a field, unless there is a good reason to increase its visibility.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 13. Addison-Wesley, 2008.\n* The Java Tutorials: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html).\n"
                    },
                    "id": "java/non-private-field",
                    "name": "java/non-private-field",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Declarations/NonPrivateField.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-private field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A comparator that is passed to an ordered collection (for example, a treemap) must be serializable, otherwise the collection fails to serialize at run-time."
                    },
                    "help": {
                      "markdown": "# Non-serializable comparator\nA class that implements `java.util.Comparator` and is used to construct a sorted collection needs to be serializable. An ordered collection (such as a `java.util.TreeMap`) that is constructed using a comparator serializes successfully only if the comparator is serializable.\n\nThe `Collection`s in the Java Standard Library that require a comparator (`TreeSet`, `TreeMap`, `PriorityQueue`) all call `ObjectOutputStream.defaultWriteObject`, which tries to serialize every non-static, non-transient field in the class. As the comparator is stored in a field in these collections, the attempt to serialize a non-serializable comparator throws a `java.io.NotSerializableException`.\n\n\n## Recommendation\nComparators should be serializable if they are used in sorted collections that may be serialized. In most cases, simply changing the comparator so it also implements `Serializable` is enough. Comparators that have internal state may require additional changes (for example, custom `writeObject` and `readObject` methods). In these cases, it is best to follow general best practices for serializable objects (see references below).\n\n\n## Example\nIn the following example, `WrongComparator` is not serializable because it does not implement `Serializable`. However, `StringComparator` is serializable because it does implement `Serializable`.\n\n\n```java\n// BAD: This is not serializable, and throws a 'java.io.NotSerializableException'\n// when used in a serializable sorted collection.\nclass WrongComparator implements Comparator<String> {\n    public int compare(String o1, String o2) {\n        return o1.compareTo(o2);\n    }\n}\n\n// GOOD: This is serializable, and can be used in collections that are meant to be serialized.\nclass StringComparator implements Comparator<String>, Serializable {\n    private static final long serialVersionUID = -5972458403679726498L;\n\n    public int compare(String arg0, String arg1) {\n        return arg0.compareTo(arg1);\n    }\n}\n```\n\n## References\n* Java API Specification: [Comparator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html), [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n",
                      "text": "# Non-serializable comparator\nA class that implements `java.util.Comparator` and is used to construct a sorted collection needs to be serializable. An ordered collection (such as a `java.util.TreeMap`) that is constructed using a comparator serializes successfully only if the comparator is serializable.\n\nThe `Collection`s in the Java Standard Library that require a comparator (`TreeSet`, `TreeMap`, `PriorityQueue`) all call `ObjectOutputStream.defaultWriteObject`, which tries to serialize every non-static, non-transient field in the class. As the comparator is stored in a field in these collections, the attempt to serialize a non-serializable comparator throws a `java.io.NotSerializableException`.\n\n\n## Recommendation\nComparators should be serializable if they are used in sorted collections that may be serialized. In most cases, simply changing the comparator so it also implements `Serializable` is enough. Comparators that have internal state may require additional changes (for example, custom `writeObject` and `readObject` methods). In these cases, it is best to follow general best practices for serializable objects (see references below).\n\n\n## Example\nIn the following example, `WrongComparator` is not serializable because it does not implement `Serializable`. However, `StringComparator` is serializable because it does implement `Serializable`.\n\n\n```java\n// BAD: This is not serializable, and throws a 'java.io.NotSerializableException'\n// when used in a serializable sorted collection.\nclass WrongComparator implements Comparator<String> {\n    public int compare(String o1, String o2) {\n        return o1.compareTo(o2);\n    }\n}\n\n// GOOD: This is serializable, and can be used in collections that are meant to be serialized.\nclass StringComparator implements Comparator<String>, Serializable {\n    private static final long serialVersionUID = -5972458403679726498L;\n\n    public int compare(String arg0, String arg1) {\n        return arg0.compareTo(arg1);\n    }\n}\n```\n\n## References\n* Java API Specification: [Comparator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html), [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n"
                    },
                    "id": "java/non-serializable-comparator",
                    "name": "java/non-serializable-comparator",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableComparator.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-serializable comparator"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A non-transient field in a serializable class must also be serializable otherwise it causes the class to fail to serialize with a 'NotSerializableException'."
                    },
                    "help": {
                      "markdown": "# Non-serializable field\nIf a serializable class is serialized using the default Java serialization mechanism, each non-static, non-transient field in the class must also be serializable. Otherwise, the class generates a `java.io.NotSerializableException` as its fields are written out by `ObjectOutputStream.writeObject`.\n\nAs an exception, classes that define their own `readObject` and `writeObject` methods can have fields that are not themselves serializable. The `readObject` and `writeObject` methods are responsible for encoding any state in those fields that needs to be serialized.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Mark the field as `transient` :** Marking the field as `transient` makes the serialization mechanism skip the field. Before doing this, make sure that the field is not really intended to be part of the persistent state of the object.\n* **Define custom `readObject` and `writeObject` methods for the `Serializable` class :** Explicitly defining the `readObject` and `writeObject` methods enables you to choose which fields to read from, or write to, an object stream during serialization.\n* **Make the type of the field `Serializable` :** If the field is part of the object's persistent state and you wish to use Java's default serialization mechanism, the type of the field must implement `Serializable`. When choosing this option, make sure that you follow best practices for serialization.\n\n## Example 1\nIn the following example, `WrongPerformanceRecord` contains a field `factors` that is not serializable but is in a serializable class. This causes a `java.io.NotSerializableException` when the field is written out by `writeObject`. However, `PerformanceRecord` contains a field `factors` that is marked as `transient`, so that the serialization mechanism skips the field. This means that a correctly serialized record is output by `writeObject`.\n\n\n```java\nclass DerivedFactors {             // Class that contains derived values computed from entries in a\n    private Number efficiency;     // performance record\n    private Number costPerItem;\n    private Number profitPerItem;\n    ...\n}\n\nclass WrongPerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    private DerivedFactors factors;  // BAD: 'DerivedFactors' is not serializable\n                                     // but is in a serializable class. This\n                                     // causes a 'java.io.NotSerializableException'\n                                     // when 'WrongPerformanceRecord' is serialized.\n    ...\n}\n\nclass PerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    transient private DerivedFactors factors;  // GOOD: 'DerivedFactors' is declared\n                                               // 'transient' so it does not contribute to the\n                                               // serializable state of 'PerformanceRecord'.\n    ...\n}\n\n```\n\n## Example 2\nIn this second example, `WrongPair` takes two generic parameters `L` and `R`. The class itself is serializable, but users of this class are not forced to pass serializable objects to its constructor, which could lead to problems during serialization. The solution is to set upper type bounds for the parameters, to force the user to supply only serializable objects. A similar example is the `WrongEvent` class, which takes a weakly typed `eventData` object. A better solution is to force the user to supply an object whose class implements the `Serializable` interface.\n\n\n```java\nclass WrongPair<L, R> implements Serializable{\n    private final L left;            // BAD\n    private final R right;           // BAD: L and R are not guaranteed to be serializable\n\n    public WrongPair(L left, R right){ ... }\n\n    ...\n}\n\nclass Pair<L extends Serializable, R extends Serializable> implements Serializable{\n    private final L left;            // GOOD: L and R must implement Serializable\n    private final R right;\n\n    public Pair(L left, R right){ ... }\n\n    ...\n}\n\nclass WrongEvent implements Serializable{\n    private Object eventData;        // BAD: Type is too general.\n\n    public WrongEvent(Object eventData){ ... }\n}\n\nclass Event implements Serializable{\n    private Serializable eventData;  // GOOD: Force the user to supply only serializable data\n\n    public Event(Serializable eventData){ ... }\n}\n\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html).\n",
                      "text": "# Non-serializable field\nIf a serializable class is serialized using the default Java serialization mechanism, each non-static, non-transient field in the class must also be serializable. Otherwise, the class generates a `java.io.NotSerializableException` as its fields are written out by `ObjectOutputStream.writeObject`.\n\nAs an exception, classes that define their own `readObject` and `writeObject` methods can have fields that are not themselves serializable. The `readObject` and `writeObject` methods are responsible for encoding any state in those fields that needs to be serialized.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Mark the field as `transient` :** Marking the field as `transient` makes the serialization mechanism skip the field. Before doing this, make sure that the field is not really intended to be part of the persistent state of the object.\n* **Define custom `readObject` and `writeObject` methods for the `Serializable` class :** Explicitly defining the `readObject` and `writeObject` methods enables you to choose which fields to read from, or write to, an object stream during serialization.\n* **Make the type of the field `Serializable` :** If the field is part of the object's persistent state and you wish to use Java's default serialization mechanism, the type of the field must implement `Serializable`. When choosing this option, make sure that you follow best practices for serialization.\n\n## Example 1\nIn the following example, `WrongPerformanceRecord` contains a field `factors` that is not serializable but is in a serializable class. This causes a `java.io.NotSerializableException` when the field is written out by `writeObject`. However, `PerformanceRecord` contains a field `factors` that is marked as `transient`, so that the serialization mechanism skips the field. This means that a correctly serialized record is output by `writeObject`.\n\n\n```java\nclass DerivedFactors {             // Class that contains derived values computed from entries in a\n    private Number efficiency;     // performance record\n    private Number costPerItem;\n    private Number profitPerItem;\n    ...\n}\n\nclass WrongPerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    private DerivedFactors factors;  // BAD: 'DerivedFactors' is not serializable\n                                     // but is in a serializable class. This\n                                     // causes a 'java.io.NotSerializableException'\n                                     // when 'WrongPerformanceRecord' is serialized.\n    ...\n}\n\nclass PerformanceRecord implements Serializable {\n    private String unitId;\n    private Number dailyThroughput;\n    private Number dailyCost;\n    transient private DerivedFactors factors;  // GOOD: 'DerivedFactors' is declared\n                                               // 'transient' so it does not contribute to the\n                                               // serializable state of 'PerformanceRecord'.\n    ...\n}\n\n```\n\n## Example 2\nIn this second example, `WrongPair` takes two generic parameters `L` and `R`. The class itself is serializable, but users of this class are not forced to pass serializable objects to its constructor, which could lead to problems during serialization. The solution is to set upper type bounds for the parameters, to force the user to supply only serializable objects. A similar example is the `WrongEvent` class, which takes a weakly typed `eventData` object. A better solution is to force the user to supply an object whose class implements the `Serializable` interface.\n\n\n```java\nclass WrongPair<L, R> implements Serializable{\n    private final L left;            // BAD\n    private final R right;           // BAD: L and R are not guaranteed to be serializable\n\n    public WrongPair(L left, R right){ ... }\n\n    ...\n}\n\nclass Pair<L extends Serializable, R extends Serializable> implements Serializable{\n    private final L left;            // GOOD: L and R must implement Serializable\n    private final R right;\n\n    public Pair(L left, R right){ ... }\n\n    ...\n}\n\nclass WrongEvent implements Serializable{\n    private Object eventData;        // BAD: Type is too general.\n\n    public WrongEvent(Object eventData){ ... }\n}\n\nclass Event implements Serializable{\n    private Serializable eventData;  // GOOD: Force the user to supply only serializable data\n\n    public Event(Serializable eventData){ ... }\n}\n\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html), [ObjectOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html).\n"
                    },
                    "id": "java/non-serializable-field",
                    "name": "java/non-serializable-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableField.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-serializable field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A class that is serializable with an enclosing class that is not serializable causes serialization to fail."
                    },
                    "help": {
                      "markdown": "# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n",
                      "text": "# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n"
                    },
                    "id": "java/non-serializable-inner-class",
                    "name": "java/non-serializable-inner-class",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/NonSerializableInnerClass.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serializable inner class of non-serializable class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-static nested class keeps a reference to the enclosing object, which makes the nested class bigger and may cause a memory leak."
                    },
                    "help": {
                      "markdown": "# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n",
                      "text": "# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n"
                    },
                    "id": "java/non-static-nested-class",
                    "name": "java/non-static-nested-class",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/InnerClassCouldBeStatic.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Inner class could be static"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An integer literal that starts with '0' may cause a problem. If the '0' is intentional, a programmer may misread the literal as a decimal literal. If the '0' is unintentional and a decimal literal is intended, the compiler treats the literal as an octal literal."
                    },
                    "help": {
                      "markdown": "# Use of octal values\nAn integer literal consisting of a leading `0` digit followed by one or more digits in the range `0-7` is an octal literal. This can lead to two problems:\n\n* An octal literal can be misread by a programmer as a decimal literal.\n* A programmer might accidentally start a decimal literal with a zero, so that the compiler treats the decimal literal as an octal literal. For example, `010` is equal to `8`, not `10`.\n\n## Recommendation\nTo avoid these problems:\n\n* Avoid using octal literals so that programmers do not confuse them with decimal literals. However, if you need to use octal literals, you should add a comment to each octal literal indicating the intention to use octal literals.\n* When typing decimal literals, be careful not to begin them with a zero accidentally.\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 59. Addison-Wesley, 2005.\n* Java Language Specification: [Integer Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1).\n",
                      "text": "# Use of octal values\nAn integer literal consisting of a leading `0` digit followed by one or more digits in the range `0-7` is an octal literal. This can lead to two problems:\n\n* An octal literal can be misread by a programmer as a decimal literal.\n* A programmer might accidentally start a decimal literal with a zero, so that the compiler treats the decimal literal as an octal literal. For example, `010` is equal to `8`, not `10`.\n\n## Recommendation\nTo avoid these problems:\n\n* Avoid using octal literals so that programmers do not confuse them with decimal literals. However, if you need to use octal literals, you should add a comment to each octal literal indicating the intention to use octal literals.\n* When typing decimal literals, be careful not to begin them with a zero accidentally.\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 59. Addison-Wesley, 2005.\n* Java Language Specification: [Integer Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.1).\n"
                    },
                    "id": "java/octal-literal",
                    "name": "java/octal-literal",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/OctalLiteral.ql",
                      "tags": [
                        "correctness",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use of octal values"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An assignment to a local variable that is not used before a further assignment is made has no effect."
                    },
                    "help": {
                      "markdown": "# Assigned value is overwritten\nA value is assigned to a local variable, but whenever the variable is subsequently read, there has been at least one other assignment to that variable. This means that the original assignment is suspect, because the state of the local variable that it creates is never used.\n\n\n## Recommendation\nEnsure that you check the control and data flow in the method carefully. If a value is really not needed, consider omitting the assignment. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.\n\n\n## Example\nIn the following example, the value assigned to `result` on line 5 is always overwritten (line 6) before being read (line 7). This is a strong indicator that there is something wrong. By examining the code, we can see that the loop in lines 3-5 seems to be left over from an old way of storing the list of persons, and line 6 represents the new (and better-performing) way. Consequently, we can delete lines 3-5 while preserving behavior.\n\n\n```java\nPerson find(String name) {\n\tPerson result;\n\tfor (Person p : people.values())\n\t\tif (p.getName().equals(name))\n\t\t\tresult = p;  // Redundant assignment\n\tresult = people.get(name);\n\treturn result;\n```\n",
                      "text": "# Assigned value is overwritten\nA value is assigned to a local variable, but whenever the variable is subsequently read, there has been at least one other assignment to that variable. This means that the original assignment is suspect, because the state of the local variable that it creates is never used.\n\n\n## Recommendation\nEnsure that you check the control and data flow in the method carefully. If a value is really not needed, consider omitting the assignment. Be careful, though: if the right-hand side has a side-effect (like performing a method call), it is important to keep this to preserve the overall behavior.\n\n\n## Example\nIn the following example, the value assigned to `result` on line 5 is always overwritten (line 6) before being read (line 7). This is a strong indicator that there is something wrong. By examining the code, we can see that the loop in lines 3-5 seems to be left over from an old way of storing the list of persons, and line 6 represents the new (and better-performing) way. Consequently, we can delete lines 3-5 while preserving behavior.\n\n\n```java\nPerson find(String name) {\n\tPerson result;\n\tfor (Person p : people.values())\n\t\tif (p.getName().equals(name))\n\t\t\tresult = p;  // Redundant assignment\n\tresult = people.get(name);\n\treturn result;\n```\n"
                    },
                    "id": "java/overwritten-assignment-to-local",
                    "name": "java/overwritten-assignment-to-local",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/DeadStoreOfLocal.ql",
                      "tags": [
                        "external/cwe/cwe-563",
                        "maintainability",
                        "readability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Assigned value is overwritten"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Directly printing an array, without first converting the array to a string, produces unreadable results."
                    },
                    "help": {
                      "markdown": "# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/print-array",
                    "name": "java/print-array",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/PrintLnArray.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Implicit conversion from array to string"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Creating an instance of 'Random' for each pseudo-random number required does not guarantee an evenly distributed sequence of random numbers."
                    },
                    "help": {
                      "markdown": "# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n",
                      "text": "# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n"
                    },
                    "id": "java/random-used-once",
                    "name": "java/random-used-once",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/RandomUsedOnce.ql",
                      "tags": [
                        "external/cwe/cwe-335",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Random used only once"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Parameterizing a call to a constructor of a generic type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized constructor invocation\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized constructor invocation\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-constructor-invocation",
                    "name": "java/raw-constructor-invocation",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsConstructor.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized constructor invocation"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a parameterized instance of a generic type for a method return type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized method return type\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized method return type\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-return-type",
                    "name": "java/raw-return-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsReturnType.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized method return type"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Declaring a field, parameter, or local variable as a parameterized type increases type safety and code readability."
                    },
                    "help": {
                      "markdown": "# Non-parameterized variable\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n",
                      "text": "# Non-parameterized variable\nThe use of generics in Java improves compile-time type safety and code readability. Users of a class or interface that has been designed using generic types should therefore make use of parameterized instances in variable declarations, method return types, and constructor calls.\n\n\n## Recommendation\nProvide type parameters to generic classes and interfaces where possible.\n\nNote that converting legacy code to use generics may have to be done carefully in order to preserve the existing functionality of an API; for detailed guidance, see the references.\n\n\n## Example\nThe following example is poorly written because it uses raw types. This makes it more error prone because the compiler is less able to perform type checks.\n\n\n```java\npublic List constructRawList(Object o) {\n    List list;  // Raw variable declaration\n    list = new ArrayList();  // Raw constructor call\n    list.add(o);\n    return list;  // Raw method return type (see signature above)\n}\n```\nA parameterized version can be easily made and is much safer.\n\n\n```java\npublic <T> List<T> constructParameterizedList(T o) {\n    List<T> list;  // Parameterized variable declaration\n    list = new ArrayList<T>();  // Parameterized constructor call\n    list.add(o);\n    return list;  // Parameterized method return type (see signature above)\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 23. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Generics](https://docs.oracle.com/javase/tutorial/java/generics/), [Converting Legacy Code to Use Generics](https://docs.oracle.com/javase/tutorial/extra/generics/convert.html).\n"
                    },
                    "id": "java/raw-variable",
                    "name": "java/raw-variable",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Types/GenericsVariable.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-parameterized variable"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Casting an object to its own type is unnecessary."
                    },
                    "help": {
                      "markdown": "# Unnecessary cast\nA cast is unnecessary if the type of the operand is already the same as the type that is being cast to.\n\n\n## Recommendation\nAvoid including unnecessary casts.\n\n\n## Example\nIn the following example, casting `i` to an `Integer` is not necessary. It is already an `Integer`.\n\n\n```java\npublic class UnnecessaryCast {\n    public static void main(String[] args) {\n        Integer i = 23;\n        Integer j = (Integer)i;  // AVOID: Redundant cast\n    }\n}\n```\nTo fix the code, delete `(Integer)` on the right-hand side of the assignment on line 4.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unnecessary cast\nA cast is unnecessary if the type of the operand is already the same as the type that is being cast to.\n\n\n## Recommendation\nAvoid including unnecessary casts.\n\n\n## Example\nIn the following example, casting `i` to an `Integer` is not necessary. It is already an `Integer`.\n\n\n```java\npublic class UnnecessaryCast {\n    public static void main(String[] args) {\n        Integer i = 23;\n        Integer j = (Integer)i;  // AVOID: Redundant cast\n    }\n}\n```\nTo fix the code, delete `(Integer)` on the right-hand side of the assignment on line 4.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/redundant-cast",
                    "name": "java/redundant-cast",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/UnnecessaryCast.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unnecessary cast"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit' may cause finalizers to be run on live objects, leading to erratic behavior or deadlock."
                    },
                    "help": {
                      "markdown": "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n",
                      "text": "# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n"
                    },
                    "id": "java/run-finalizers-on-exit",
                    "name": "java/run-finalizers-on-exit",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToRunFinalizersOnExit.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dangerous runFinalizersOnExit"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Files in which most of the lines are similar to those in another file make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly similar file\nWhen most of the lines in one file have corresponding \"similar\" lines in one or more other files, the files themselves are regarded as *mostly similar*. Two lines are defined as similar if they are either identical or contain only very minor differences.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nConsider whether the differences are deliberate or a result of an inconsistent update to one of the clones. If the latter, then treating the files as completely duplicate and eliminating all but one (while preserving any corrections or new features that may have been introduced) is the best course. If two files serve genuinely different purposes but almost all of their lines are the same, that can be a sign that there is a missing level of abstraction. Can some of the shared code be extracted into methods (perhaps with additional parameters, to cover the differences in behavior)? Should it be moved into a utility class or file that is accessible to all current implementations, or should a new level of abstraction be introduced?\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly similar file\nWhen most of the lines in one file have corresponding \"similar\" lines in one or more other files, the files themselves are regarded as *mostly similar*. Two lines are defined as similar if they are either identical or contain only very minor differences.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nConsider whether the differences are deliberate or a result of an inconsistent update to one of the clones. If the latter, then treating the files as completely duplicate and eliminating all but one (while preserving any corrections or new features that may have been introduced) is the best course. If two files serve genuinely different purposes but almost all of their lines are the same, that can be a sign that there is a missing level of abstraction. Can some of the shared code be extracted into methods (perhaps with additional parameters, to cover the differences in behavior)? Should it be moved into a utility class or file that is accessible to all current implementations, or should a new level of abstraction be introduced?\n\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/similar-file",
                    "name": "java/similar-file",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlySimilarFile.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly similar file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Methods in which most of the lines are duplicated in another method make code more difficult to understand and introduce a risk of changes being made to only one copy."
                    },
                    "help": {
                      "markdown": "# Mostly duplicate method\nWhen most of the lines in one method are duplicated in one or more other methods, the methods themselves are regarded as *mostly duplicate* or *similar*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated methods are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many lines between two methods, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies.\n\n* If the two methods serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways of encapsulating the commonality and sharing it while retaining the differences in functionality. Perhaps the method can be moved to a single place and given an additional parameter, allowing it to cover all use cases. Alternatively, there may be a common pre-processing or post-processing step that can be extracted to its own (shared) method, leaving only the specific parts in the existing methods. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Extract method\", \"Change method signature\", \"Pull up\" or \"Extract supertype\".\n* If the two methods serve the same purpose and are different only as a result of inconsistent updates then treat the methods as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates. Callers of the removed methods should be updated to call the remaining method instead.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n",
                      "text": "# Mostly duplicate method\nWhen most of the lines in one method are duplicated in one or more other methods, the methods themselves are regarded as *mostly duplicate* or *similar*.\n\nCode duplication in general is highly undesirable for a range of reasons. The artificially inflated amount of code is more difficult to understand, and sequences of similar but subtly different lines can mask the real purpose or intention behind them. Also, there is always a risk that only one of several copies of the code is updated to address a defect or add a feature.\n\n\n## Recommendation\nAlthough completely duplicated methods are rare, they are usually a sign of a simple oversight (or deliberate copy/paste) by a developer. Usually the required solution is to remove all but one of them.\n\nIt is more common to see duplication of many lines between two methods, leaving just a few that are actually different. Decide whether the differences are intended or the result of an inconsistent update to one of the copies.\n\n* If the two methods serve different purposes but many of their lines are duplicated, this indicates that there is a missing level of abstraction. Look for ways of encapsulating the commonality and sharing it while retaining the differences in functionality. Perhaps the method can be moved to a single place and given an additional parameter, allowing it to cover all use cases. Alternatively, there may be a common pre-processing or post-processing step that can be extracted to its own (shared) method, leaving only the specific parts in the existing methods. Modern IDEs may provide refactoring support for this sort of issue, usually with the names \"Extract method\", \"Change method signature\", \"Pull up\" or \"Extract supertype\".\n* If the two methods serve the same purpose and are different only as a result of inconsistent updates then treat the methods as completely duplicate. Determine the most up-to-date and correct version of the code and eliminate all near duplicates. Callers of the removed methods should be updated to call the remaining method instead.\n\n## References\n* E. Juergens, F. Deissenboeck, B. Hummel, S. Wagner. *Do code clones matter?* Proceedings of the 31st International Conference on Software Engineering, 485-495, 2009.\n"
                    },
                    "id": "java/similar-method",
                    "name": "java/similar-method",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/external/MostlyDuplicateMethod.ql",
                      "tags": [
                        "duplicate-code",
                        "maintainability",
                        "non-attributable",
                        "statistical",
                        "testability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Mostly duplicate method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using autowiring in Spring beans may make it difficult to maintain large projects."
                    },
                    "help": {
                      "markdown": "# Avoid autowiring\nUsing Spring autowiring can make it difficult to see what beans get passed to constructors or setters. The Spring Framework Reference documentation cites the following disadvantages of autowiring:\n\n* Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire so-called *simple* properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by design.\n* Autowiring is less exact than explicit wiring. Although ... Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.\n* Wiring information may not be available to tools that may generate documentation from a Spring container.\n* Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.\n\n## Recommendation\nThe Spring Framework Reference documentation suggests the following ways to address problems with autowired beans:\n\n* Abandon autowiring in favor of explicit wiring.\n* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`.\n* Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to true.\n* If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration.\n\n## Example\nThe following example shows a bean, `autoWiredOrderService`, that is defined using autowiring, and an improved version of the bean, `orderService`, that is defined using explicit wiring.\n\n\n```xml\n<!--AVOID: Using autowiring makes it difficult to see the dependencies of the bean-->\n<bean id=\"autoWiredOrderService\"\n        class=\"documentation.examples.spring.OrderService\"\n        autowire=\"byName\"/>\n\n<!--GOOD: Explicitly specifying the properties of the bean documents its dependencies\n    and makes the bean configuration easier to maintain-->\n<bean id=\"orderService\"\n        class=\"documentation.examples.spring.OrderService\">\n        <property name=\"DAO\">\n            <idref bean=\"dao\"/>\n        </property>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.5.1 Limitations and disadvantages of autowiring](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-autowired-exceptions).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n",
                      "text": "# Avoid autowiring\nUsing Spring autowiring can make it difficult to see what beans get passed to constructors or setters. The Spring Framework Reference documentation cites the following disadvantages of autowiring:\n\n* Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire so-called *simple* properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by design.\n* Autowiring is less exact than explicit wiring. Although ... Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.\n* Wiring information may not be available to tools that may generate documentation from a Spring container.\n* Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.\n\n## Recommendation\nThe Spring Framework Reference documentation suggests the following ways to address problems with autowired beans:\n\n* Abandon autowiring in favor of explicit wiring.\n* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`.\n* Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to true.\n* If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration.\n\n## Example\nThe following example shows a bean, `autoWiredOrderService`, that is defined using autowiring, and an improved version of the bean, `orderService`, that is defined using explicit wiring.\n\n\n```xml\n<!--AVOID: Using autowiring makes it difficult to see the dependencies of the bean-->\n<bean id=\"autoWiredOrderService\"\n        class=\"documentation.examples.spring.OrderService\"\n        autowire=\"byName\"/>\n\n<!--GOOD: Explicitly specifying the properties of the bean documents its dependencies\n    and makes the bean configuration easier to maintain-->\n<bean id=\"orderService\"\n        class=\"documentation.examples.spring.OrderService\">\n        <property name=\"DAO\">\n            <idref bean=\"dao\"/>\n        </property>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.5.1 Limitations and disadvantages of autowiring](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-autowired-exceptions).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n"
                    },
                    "id": "java/spring/autowiring",
                    "name": "java/spring/autowiring",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/AvoidAutowiring.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Avoid autowiring"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using 'id' instead of 'name' to name a Spring bean enables the XML parser to perform additional checks."
                    },
                    "help": {
                      "markdown": "# Use id instead of name\nTo name a Spring bean, it is best to use the `id` attribute instead of the `name` attribute. Using the `id` attribute enables the XML parser to perform additional checks (for example, checking if the `id` in a `ref` attribute is an actual `id` of an XML element).\n\n\n## Recommendation\nUse the `id` attribute instead of the `name` attribute when naming a bean.\n\n\n## Example\nIn the following example, the `dao` bean is shown using the `name` attribute, which allows a typo to go undetected because the XML parser does not check `name`. In contrast, using the `id` attribute allows the XML parser to catch the typo.\n\n\n```xml\n<!--AVOID: Using the 'name' attribute disables checking of bean references at XML parse time-->\n<bean name=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser cannot catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n\n\n<!--GOOD: Using the 'id' attribute enables checking of bean references at XML parse time-->\n<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser can catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.3.1 Naming beans](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-beanname).\n* W3C: [3.3.1 Attribute Types](http://www.w3.org/TR/REC-xml/#sec-attribute-types).\n",
                      "text": "# Use id instead of name\nTo name a Spring bean, it is best to use the `id` attribute instead of the `name` attribute. Using the `id` attribute enables the XML parser to perform additional checks (for example, checking if the `id` in a `ref` attribute is an actual `id` of an XML element).\n\n\n## Recommendation\nUse the `id` attribute instead of the `name` attribute when naming a bean.\n\n\n## Example\nIn the following example, the `dao` bean is shown using the `name` attribute, which allows a typo to go undetected because the XML parser does not check `name`. In contrast, using the `id` attribute allows the XML parser to catch the typo.\n\n\n```xml\n<!--AVOID: Using the 'name' attribute disables checking of bean references at XML parse time-->\n<bean name=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser cannot catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n\n\n<!--GOOD: Using the 'id' attribute enables checking of bean references at XML parse time-->\n<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<!--The XML parser can catch this typo-->\n\t<property name=\"dao\" ref=\"da0\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.3.1 Naming beans](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-beanname).\n* W3C: [3.3.1 Attribute Types](http://www.w3.org/TR/REC-xml/#sec-attribute-types).\n"
                    },
                    "id": "java/spring/bean-id",
                    "name": "java/spring/bean-id",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseIdInsteadOfName.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use id instead of name"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using a type name instead of an index number in a Spring 'constructor-arg' element improves readability."
                    },
                    "help": {
                      "markdown": "# Use constructor-arg types instead of index\nUsing type matching instead of index matching in a Spring `constructor-arg` element produces a more readable bean definition and is less vulnerable to being broken by a change to the constructor of the bean's underlying class. Index matching should be used only if type matching is not sufficient to remove ambiguity in the constructor arguments.\n\n\n## Recommendation\nThe bean definition's `constructor-arg` elements should use type matching instead of index matching.\n\n\n## Example\nThe following example shows a bean, `billingService1`, whose `constructor-arg` elements use index matching, and an improved version of the bean, `billingService2`, whose `constructor-arg` elements use type matching.\n\n\n```xml\n<!--AVOID: Using explicit constructor indices makes the bean configuration\n           vulnerable to changes to the constructor-->\n<bean id=\"billingService1\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg index=\"0\" value=\"John Doe\"/>\n    <constructor-arg index=\"1\" ref=\"dao\"/>\n</bean>\n\n<!--GOOD: Using type matching makes the bean configuration more robust to changes in\n    the constructor-->\n<bean id=\"billingService2\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg ref=\"dao\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"Jane Doe\"/>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=2).\n",
                      "text": "# Use constructor-arg types instead of index\nUsing type matching instead of index matching in a Spring `constructor-arg` element produces a more readable bean definition and is less vulnerable to being broken by a change to the constructor of the bean's underlying class. Index matching should be used only if type matching is not sufficient to remove ambiguity in the constructor arguments.\n\n\n## Recommendation\nThe bean definition's `constructor-arg` elements should use type matching instead of index matching.\n\n\n## Example\nThe following example shows a bean, `billingService1`, whose `constructor-arg` elements use index matching, and an improved version of the bean, `billingService2`, whose `constructor-arg` elements use type matching.\n\n\n```xml\n<!--AVOID: Using explicit constructor indices makes the bean configuration\n           vulnerable to changes to the constructor-->\n<bean id=\"billingService1\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg index=\"0\" value=\"John Doe\"/>\n    <constructor-arg index=\"1\" ref=\"dao\"/>\n</bean>\n\n<!--GOOD: Using type matching makes the bean configuration more robust to changes in\n    the constructor-->\n<bean id=\"billingService2\" class=\"documentation.examples.spring.BillingService\">\n    <constructor-arg ref=\"dao\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"Jane Doe\"/>\n</bean>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection).\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=2).\n"
                    },
                    "id": "java/spring/constructor-arg-index",
                    "name": "java/spring/constructor-arg-index",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/DontUseConstructorArgIndex.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use constructor-arg types instead of index"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "When using the Spring Framework, using setter injection instead of constructor injection is more flexible, especially when several properties are optional."
                    },
                    "help": {
                      "markdown": "# Use setter injection instead of constructor injection\nWhen you use the Spring Framework, using setter injection instead of constructor injection is more flexible, particularly for Spring beans with a large number of optional properties. Constructor injection should be used only on required bean properties; using constructor injection on optional bean properties requires a large number of constructors to handle different combinations of properties.\n\nAlthough the generally accepted best practice is to use constructor injection for mandatory dependencies, and setter injection for optional dependencies, the `@Required` annotation allows you to forgo constructor injection completely. Using the `@Required` annotation on a setter method makes the framework check that a dependency is injected using that method.\n\n\n## Recommendation\nUse setter injection in bean configurations, marking required properties with the `@Required` annotation. It makes it easier to accommodate a large number of optional properties, and makes the bean more flexible by allowing for re-injection of dependencies.\n\n\n## Example\nThe following example shows a bean that is defined using constructor injection. The bean configuration is followed by the class definition.\n\n\n```xml\n<!--AVOID: Using constructor args for optional parameters requires one constructor per combination\nof properties. This leads to a large number of constructors in the bean class.-->\n<bean id=\"chart1\" class=\"documentation.examples.spring.WrongChartMaker\">\n\t<constructor-arg ref=\"customTrend\"/>\n\t<constructor-arg ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart1'\npublic class WrongChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic WrongChartMaker() {}\n\n\t// Each combination of the optional parameters must be represented by a constructor.\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(TrendRenderer customTrendRenderer) {\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer, \n\t\t\t\t\t\t\tTrendRenderer customTrendRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n}\n```\nThe following example shows how the same bean can be defined using setter injection instead. Again, the bean configuration is followed by the class definition.\n\n\n```xml\n<!--GOOD: Using setter injection requires only one setter for each property.-->\n<bean id=\"chart2\" class=\"documentation.examples.spring.ChartMaker\">\n\t<property name=\"axisRenderer\" ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart2'\npublic class ChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic ChartMaker() {}\n\t\n\tpublic void setAxisRenderer(AxisRenderer axisRenderer) {\n\t\tthis.axisRenderer = axisRenderer;\n\t}\n\t\n\tpublic void setTrendRenderer(TrendRenderer trendRenderer) {\n\t\tthis.trendRenderer = trendRenderer;\n\t}\n}\n```\n\n## References\n* Martin Fowler: [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html).\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection), [3.4.1.2 Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n* SpringSource: [Setter injection versus constructor injection and the use of @Required](https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/).\n",
                      "text": "# Use setter injection instead of constructor injection\nWhen you use the Spring Framework, using setter injection instead of constructor injection is more flexible, particularly for Spring beans with a large number of optional properties. Constructor injection should be used only on required bean properties; using constructor injection on optional bean properties requires a large number of constructors to handle different combinations of properties.\n\nAlthough the generally accepted best practice is to use constructor injection for mandatory dependencies, and setter injection for optional dependencies, the `@Required` annotation allows you to forgo constructor injection completely. Using the `@Required` annotation on a setter method makes the framework check that a dependency is injected using that method.\n\n\n## Recommendation\nUse setter injection in bean configurations, marking required properties with the `@Required` annotation. It makes it easier to accommodate a large number of optional properties, and makes the bean more flexible by allowing for re-injection of dependencies.\n\n\n## Example\nThe following example shows a bean that is defined using constructor injection. The bean configuration is followed by the class definition.\n\n\n```xml\n<!--AVOID: Using constructor args for optional parameters requires one constructor per combination\nof properties. This leads to a large number of constructors in the bean class.-->\n<bean id=\"chart1\" class=\"documentation.examples.spring.WrongChartMaker\">\n\t<constructor-arg ref=\"customTrend\"/>\n\t<constructor-arg ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart1'\npublic class WrongChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic WrongChartMaker() {}\n\n\t// Each combination of the optional parameters must be represented by a constructor.\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(TrendRenderer customTrendRenderer) {\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n\t\n\tpublic WrongChartMaker(AxisRenderer customAxisRenderer, \n\t\t\t\t\t\t\tTrendRenderer customTrendRenderer) {\n\t\tthis.axisRenderer = customAxisRenderer;\n\t\tthis.trendRenderer = customTrendRenderer;\n\t}\n}\n```\nThe following example shows how the same bean can be defined using setter injection instead. Again, the bean configuration is followed by the class definition.\n\n\n```xml\n<!--GOOD: Using setter injection requires only one setter for each property.-->\n<bean id=\"chart2\" class=\"documentation.examples.spring.ChartMaker\">\n\t<property name=\"axisRenderer\" ref=\"customAxis\"/>\n</bean>\n```\n\n```java\n// Class for bean 'chart2'\npublic class ChartMaker {\n\tprivate AxisRenderer axisRenderer = new DefaultAxisRenderer();\n\tprivate TrendRenderer trendRenderer = new DefaultTrendRenderer();\n\t\n\tpublic ChartMaker() {}\n\t\n\tpublic void setAxisRenderer(AxisRenderer axisRenderer) {\n\t\tthis.axisRenderer = axisRenderer;\n\t}\n\t\n\tpublic void setTrendRenderer(TrendRenderer trendRenderer) {\n\t\tthis.trendRenderer = trendRenderer;\n\t}\n}\n```\n\n## References\n* Martin Fowler: [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html).\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n* Spring Framework Reference Documentation 3.0: [3.4.1.1 Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-constructor-injection), [3.4.1.2 Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n* SpringSource: [Setter injection versus constructor injection and the use of @Required](https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/).\n"
                    },
                    "id": "java/spring/constructor-injection",
                    "name": "java/spring/constructor-injection",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseSetterInjection.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use setter injection instead of constructor injection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Putting 'import' statements before bean definitions in a Spring bean configuration file makes it easier to immediately see all the file's dependencies."
                    },
                    "help": {
                      "markdown": "# Imports should come before bean definitions\nPutting `import` statements at the top of Spring XML bean definition files is good practice because they give a quick summary of the file's dependencies, and can even be used to document the general architecture of a system.\n\n\n## Recommendation\nMake sure that all `import` statements are at the top of the `<beans>` section of a Spring XML bean definition file.\n\n\n## Example\nThe following example shows a `<beans>` section of a Spring XML bean definition file in which an `import` statement is in the middle, and a `<beans>` section in which all the `import` statements are at the top.\n\n\n```xml\n<beans>\n    <import resource=\"services.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    \n    <!--AVOID: Imports in the middle of a bean configuration make it difficult\n        to immediately determine the dependencies of the configuration-->\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n\n<beans>\n    <!--GOOD: Having the imports at the top immediately gives an idea of\n        what the dependencies of the configuration are-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n",
                      "text": "# Imports should come before bean definitions\nPutting `import` statements at the top of Spring XML bean definition files is good practice because they give a quick summary of the file's dependencies, and can even be used to document the general architecture of a system.\n\n\n## Recommendation\nMake sure that all `import` statements are at the top of the `<beans>` section of a Spring XML bean definition file.\n\n\n## Example\nThe following example shows a `<beans>` section of a Spring XML bean definition file in which an `import` statement is in the middle, and a `<beans>` section in which all the `import` statements are at the top.\n\n\n```xml\n<beans>\n    <import resource=\"services.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    \n    <!--AVOID: Imports in the middle of a bean configuration make it difficult\n        to immediately determine the dependencies of the configuration-->\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n\n<beans>\n    <!--GOOD: Having the imports at the top immediately gives an idea of\n        what the dependencies of the configuration are-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n    <bean id=\"bean3\" class=\"...\"/>\n    <bean id=\"bean4\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n"
                    },
                    "id": "java/spring/import-location",
                    "name": "java/spring/import-location",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/ImportsFirst.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Imports should come before bean definitions"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Adding 'description' elements to a Spring XML bean definition file is good practice."
                    },
                    "help": {
                      "markdown": "# This bean does not have a description element\nIn a Spring XML bean definition file, adding a `<description>` element to a `<bean>` element or the enclosing `<beans>` element to document the purpose of the bean specification is good practice. A `description` element also has the advantage of making it easier for tools to detect and display the documentation for your bean specifications.\n\n\n## Recommendation\nAdd a `<description>` element either in the `<bean>` element or its enclosing `<beans>` element.\n\n\n## Example\nThe following example shows a Spring XML bean definition file that includes `<description>` elements.\n\n\n```xml\n<beans>\n\t<!--Using a description element makes it easier for tools to pick up\n\t    documentation of the bean configuration-->\n\t<description>\n\tThis file configures the various service beans.\n\t</description>\n\t\n\t<!--You can also put a description element in a bean-->\n\t<bean id=\"baseService\" abstract=\"true\">\n\t\t<description>\n\t\tThis bean defines base properties common to the service beans\n\t\t</description>\n\t\t...\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n\t\n\t<bean id=\"orderService\" \n\t\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n</beans>\n```\n\n## References\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n",
                      "text": "# This bean does not have a description element\nIn a Spring XML bean definition file, adding a `<description>` element to a `<bean>` element or the enclosing `<beans>` element to document the purpose of the bean specification is good practice. A `description` element also has the advantage of making it easier for tools to detect and display the documentation for your bean specifications.\n\n\n## Recommendation\nAdd a `<description>` element either in the `<bean>` element or its enclosing `<beans>` element.\n\n\n## Example\nThe following example shows a Spring XML bean definition file that includes `<description>` elements.\n\n\n```xml\n<beans>\n\t<!--Using a description element makes it easier for tools to pick up\n\t    documentation of the bean configuration-->\n\t<description>\n\tThis file configures the various service beans.\n\t</description>\n\t\n\t<!--You can also put a description element in a bean-->\n\t<bean id=\"baseService\" abstract=\"true\">\n\t\t<description>\n\t\tThis bean defines base properties common to the service beans\n\t\t</description>\n\t\t...\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n\t\n\t<bean id=\"orderService\" \n\t\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\t\tparent=\"baseService\">\n\t\t...\n\t</bean>\n</beans>\n```\n\n## References\n* ONJava: [Twelve Best Practices For Spring XML Configurations](http://onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=3).\n"
                    },
                    "id": "java/spring/missing-bean-description",
                    "name": "java/spring/missing-bean-description",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/NoBeanDescription.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "This bean does not have a description element"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Beans that share similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see."
                    },
                    "help": {
                      "markdown": "# Beans sharing similar properties\nBeans that share a considerable number of similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see.\n\n\n## Recommendation\nTry to move the properties that the bean definitions share to a common parent bean. This reduces repetition in the bean definitions and gives a clearer picture of the system's architecture.\n\n\n## Example\nThe following example shows a configuration file that contains two beans that share several properties with the same values.\n\n\n```xml\n<!--AVOID: 'shippingService' and 'orderService' share several properties with the same values-->\n<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\nThe following example shows how the shared properties have been moved into a parent bean, `baseService`.\n\n\n```xml\n<!--The 'baseService' bean contains common property definitions for services.-->\n<bean id=\"baseService\" abstract=\"true\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n</bean>\n\n<bean id=\"shippingService\" \n\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\tparent=\"baseService\">\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" \n\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\tparent=\"baseService\">\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.2 References to other beans (collaborators)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-ref-element).\n",
                      "text": "# Beans sharing similar properties\nBeans that share a considerable number of similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see.\n\n\n## Recommendation\nTry to move the properties that the bean definitions share to a common parent bean. This reduces repetition in the bean definitions and gives a clearer picture of the system's architecture.\n\n\n## Example\nThe following example shows a configuration file that contains two beans that share several properties with the same values.\n\n\n```xml\n<!--AVOID: 'shippingService' and 'orderService' share several properties with the same values-->\n<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n\t\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\nThe following example shows how the shared properties have been moved into a parent bean, `baseService`.\n\n\n```xml\n<!--The 'baseService' bean contains common property definitions for services.-->\n<bean id=\"baseService\" abstract=\"true\">\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n\t<property name=\"dao\">\n\t\t<ref bean=\"dao\"/>\n\t</property>\n\t<property name=\"registry\">\n\t\t<ref bean=\"basicRegistry\"/>\n\t</property>\n</bean>\n\n<bean id=\"shippingService\" \n\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\tparent=\"baseService\">\n\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n</bean>\n\n<bean id=\"orderService\" \n\t\tclass=\"documentation.examples.spring.OrderService\"\n\t\tparent=\"baseService\">\n\t<property name=\"orderReference\" value=\"8675309\"/>\n</bean>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.2 References to other beans (collaborators)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-ref-element).\n"
                    },
                    "id": "java/spring/missing-parent-bean",
                    "name": "java/spring/missing-parent-bean",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/MissingParentBean.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Beans sharing similar properties"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "Not declaring a setter for a property that is defined in a Spring XML file causes a compilation error."
                    },
                    "help": {
                      "markdown": "# Missing setters for property dependency injection\nThe absence of a matching setter method for a property that is defined in a Spring XML bean causes a validation error when the project is compiled.\n\n\n## Recommendation\nEnsure that there is a setter method in the bean file that matches the property name.\n\n\n## Example\nThe following example shows a bean file in which there is no match for the setter method that is in the class.\n\n\n```xml\n<bean id=\"contentService\" class=\"documentation.examples.spring.ContentService\">\n\t<!--BAD: The setter method in the class is 'setHelper', so this property\n\t         does not match the setter method.-->\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n</bean>\n\n```\nThis is the bean class.\n\n\n```java\n// bean class\npublic class ContentService {\n\tprivate TransactionHelper helper;\n\n\t// This method does not match the property in the bean file.\n\tpublic void setHelper(TransactionHelper helper) {\n\t\tthis.helper = helper;\n\t}\n}\n\n```\nThe property `transactionHelper` should instead have the name `helper`.\n\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.2 Setter-based dependency injection](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n",
                      "text": "# Missing setters for property dependency injection\nThe absence of a matching setter method for a property that is defined in a Spring XML bean causes a validation error when the project is compiled.\n\n\n## Recommendation\nEnsure that there is a setter method in the bean file that matches the property name.\n\n\n## Example\nThe following example shows a bean file in which there is no match for the setter method that is in the class.\n\n\n```xml\n<bean id=\"contentService\" class=\"documentation.examples.spring.ContentService\">\n\t<!--BAD: The setter method in the class is 'setHelper', so this property\n\t         does not match the setter method.-->\n\t<property name=\"transactionHelper\">\n\t\t<ref bean=\"transactionHelper\"/>\n\t</property>\n</bean>\n\n```\nThis is the bean class.\n\n\n```java\n// bean class\npublic class ContentService {\n\tprivate TransactionHelper helper;\n\n\t// This method does not match the property in the bean file.\n\tpublic void setHelper(TransactionHelper helper) {\n\t\tthis.helper = helper;\n\t}\n}\n\n```\nThe property `transactionHelper` should instead have the name `helper`.\n\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.1.2 Setter-based dependency injection](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-setter-injection).\n"
                    },
                    "id": "java/spring/missing-setter",
                    "name": "java/spring/missing-setter",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/XML%20Configuration%20Errors/MissingSetters.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing setters for property dependency injection"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using local references when referring to Spring beans in the same file allows reference errors to be detected during XML parsing."
                    },
                    "help": {
                      "markdown": "# Use local refs when referring to beans in the same file\nIf at all possible, refer to Spring beans in the same XML file using local references, that is `<idref local=\"targetBean\">`. This requires that the bean being referenced is in the same XML file, and is named using the `id` attribute. Using local references has the advantage of allowing reference errors to be detected during XML parsing, instead of during deployment or instantiation.\n\nFrom the Spring Framework Reference documentation on `idref` elements:\n\n> \\[Using the `idref` tag in a `property` element\\] is preferable to \\[using the bean name in the property's `value` attribute\\], because using the `idref` tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the \\[`name`\\] property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.\n\nAdditionally, if the referenced bean is in the same XML unit, and the bean name is the bean `id`, you can use the `local` attribute, which allows the XML parser itself to validate the bean `id` earlier, at XML document parse time.\n\n\n## Recommendation\nUse a local `idref` when referring to beans in the same XML file. This allows errors to be detected earlier, at XML parse time rather than during instantiation.\n\n\n## Example\nIn the following example, the `shippingService` bean is shown using the `ref` element, which cannot be checked by the XML parser. The `orderService` bean is shown using the `idref` element, which allows the XML parser to find any errors at parse time.\n\n\n```xml\n<beans>\n\t<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t\t<!--AVOID: This form of reference cannot be checked by the XML parser-->\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\t<!--GOOD: This form of reference allows the XML parser to find any errors at parse time-->\n\t\t<property name=\"dao\">\n\t\t\t<idref local=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n",
                      "text": "# Use local refs when referring to beans in the same file\nIf at all possible, refer to Spring beans in the same XML file using local references, that is `<idref local=\"targetBean\">`. This requires that the bean being referenced is in the same XML file, and is named using the `id` attribute. Using local references has the advantage of allowing reference errors to be detected during XML parsing, instead of during deployment or instantiation.\n\nFrom the Spring Framework Reference documentation on `idref` elements:\n\n> \\[Using the `idref` tag in a `property` element\\] is preferable to \\[using the bean name in the property's `value` attribute\\], because using the `idref` tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the \\[`name`\\] property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.\n\nAdditionally, if the referenced bean is in the same XML unit, and the bean name is the bean `id`, you can use the `local` attribute, which allows the XML parser itself to validate the bean `id` earlier, at XML document parse time.\n\n\n## Recommendation\nUse a local `idref` when referring to beans in the same XML file. This allows errors to be detected earlier, at XML parse time rather than during instantiation.\n\n\n## Example\nIn the following example, the `shippingService` bean is shown using the `ref` element, which cannot be checked by the XML parser. The `orderService` bean is shown using the `idref` element, which allows the XML parser to find any errors at parse time.\n\n\n```xml\n<beans>\n\t<bean id=\"shippingService\" class=\"documentation.examples.spring.ShippingService\">\n\t\t<!--AVOID: This form of reference cannot be checked by the XML parser-->\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"orderService\" class=\"documentation.examples.spring.OrderService\">\n\t\t<!--GOOD: This form of reference allows the XML parser to find any errors at parse time-->\n\t\t<property name=\"dao\">\n\t\t\t<idref local=\"dao\"/>\n\t\t</property>\n\t</bean>\n\t\n\t<bean id=\"dao\" class=\"documentation.examples.spring.DAO\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
                    },
                    "id": "java/spring/non-local-reference",
                    "name": "java/spring/non-local-reference",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseLocalRef.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use local refs when referring to beans in the same file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using shortcut forms may make a Spring XML configuration file less cluttered."
                    },
                    "help": {
                      "markdown": "# Use shortcut forms for values\nShortcut forms, introduced in Spring 1.2, allow nested `value` elements to instead be defined as attributes in the enclosing `property` entry. This leads to shorter XML bean configurations that are easier to read.\n\n\n## Recommendation\nWhen possible, use the shortcut form for defining bean property values.\n\nNote that this does *not* apply to `idref` elements, which are the preferred form of referring to another bean. These do not have a shortcut form that can still be checked by the XML parser.\n\n\n## Example\nThe following example shows how a bean that is defined using shortcut forms is more concise than the same bean defined using nested `value` elements.\n\n\n```xml\n<!--AVOID: Using nested 'value' elements can make the configuration file difficult to read-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\">\n\t\t<value>main_service_registry</value>\n\t</constructor-arg>\n\t<property name=\"description\">\n\t\t<value>Top-level registry for services</value>\n\t</property>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>orderService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.OrderService</value>\n\t\t\t</entry>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>billingService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.BillingService</value>\n\t\t\t</entry>\n\t\t</map>\n\t</property>\n</bean>\n\n\n<!--GOOD: Shortcut forms (Spring 1.2) result in more concise bean definitions-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\" value=\"main_service_registry\"/>\n\t<property name=\"description\" value=\"Top-level registry for services\"/>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry key=\"orderService\" value=\"com.foo.bar.OrderService\"/>\n\t\t\t<entry key=\"billingService\" value=\"com.foo.bar.BillingService\"/>\n\t\t</map>\n\t</property>\n</bean>\n\n```\n\n## References\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n",
                      "text": "# Use shortcut forms for values\nShortcut forms, introduced in Spring 1.2, allow nested `value` elements to instead be defined as attributes in the enclosing `property` entry. This leads to shorter XML bean configurations that are easier to read.\n\n\n## Recommendation\nWhen possible, use the shortcut form for defining bean property values.\n\nNote that this does *not* apply to `idref` elements, which are the preferred form of referring to another bean. These do not have a shortcut form that can still be checked by the XML parser.\n\n\n## Example\nThe following example shows how a bean that is defined using shortcut forms is more concise than the same bean defined using nested `value` elements.\n\n\n```xml\n<!--AVOID: Using nested 'value' elements can make the configuration file difficult to read-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\">\n\t\t<value>main_service_registry</value>\n\t</constructor-arg>\n\t<property name=\"description\">\n\t\t<value>Top-level registry for services</value>\n\t</property>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>orderService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.OrderService</value>\n\t\t\t</entry>\n\t\t\t<entry>\n\t\t\t\t<key>\n\t\t\t\t\t<value>billingService</value>\n\t\t\t\t</key>\n\t\t\t\t<value>com.foo.bar.BillingService</value>\n\t\t\t</entry>\n\t\t</map>\n\t</property>\n</bean>\n\n\n<!--GOOD: Shortcut forms (Spring 1.2) result in more concise bean definitions-->\n<bean id=\"serviceRegistry\" class=\"documentation.examples.spring.ServiceRegistry\">\n\t<constructor-arg type=\"java.lang.String\" value=\"main_service_registry\"/>\n\t<property name=\"description\" value=\"Top-level registry for services\"/>\n\t<property name=\"serviceMap\">\n\t\t<map>\n\t\t\t<entry key=\"orderService\" value=\"com.foo.bar.OrderService\"/>\n\t\t\t<entry key=\"billingService\" value=\"com.foo.bar.BillingService\"/>\n\t\t</map>\n\t</property>\n</bean>\n\n```\n\n## References\n* ONJava: [Twelve Best Practices for Spring XML Configurations](http://www.onjava.com/pub/a/onjava/2006/01/25/spring-xml-configuration-best-practices.html?page=1).\n* Spring Framework Reference Documentation 3.0: [3.4.2.1 Straight values (primitives, Strings, and so on)](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-value-element).\n"
                    },
                    "id": "java/spring/non-shortcut-form",
                    "name": "java/spring/non-shortcut-form",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/UseShortcutForms.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Use shortcut forms for values"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A non-abstract Spring bean that is a parent of other beans and specifies an abstract class causes an error during bean instantiation."
                    },
                    "help": {
                      "markdown": "# Non-abstract parent beans should not use an abstract class\nA non-abstract Spring bean that is a parent of other beans must not specify an abstract class. Doing so causes an error during bean instantiation.\n\n\n## Recommendation\nMake sure that a non-abstract bean does not specify an abstract class, by doing one of the following:\n\n* Specify that the bean is also abstract by adding `abstract=\"true\"` to the bean specification.\n* If possible, update the class that is specified by the bean so that it is not abstract.\nYou can also make the XML parent bean definition abstract and remove any references from it to any class (in which case it becomes a pure bean template). Note that, like an abstract class, an abstract bean cannot be used on its own and only provides property and constructor definitions to its children.\n\n\n## Example\nIn the following example, the bean `wrongConnectionPool` is using an abstract class, `ConnectionPool`, which causes an error. Instead, the bean should be declared `abstract`, as shown in the definition of `connectionPool`.\n\n\n```xml\n<beans>\n    <!--BAD: A non-abstract bean should use a concrete class.\n        'ConnectionPool' is an abstract class.-->\n    <bean id=\"wrongConnectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\"/>\n    <bean id=\"appReqPool1\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"wrongConnectionPool\"/>\n\n    <!--GOOD: A bean that specifies an abstract class should be declared 'abstract'.-->\n    <bean id=\"connectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\" abstract=\"true\"/>\n    <bean id=\"appReqPool2\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"connectionPool\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n",
                      "text": "# Non-abstract parent beans should not use an abstract class\nA non-abstract Spring bean that is a parent of other beans must not specify an abstract class. Doing so causes an error during bean instantiation.\n\n\n## Recommendation\nMake sure that a non-abstract bean does not specify an abstract class, by doing one of the following:\n\n* Specify that the bean is also abstract by adding `abstract=\"true\"` to the bean specification.\n* If possible, update the class that is specified by the bean so that it is not abstract.\nYou can also make the XML parent bean definition abstract and remove any references from it to any class (in which case it becomes a pure bean template). Note that, like an abstract class, an abstract bean cannot be used on its own and only provides property and constructor definitions to its children.\n\n\n## Example\nIn the following example, the bean `wrongConnectionPool` is using an abstract class, `ConnectionPool`, which causes an error. Instead, the bean should be declared `abstract`, as shown in the definition of `connectionPool`.\n\n\n```xml\n<beans>\n    <!--BAD: A non-abstract bean should use a concrete class.\n        'ConnectionPool' is an abstract class.-->\n    <bean id=\"wrongConnectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\"/>\n    <bean id=\"appReqPool1\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"wrongConnectionPool\"/>\n\n    <!--GOOD: A bean that specifies an abstract class should be declared 'abstract'.-->\n    <bean id=\"connectionPool\" \n            class=\"documentation.examples.spring.ConnectionPool\" abstract=\"true\"/>\n    <bean id=\"appReqPool2\" class=\"documentation.examples.spring.AppRequestConnectionPool\" \n            parent=\"connectionPool\"/>\n</beans>\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
                    },
                    "id": "java/spring/parent-bean-abstract-class",
                    "name": "java/spring/parent-bean-abstract-class",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Violations%20of%20Best%20Practice/ParentShouldNotUseAbstractClass.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Non-abstract parent beans should not use an abstract class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Too many beans in a file can make the file difficult to understand and maintain."
                    },
                    "help": {
                      "markdown": "# Too many beans in file\nToo many bean definitions in a single file can make the file difficult to understand and maintain. It is also an indication that the architecture of the system is too tightly coupled and can be refactored.\n\n\n## Recommendation\nRefactor related bean definitions into separate files, and compose them using the `<import/>` element.\n\n\n## Example\nThe following example shows a configuration file that imports two other configuration files. These two files were created by refactoring a file that contained too many bean definitions.\n\n\n```xml\n<beans>\n    <!--Compose configuration files by using the 'import' element.-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n",
                      "text": "# Too many beans in file\nToo many bean definitions in a single file can make the file difficult to understand and maintain. It is also an indication that the architecture of the system is too tightly coupled and can be refactored.\n\n\n## Recommendation\nRefactor related bean definitions into separate files, and compose them using the `<import/>` element.\n\n\n## Example\nThe following example shows a configuration file that imports two other configuration files. These two files were created by refactoring a file that contained too many bean definitions.\n\n\n```xml\n<beans>\n    <!--Compose configuration files by using the 'import' element.-->\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n\n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.2.2.1 Composing XML-based configuration metadata](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import).\n"
                    },
                    "id": "java/spring/too-many-beans",
                    "name": "java/spring/too-many-beans",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/TooManyBeans.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Too many beans in file"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Beans that are specified but never used are redundant and should be removed."
                    },
                    "help": {
                      "markdown": "# Beans that are never used within the code\nBean definitions that are specified but are never used are redundant and can be removed. Unused beans make the program harder to understand.\n\nA bean definition is considered to be used if one or more of the following is true:\n\n* The bean is referenced or defined in the `<constructor-arg>` or `<property>` element of a live bean.\n* The bean is injected in to a constructor or method of a live bean due to autowiring. This includes autowiring by annotation (`@Autowired` or `@Inject`), and autowiring configured by the autowired attribute within bean configuration files.\n* The bean is explicitly loaded from a factory bean. It is not always possible to determine when this occurs, because factory beans are loaded using a `String` value, which may contain arbitrary values.\n* The bean is called reflectively by the Spring framework. For example, if the class is a Spring MVC framework controller, it may be called in response to web requests.\n* The bean has a static initializer.\n* The bean is not lazy, and has a constructor or instance initializer that modifies state outside of the bean.\nAny bean which is not used in one or more ways will be marked as \"dead\".\n\n\n## Recommendation\nFirst verify that the bean definition is never used at runtime. In some cases beans may be used in framework-specific ways, or may be loaded by name from a bean factory in a way that is impossible to determine statically.\n\nAfter confirming that the bean is not required, remove the bean. You will also need remove any references to this bean, which may, in turn, require removing other beans or references.\n\n\n## Example\nThe following example shows a configuration file that includes two beans:\n\n\n```xml\n<beans>\n    <!-- This bean is referred to, so is live. -->\n    <bean id=\"petStore\" class=\"org.sample.PetStoreService\"/>\n    <!-- This bean is never referred to, so is dead. -->\n    <bean id=\"clinic\" class=\"org.sample.ClinicService\"/>\n</beans>\n\n```\nThis XML file is loaded with the following Java class:\n\n\n```java\nclass Start {\n\tpublic static void main(String[] args) {\n\t\t// Create a context from the XML file, constructing beans\n\t\tApplicationContext context =\n\t\t    new ClassPathXmlApplicationContext(new String[] {\"services.xml\"});\n\n\t\t// Retrieve the petStore from the context bean factory.\n\t\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\t\t// Use the value\n\t\tList<String> userList = service.getUsernameList();\n\t}\n}\n```\nThis class constructs a Spring `ApplicationContext` using the XML file, then loads the \"petStore\" bean. Given these two files, the \"clinic\" bean will be marked as dead because it is not used in any context, unlike the \"petStore\" bean.\n\n\n## References\n* Spring Framework Reference Documentation 4.2: [6.3 Bean overview](http://docs.spring.io/spring/docs/4.2.3.RELEASE/spring-framework-reference/html/beans.html#beans-definition).\n",
                      "text": "# Beans that are never used within the code\nBean definitions that are specified but are never used are redundant and can be removed. Unused beans make the program harder to understand.\n\nA bean definition is considered to be used if one or more of the following is true:\n\n* The bean is referenced or defined in the `<constructor-arg>` or `<property>` element of a live bean.\n* The bean is injected in to a constructor or method of a live bean due to autowiring. This includes autowiring by annotation (`@Autowired` or `@Inject`), and autowiring configured by the autowired attribute within bean configuration files.\n* The bean is explicitly loaded from a factory bean. It is not always possible to determine when this occurs, because factory beans are loaded using a `String` value, which may contain arbitrary values.\n* The bean is called reflectively by the Spring framework. For example, if the class is a Spring MVC framework controller, it may be called in response to web requests.\n* The bean has a static initializer.\n* The bean is not lazy, and has a constructor or instance initializer that modifies state outside of the bean.\nAny bean which is not used in one or more ways will be marked as \"dead\".\n\n\n## Recommendation\nFirst verify that the bean definition is never used at runtime. In some cases beans may be used in framework-specific ways, or may be loaded by name from a bean factory in a way that is impossible to determine statically.\n\nAfter confirming that the bean is not required, remove the bean. You will also need remove any references to this bean, which may, in turn, require removing other beans or references.\n\n\n## Example\nThe following example shows a configuration file that includes two beans:\n\n\n```xml\n<beans>\n    <!-- This bean is referred to, so is live. -->\n    <bean id=\"petStore\" class=\"org.sample.PetStoreService\"/>\n    <!-- This bean is never referred to, so is dead. -->\n    <bean id=\"clinic\" class=\"org.sample.ClinicService\"/>\n</beans>\n\n```\nThis XML file is loaded with the following Java class:\n\n\n```java\nclass Start {\n\tpublic static void main(String[] args) {\n\t\t// Create a context from the XML file, constructing beans\n\t\tApplicationContext context =\n\t\t    new ClassPathXmlApplicationContext(new String[] {\"services.xml\"});\n\n\t\t// Retrieve the petStore from the context bean factory.\n\t\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\t\t// Use the value\n\t\tList<String> userList = service.getUsernameList();\n\t}\n}\n```\nThis class constructs a Spring `ApplicationContext` using the XML file, then loads the \"petStore\" bean. Given these two files, the \"clinic\" bean will be marked as dead because it is not used in any context, unlike the \"petStore\" bean.\n\n\n## References\n* Spring Framework Reference Documentation 4.2: [6.3 Bean overview](http://docs.spring.io/spring/docs/4.2.3.RELEASE/spring-framework-reference/html/beans.html#beans-definition).\n"
                    },
                    "id": "java/spring/unused-bean",
                    "name": "java/spring/unused-bean",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/UnusedBean.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Beans that are never used within the code"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A bean property that overrides the same property in a parent bean, and has the same contents, is useless."
                    },
                    "help": {
                      "markdown": "# Useless property override\nA property in a child bean that overrides a property with the same name in its parent and has the same contents is useless. This is because the bean inherits the property from its parent anyway.\n\n\n## Recommendation\nIf possible, remove the property in the child bean.\n\n\n## Example\nIn the following example, `registry` is defined in both the parent bean and the child bean. It should be removed from the child bean.\n\n\n```xml\n<beans>\n\t<bean id=\"baseShippingService\" abstract=\"true\">\n\t\t<property name=\"transactionHelper\">\n\t\t\t<ref bean=\"transactionHelper\"/>\n\t\t</property>\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseShippingService\">\n\t\t<!--AVOID: This property is already defined with the same value in the parent bean.-->\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n\t</bean>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n",
                      "text": "# Useless property override\nA property in a child bean that overrides a property with the same name in its parent and has the same contents is useless. This is because the bean inherits the property from its parent anyway.\n\n\n## Recommendation\nIf possible, remove the property in the child bean.\n\n\n## Example\nIn the following example, `registry` is defined in both the parent bean and the child bean. It should be removed from the child bean.\n\n\n```xml\n<beans>\n\t<bean id=\"baseShippingService\" abstract=\"true\">\n\t\t<property name=\"transactionHelper\">\n\t\t\t<ref bean=\"transactionHelper\"/>\n\t\t</property>\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"dao\"/>\n\t\t</property>\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"shippingService\" \n\t\t\tclass=\"documentation.examples.spring.ShippingService\"\n\t\t\tparent=\"baseShippingService\">\n\t\t<!--AVOID: This property is already defined with the same value in the parent bean.-->\n\t\t<property name=\"registry\">\n\t\t\t<ref bean=\"basicRegistry\"/>\n\t\t</property>\n\t\t<property name=\"shippingProvider\" value=\"Federal Parcel Service\"/>\n\t</bean>\n</beans>\n\n```\n\n## References\n* Spring Framework Reference Documentation 3.0: [3.7 Bean definition inheritance](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-child-bean-definitions).\n"
                    },
                    "id": "java/spring/useless-property-override",
                    "name": "java/spring/useless-property-override",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Frameworks/Spring/Architecture/Refactoring%20Opportunities/UselessPropertyOverride.ql",
                      "tags": [
                        "frameworks/spring",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless property override"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Array constants are mutable and can be changed by malicious code or by accident."
                    },
                    "help": {
                      "markdown": "# Array constant vulnerable to change\nConstant values are typically represented by public, static, final fields. When defining several related constants, it is sometimes tempting to define a public, static, final field with an array type, and initialize it with a list of all the different constant values.\n\nHowever, the `final` keyword applies only to the field itself (that is, the array reference), and not to the contents of the array. This means that the field always refers to the same array instance, but each element of the array may be modified freely. This possibly invalidates important assumptions of client code.\n\n\n## Recommendation\nWhere possible, avoid declaring array constants. If there are only a few constant values, consider using a named constant for each one, or defining them in an `enum` type.\n\nIf you genuinely need to refer to a long list of constants with the same name and an index, consider replacing the array constant with a constant of type `List` to which you assign an unmodifiable collection. See the example for ways of achieving this.\n\n\n## Example\nIn the following example, `public static final` applies only to `RGB` itself, not the constants that it contains.\n\n\n```java\npublic class Display {\n\t// AVOID: Array constant is vulnerable to mutation.\n\tpublic static final String[] RGB = {\n\t\t\"FF0000\", \"00FF00\", \"0000FF\"\n\t};\n\t\n\tvoid f() {\n\t\t// Re-assigning the \"constant\" is legal.\n\t\tRGB[0] = \"00FFFF\";\n\t}\n}\n```\nThe following example shows examples of ways to declare constants that avoid this problem.\n\n\n```java\n// Solution 1: Extract to individual constants\npublic class Display {\n    public static final String RED = \"FF0000\";\n    public static final String GREEN = \"00FF00\";\n    public static final String BLUE = \"0000FF\";\n}\n\n// Solution 2: Define constants using in an enum type\npublic enum Display\n{\n    RED (\"FF0000\"), GREEN (\"00FF00\"), BLUE (\"0000FF\");\n\n    private String rgb;\n    private Display(int rgb) {\n        this.rgb = rgb;\n    }\n    public String getRGB(){\n        return rgb;\n    }\n}\n\n// Solution 3: Use an unmodifiable collection\npublic class Display {\n    public static final List<String> RGB =\n            Collections.unmodifiableList(\n                    Arrays.asList(\"FF0000\",\n                            \"00FF00\",\n                            \"0000FF\"));\n}\n\n// Solution 4: Use a utility method\npublic class Utils {\n    public static <T> List<T> constList(T... values) {\n        return Collections.unmodifiableList(\n                Arrays.asList(values));\n    }\n}\n\npublic class Display {\n    public static final List<String> RGB =\n            Utils.constList(\"FF0000\", \"00FF00\", \"0000FF\");\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 70. Addison-Wesley, 2008.\n* Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4).\n* Common Weakness Enumeration: [CWE-582](https://cwe.mitre.org/data/definitions/582.html).\n",
                      "text": "# Array constant vulnerable to change\nConstant values are typically represented by public, static, final fields. When defining several related constants, it is sometimes tempting to define a public, static, final field with an array type, and initialize it with a list of all the different constant values.\n\nHowever, the `final` keyword applies only to the field itself (that is, the array reference), and not to the contents of the array. This means that the field always refers to the same array instance, but each element of the array may be modified freely. This possibly invalidates important assumptions of client code.\n\n\n## Recommendation\nWhere possible, avoid declaring array constants. If there are only a few constant values, consider using a named constant for each one, or defining them in an `enum` type.\n\nIf you genuinely need to refer to a long list of constants with the same name and an index, consider replacing the array constant with a constant of type `List` to which you assign an unmodifiable collection. See the example for ways of achieving this.\n\n\n## Example\nIn the following example, `public static final` applies only to `RGB` itself, not the constants that it contains.\n\n\n```java\npublic class Display {\n\t// AVOID: Array constant is vulnerable to mutation.\n\tpublic static final String[] RGB = {\n\t\t\"FF0000\", \"00FF00\", \"0000FF\"\n\t};\n\t\n\tvoid f() {\n\t\t// Re-assigning the \"constant\" is legal.\n\t\tRGB[0] = \"00FFFF\";\n\t}\n}\n```\nThe following example shows examples of ways to declare constants that avoid this problem.\n\n\n```java\n// Solution 1: Extract to individual constants\npublic class Display {\n    public static final String RED = \"FF0000\";\n    public static final String GREEN = \"00FF00\";\n    public static final String BLUE = \"0000FF\";\n}\n\n// Solution 2: Define constants using in an enum type\npublic enum Display\n{\n    RED (\"FF0000\"), GREEN (\"00FF00\"), BLUE (\"0000FF\");\n\n    private String rgb;\n    private Display(int rgb) {\n        this.rgb = rgb;\n    }\n    public String getRGB(){\n        return rgb;\n    }\n}\n\n// Solution 3: Use an unmodifiable collection\npublic class Display {\n    public static final List<String> RGB =\n            Collections.unmodifiableList(\n                    Arrays.asList(\"FF0000\",\n                            \"00FF00\",\n                            \"0000FF\"));\n}\n\n// Solution 4: Use a utility method\npublic class Utils {\n    public static <T> List<T> constList(T... values) {\n        return Collections.unmodifiableList(\n                Arrays.asList(values));\n    }\n}\n\npublic class Display {\n    public static final List<String> RGB =\n            Utils.constList(\"FF0000\", \"00FF00\", \"0000FF\");\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, p. 70. Addison-Wesley, 2008.\n* Java Language Specification: [4.12.4 final Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4).\n* Common Weakness Enumeration: [CWE-582](https://cwe.mitre.org/data/definitions/582.html).\n"
                    },
                    "id": "java/static-array",
                    "name": "java/static-array",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/StaticArray.ql",
                      "tags": [
                        "external/cwe/cwe-582",
                        "maintainability",
                        "modularity"
                      ]
                    },
                    "shortDescription": {
                      "text": "Array constant vulnerable to change"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Writing to a static field from an instance method is prone to race conditions unless you use synchronization. In addition, it makes it difficult to keep the static state consistent and affects code readability."
                    },
                    "help": {
                      "markdown": "# Static field written by instance method\nA static field represents state shared between all instances of a particular class. Typically, static methods are provided to manipulate this static state, and it is bad practice to modify the static state of a class from an instance method (or from a constructor).\n\nThere are several reasons why this is bad practice. It can be very difficult to keep the static state consistent when there are multiple instances through which it could be modified. Such modifications represent a readability issue: most programmers would expect a static method to affect static state, and an instance method to affect instance state.\n\n\n## Recommendation\nIf the field should be an instance field, ensure that it does not have a `static` modifier.\n\nIf the field does have to be static, evaluate the assumptions in the code. Does the field really have to be modified directly in an instance method? It might be better to access the field from within static methods, so that any concerns about synchronization can be addressed without numerous synchronization statements in the code. Perhaps the field modification is part of the static initialization of the class, and should be moved to a static initializer or method.\n\n\n## Example\nIn the following example, a static field, `customers`, is written to by an instance method, `initialize`. It is entirely reasonable for another developer to assume that an instance method called `initialize` should be called on each new instance, and that is what the code in `Department` does. Unfortunately, the static field is shared between all instances of `Customer`, and so each time `initialize` is called, the old state is lost.\n\n\n```java\npublic class Customer {\n\tprivate static List<Customer> customers;\n\tpublic void initialize() {\n\t\t// AVOID: Static field is written to by instance method.\n\t\tcustomers = new ArrayList<Customer>();\n\t\tregister();\n\t}\n\tpublic static void add(Customer c) {\n\t\tcustomers.add(c);\n\t}\n}\n\n// ...\npublic class Department {\n\tpublic void addCustomer(String name) {\n\t\tCustomer c = new Customer(n);\n\t\t// The following call overwrites the list of customers\n\t\t// stored in 'Customer' (see above).\n\t\tc.initialize();\n\t\tCustomer.add(c);\n\t}\n}\n\n```\nThe solution is to extract the static initialization of `customers` to a static method, where it will happen exactly once.\n\n\n## References\n* Java Language Specification: [8.3.1.1 static Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1).\n",
                      "text": "# Static field written by instance method\nA static field represents state shared between all instances of a particular class. Typically, static methods are provided to manipulate this static state, and it is bad practice to modify the static state of a class from an instance method (or from a constructor).\n\nThere are several reasons why this is bad practice. It can be very difficult to keep the static state consistent when there are multiple instances through which it could be modified. Such modifications represent a readability issue: most programmers would expect a static method to affect static state, and an instance method to affect instance state.\n\n\n## Recommendation\nIf the field should be an instance field, ensure that it does not have a `static` modifier.\n\nIf the field does have to be static, evaluate the assumptions in the code. Does the field really have to be modified directly in an instance method? It might be better to access the field from within static methods, so that any concerns about synchronization can be addressed without numerous synchronization statements in the code. Perhaps the field modification is part of the static initialization of the class, and should be moved to a static initializer or method.\n\n\n## Example\nIn the following example, a static field, `customers`, is written to by an instance method, `initialize`. It is entirely reasonable for another developer to assume that an instance method called `initialize` should be called on each new instance, and that is what the code in `Department` does. Unfortunately, the static field is shared between all instances of `Customer`, and so each time `initialize` is called, the old state is lost.\n\n\n```java\npublic class Customer {\n\tprivate static List<Customer> customers;\n\tpublic void initialize() {\n\t\t// AVOID: Static field is written to by instance method.\n\t\tcustomers = new ArrayList<Customer>();\n\t\tregister();\n\t}\n\tpublic static void add(Customer c) {\n\t\tcustomers.add(c);\n\t}\n}\n\n// ...\npublic class Department {\n\tpublic void addCustomer(String name) {\n\t\tCustomer c = new Customer(n);\n\t\t// The following call overwrites the list of customers\n\t\t// stored in 'Customer' (see above).\n\t\tc.initialize();\n\t\tCustomer.add(c);\n\t}\n}\n\n```\nThe solution is to extract the static initialization of `customers` to a static method, where it will happen exactly once.\n\n\n## References\n* Java Language Specification: [8.3.1.1 static Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1).\n"
                    },
                    "id": "java/static-field-written-by-instance",
                    "name": "java/static-field-written-by-instance",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Statements/StaticFieldWrittenByInstance.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Static field written by instance method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended."
                    },
                    "help": {
                      "markdown": "# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n",
                      "text": "# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
                    },
                    "id": "java/string-buffer-char-init",
                    "name": "java/string-buffer-char-init",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/StringBufferCharInit.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Character passed to StringBuffer or StringBuilder constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Performing string concatenation in a loop that iterates many times may affect performance."
                    },
                    "help": {
                      "markdown": "# String concatenation in loop\nWhen string concatenation is performed using the \"+\" operator, the compiler translates this operation to a suitable manipulation, possibly constructing several intermediate strings. In general, because strings are immutable, at least one new string has to be constructed to hold the result.\n\nBuilding up a string one piece at a time in a loop requires a new string on every iteration, repeatedly copying longer and longer prefixes to fresh string objects. As a result, performance can be severely degraded.\n\n\n## Recommendation\nWhenever a string is constructed using a loop that iterates more than just a few times, it is usually better to create a `StringBuffer` or `StringBuilder` object and append to that. Because such buffers are based on mutable character arrays, which do not require a new string to be created for each concatenation, they can reduce the cost of repeatedly growing the string.\n\nTo choose between `StringBuffer` and `StringBuilder`, check if the new buffer object can possibly be accessed by several different threads while in use. If multi-thread safety is required, use a `StringBuffer`. For purely local string buffers, you can avoid the overhead of synchronization by using a `StringBuilder`.\n\n\n## Example\nThe following example shows a simple test that measures the time taken to construct a string. It constructs the same string of 65,536 binary digits, character-by-character, first by repeatedly appending to a string, and then by using a `StringBuilder`. The second method is three orders of magnitude faster.\n\n\n```java\npublic class ConcatenationInLoops {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random(123);\n\t\tlong start = System.currentTimeMillis();\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\ts += r.nextInt(2);\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints roughly 4500.\n\n\t\tr = new Random(123);\n\t\tstart = System.currentTimeMillis();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\tsb.append(r.nextInt(2));\n\t\ts = sb.toString();\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints 5.\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 51. Addison-Wesley, 2008.\n* Java API Specification: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n",
                      "text": "# String concatenation in loop\nWhen string concatenation is performed using the \"+\" operator, the compiler translates this operation to a suitable manipulation, possibly constructing several intermediate strings. In general, because strings are immutable, at least one new string has to be constructed to hold the result.\n\nBuilding up a string one piece at a time in a loop requires a new string on every iteration, repeatedly copying longer and longer prefixes to fresh string objects. As a result, performance can be severely degraded.\n\n\n## Recommendation\nWhenever a string is constructed using a loop that iterates more than just a few times, it is usually better to create a `StringBuffer` or `StringBuilder` object and append to that. Because such buffers are based on mutable character arrays, which do not require a new string to be created for each concatenation, they can reduce the cost of repeatedly growing the string.\n\nTo choose between `StringBuffer` and `StringBuilder`, check if the new buffer object can possibly be accessed by several different threads while in use. If multi-thread safety is required, use a `StringBuffer`. For purely local string buffers, you can avoid the overhead of synchronization by using a `StringBuilder`.\n\n\n## Example\nThe following example shows a simple test that measures the time taken to construct a string. It constructs the same string of 65,536 binary digits, character-by-character, first by repeatedly appending to a string, and then by using a `StringBuilder`. The second method is three orders of magnitude faster.\n\n\n```java\npublic class ConcatenationInLoops {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random(123);\n\t\tlong start = System.currentTimeMillis();\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\ts += r.nextInt(2);\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints roughly 4500.\n\n\t\tr = new Random(123);\n\t\tstart = System.currentTimeMillis();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 65536; i++)\n\t\t\tsb.append(r.nextInt(2));\n\t\ts = sb.toString();\n\t\tSystem.out.println(System.currentTimeMillis() - start);  // This prints 5.\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 51. Addison-Wesley, 2008.\n* Java API Specification: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"
                    },
                    "id": "java/string-concatenation-in-loop",
                    "name": "java/string-concatenation-in-loop",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Performance/ConcatenationInLoops.ql",
                      "tags": [
                        "efficiency",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "String concatenation in loop"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling Swing methods from a thread other than the event-dispatching thread may result in multi-threading errors."
                    },
                    "help": {
                      "markdown": "# Thread safety\nBecause Swing components are not thread-safe (that is, they do not support concurrent access from multiple threads), Swing has a rule that states that method calls on Swing components that have been *realized* (see below) must be made from a special thread known as the *event-dispatching thread*. Failure to observe this rule may result in multiple threads accessing a Swing component concurrently, with the potential for deadlocks, race conditions and other errors related to multi-threading.\n\nA component is considered *realized* if its `paint` method has been, or could be, called at this point. Realization is triggered according to the following rules:\n\n* A top-level window is realized if `setVisible(true)`, `show` or `pack` is called on it.\n* Realizing a container realizes the components it contains.\nThere are a few exceptions to the rule. These are documented more fully in \\[The Swing Connection\\] but the key exceptions are:\n\n* It is safe to call the `repaint`, `revalidate` and `invalidate` methods on a Swing component from any thread.\n* It is safe to add and remove listeners from any thread. Therefore, any method of the form `add*Listener` or `remove*Listener` is thread-safe.\n\n## Recommendation\nEnsure that method calls on Swing components are made from the event-dispatching thread. If you need to call a method on a Swing component from another thread, you must do so using the event-dispatching thread. Swing provides a `SwingUtilities` class that you can use to ask the event-dispatching thread to run arbitrary code on your components, by calling one of two methods. Each method takes a `Runnable` as its only argument:\n\n* `SwingUtilities.invokeLater` asks the event-dispatching thread to run some code and then immediately returns (that is, it is non-blocking). The code is run at some indeterminate time in the future, but the thread that calls `invokeLater` does not wait for it.\n* `SwingUtilities.invokeAndWait` asks the event-dispatching thread to run some code and then waits for it to complete (that is, it is blocking).\n\n## Example\nIn the following example, there is a call from the main thread to a method, `setTitle`, on the `MyFrame` object after the object has been realized by the `setVisible(true)` call. This represents an unsafe call to a Swing method from a thread other than the event-dispatching thread.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class BrokenSwing {\n    private static void doStuff(MyFrame frame) {\n        // BAD: Direct call to a Swing component after it has been realized\n        frame.setTitle(\"Title\");\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n```\nIn the following modified example, the call to `setTitle` is instead called from within a call to `invokeLater`.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class GoodSwing {\n    private static void doStuff(final MyFrame frame) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                // GOOD: Call to Swing component made via the\n                // event-dispatching thread using 'invokeLater'\n                frame.setTitle(\"Title\");\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, p.28. O'Reilly, 1999.\n* Java Developer's Journal: [Building Thread-Safe GUIs with Swing](http://www.comscigate.com/JDJ/archives/0605/ford/index.html).\n* The Java Tutorials: [Concurrency in Swing](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html).\n* The Swing Connection: [Threads and Swing](https://www.comp.nus.edu.sg/~cs3283/ftp/Java/swingConnect/archive/tech_topics_arch/threads/threads.html).\n",
                      "text": "# Thread safety\nBecause Swing components are not thread-safe (that is, they do not support concurrent access from multiple threads), Swing has a rule that states that method calls on Swing components that have been *realized* (see below) must be made from a special thread known as the *event-dispatching thread*. Failure to observe this rule may result in multiple threads accessing a Swing component concurrently, with the potential for deadlocks, race conditions and other errors related to multi-threading.\n\nA component is considered *realized* if its `paint` method has been, or could be, called at this point. Realization is triggered according to the following rules:\n\n* A top-level window is realized if `setVisible(true)`, `show` or `pack` is called on it.\n* Realizing a container realizes the components it contains.\nThere are a few exceptions to the rule. These are documented more fully in \\[The Swing Connection\\] but the key exceptions are:\n\n* It is safe to call the `repaint`, `revalidate` and `invalidate` methods on a Swing component from any thread.\n* It is safe to add and remove listeners from any thread. Therefore, any method of the form `add*Listener` or `remove*Listener` is thread-safe.\n\n## Recommendation\nEnsure that method calls on Swing components are made from the event-dispatching thread. If you need to call a method on a Swing component from another thread, you must do so using the event-dispatching thread. Swing provides a `SwingUtilities` class that you can use to ask the event-dispatching thread to run arbitrary code on your components, by calling one of two methods. Each method takes a `Runnable` as its only argument:\n\n* `SwingUtilities.invokeLater` asks the event-dispatching thread to run some code and then immediately returns (that is, it is non-blocking). The code is run at some indeterminate time in the future, but the thread that calls `invokeLater` does not wait for it.\n* `SwingUtilities.invokeAndWait` asks the event-dispatching thread to run some code and then waits for it to complete (that is, it is blocking).\n\n## Example\nIn the following example, there is a call from the main thread to a method, `setTitle`, on the `MyFrame` object after the object has been realized by the `setVisible(true)` call. This represents an unsafe call to a Swing method from a thread other than the event-dispatching thread.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class BrokenSwing {\n    private static void doStuff(MyFrame frame) {\n        // BAD: Direct call to a Swing component after it has been realized\n        frame.setTitle(\"Title\");\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n```\nIn the following modified example, the call to `setTitle` is instead called from within a call to `invokeLater`.\n\n\n```java\nclass MyFrame extends JFrame {\n    public MyFrame() {\n        setSize(640, 480);\n        setTitle(\"BrokenSwing\");\n    }\n}\n\npublic class GoodSwing {\n    private static void doStuff(final MyFrame frame) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                // GOOD: Call to Swing component made via the\n                // event-dispatching thread using 'invokeLater'\n                frame.setTitle(\"Title\");\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        MyFrame frame = new MyFrame();\n        frame.setVisible(true);\n        doStuff(frame);\n    }\n}\n\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, p.28. O'Reilly, 1999.\n* Java Developer's Journal: [Building Thread-Safe GUIs with Swing](http://www.comscigate.com/JDJ/archives/0605/ford/index.html).\n* The Java Tutorials: [Concurrency in Swing](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html).\n* The Swing Connection: [Threads and Swing](https://www.comp.nus.edu.sg/~cs3283/ftp/Java/swingConnect/archive/tech_topics_arch/threads/threads.html).\n"
                    },
                    "id": "java/swing-thread-safety",
                    "name": "java/swing-thread-safety",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/Swing/ThreadSafety.ql",
                      "tags": [
                        "frameworks/swing",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Thread safety"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A test case class whose test methods are not recognized by JUnit 3.8 as valid declarations is not used."
                    },
                    "help": {
                      "markdown": "# Test case has no tests\nA JUnit 3.8 test case class (that is, a non-abstract class that is a subtype of `junit.framework.TestCase`) should contain test methods, and each method must have the correct signature to be used by JUnit. Otherwise, the JUnit test runner will fail with an error message.\n\n\n## Recommendation\nEnsure that the test case class contains some test methods, and that each method is of the form:\n\n```\n\npublic void testXXX() {\n  // ...\n}\n\n```\nNote that the method name must start with `test` and the method must not take any parameters.\n\nIf the test case class is intended strictly for subclassing by other test case classes, consider making it abstract to document this intention. It will then no longer be flagged by this query.\n\nThis rule applies only to JUnit 3.8-style test case classes. In JUnit 4, it is no longer required to extend `junit.framework.TestCase` to mark test methods.\n\n\n## Example\nIn the following example, `TestCaseNoTests38` does not contain any valid JUnit test methods. However, `MyTests` contains two valid JUnit test methods.\n\n\n```java\n// BAD: This test case class does not have any valid JUnit 3.8 test methods.\npublic class TestCaseNoTests38 extends TestCase {\n\t// This is not a test case because it does not start with 'test'.\n\tpublic void simpleTest() {\n\t\t//...\n\t}\n\n\t// This is not a test case because it takes two parameters.\n\tpublic void testNotEquals(int i, int j) {\n\t\tassertEquals(i != j, true);\n\t}\n\n\t// This is recognized as a test, but causes JUnit to fail\n\t// when run because it is not public.\n\tvoid testEquals() {\n\t\t//...\n\t}\n}\n\n// GOOD: This test case class correctly declares test methods.\npublic class MyTests extends TestCase {\n\tpublic void testEquals() {\n\t\tassertEquals(1, 1);\n\t}\n\tpublic void testNotEquals() {\n\t\tassertFalse(1 == 2);\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# Test case has no tests\nA JUnit 3.8 test case class (that is, a non-abstract class that is a subtype of `junit.framework.TestCase`) should contain test methods, and each method must have the correct signature to be used by JUnit. Otherwise, the JUnit test runner will fail with an error message.\n\n\n## Recommendation\nEnsure that the test case class contains some test methods, and that each method is of the form:\n\n```\n\npublic void testXXX() {\n  // ...\n}\n\n```\nNote that the method name must start with `test` and the method must not take any parameters.\n\nIf the test case class is intended strictly for subclassing by other test case classes, consider making it abstract to document this intention. It will then no longer be flagged by this query.\n\nThis rule applies only to JUnit 3.8-style test case classes. In JUnit 4, it is no longer required to extend `junit.framework.TestCase` to mark test methods.\n\n\n## Example\nIn the following example, `TestCaseNoTests38` does not contain any valid JUnit test methods. However, `MyTests` contains two valid JUnit test methods.\n\n\n```java\n// BAD: This test case class does not have any valid JUnit 3.8 test methods.\npublic class TestCaseNoTests38 extends TestCase {\n\t// This is not a test case because it does not start with 'test'.\n\tpublic void simpleTest() {\n\t\t//...\n\t}\n\n\t// This is not a test case because it takes two parameters.\n\tpublic void testNotEquals(int i, int j) {\n\t\tassertEquals(i != j, true);\n\t}\n\n\t// This is recognized as a test, but causes JUnit to fail\n\t// when run because it is not public.\n\tvoid testEquals() {\n\t\t//...\n\t}\n}\n\n// GOOD: This test case class correctly declares test methods.\npublic class MyTests extends TestCase {\n\tpublic void testEquals() {\n\t\tassertEquals(1, 1);\n\t}\n\tpublic void testNotEquals() {\n\t\tassertFalse(1 == 2);\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/test-case-without-tests",
                    "name": "java/test-case-without-tests",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/TestCaseNoTests.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Test case has no tests"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A comment that contains 'TODO' or 'FIXME' may indicate code that is incomplete or broken, or it may highlight an ambiguity in the software's specification."
                    },
                    "help": {
                      "markdown": "# TODO/FIXME comments\nA comment that includes the word `TODO` or `FIXME` often marks a part of the code that is incomplete or broken, or highlights ambiguities in the software's specification.\n\nFor example, this list of comments is typical of those found in real programs:\n\n* `TODO: move this code somewhere else`\n* `FIXME: handle this case`\n* `FIXME: find a better solution to this workaround`\n* `TODO: test this`\n\n## Recommendation\nIt is very important that `TODO` or `FIXME` comments are not just removed from the code. Each of them must be addressed in some way.\n\nSimpler comments can usually be immediately addressed by fixing the code, adding a test, doing some refactoring, or clarifying the intended behavior of a feature.\n\nIn contrast, larger issues may require discussion, and a significant amount of work to address. In these cases it is a good idea to move the comment to an issue-tracking system, so that the issue can be tracked and prioritized relative to other defects and feature requests.\n\n\n## References\n* Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).\n* Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags), [Issue tracking system](http://en.wikipedia.org/wiki/Issue_tracking_system).\n* Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).\n",
                      "text": "# TODO/FIXME comments\nA comment that includes the word `TODO` or `FIXME` often marks a part of the code that is incomplete or broken, or highlights ambiguities in the software's specification.\n\nFor example, this list of comments is typical of those found in real programs:\n\n* `TODO: move this code somewhere else`\n* `FIXME: handle this case`\n* `FIXME: find a better solution to this workaround`\n* `TODO: test this`\n\n## Recommendation\nIt is very important that `TODO` or `FIXME` comments are not just removed from the code. Each of them must be addressed in some way.\n\nSimpler comments can usually be immediately addressed by fixing the code, adding a test, doing some refactoring, or clarifying the intended behavior of a feature.\n\nIn contrast, larger issues may require discussion, and a significant amount of work to address. In these cases it is a good idea to move the comment to an issue-tracking system, so that the issue can be tracked and prioritized relative to other defects and feature requests.\n\n\n## References\n* Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).\n* Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags), [Issue tracking system](http://en.wikipedia.org/wiki/Issue_tracking_system).\n* Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).\n"
                    },
                    "id": "java/todo-comment",
                    "name": "java/todo-comment",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Comments/TodoComments.ql",
                      "tags": [
                        "external/cwe/cwe-546",
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "TODO/FIXME comments"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A method named 'tostring' may be intended to be named 'toString'."
                    },
                    "help": {
                      "markdown": "# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n",
                      "text": "# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"
                    },
                    "id": "java/tostring-typo",
                    "name": "java/tostring-typo",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/ToStringTypo.ql",
                      "tags": [
                        "maintainability",
                        "naming",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Typo in toString"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Using the 'transient' field modifier in non-serializable classes has no effect."
                    },
                    "help": {
                      "markdown": "# Transient field in non-serializable class\nThe `transient` modifier is used to identify fields that are not part of the persistent state of the class. As such, it only has an effect if the class is serializable, and has no purpose in a non-serializable class.\n\nA field that is marked `transient` in a non-serializable class is likely to be a leftover from a time when the class was serializable.\n\n\n## Recommendation\nIf the class is non-serializable, leave out the `transient` modifier. Otherwise, use the modifier, and ensure that the class (or a relevant supertype) implements `Serializable`.\n\n\n## Example\nThe following example shows two fields that are declared `transient`. The modifier only has an effect in the class that implements `Serializable`.\n\n\n```java\nclass State {\n\t// The 'transient' modifier has no effect here because\n\t// the 'State' class does not implement 'Serializable'.\n\tprivate transient int[] stateData;\n}\n\nclass PersistentState implements Serializable {\n\tprivate int[] stateData;\n\t// The 'transient' modifier indicates that this field is not part of\n\t// the persistent state and should therefore not be serialized.\n\tprivate transient int[] cachedComputedData;\n}\n```\n\n## References\n* Java Language Specification: [8.3.1.3 transient Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.3).\n* Java Object Serialization Specification: [1.5 Defining Serializable Fields for a Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#defining-serializable-fields-for-a-class).\n",
                      "text": "# Transient field in non-serializable class\nThe `transient` modifier is used to identify fields that are not part of the persistent state of the class. As such, it only has an effect if the class is serializable, and has no purpose in a non-serializable class.\n\nA field that is marked `transient` in a non-serializable class is likely to be a leftover from a time when the class was serializable.\n\n\n## Recommendation\nIf the class is non-serializable, leave out the `transient` modifier. Otherwise, use the modifier, and ensure that the class (or a relevant supertype) implements `Serializable`.\n\n\n## Example\nThe following example shows two fields that are declared `transient`. The modifier only has an effect in the class that implements `Serializable`.\n\n\n```java\nclass State {\n\t// The 'transient' modifier has no effect here because\n\t// the 'State' class does not implement 'Serializable'.\n\tprivate transient int[] stateData;\n}\n\nclass PersistentState implements Serializable {\n\tprivate int[] stateData;\n\t// The 'transient' modifier indicates that this field is not part of\n\t// the persistent state and should therefore not be serialized.\n\tprivate transient int[] cachedComputedData;\n}\n```\n\n## References\n* Java Language Specification: [8.3.1.3 transient Fields](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.3).\n* Java Object Serialization Specification: [1.5 Defining Serializable Fields for a Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#defining-serializable-fields-for-a-class).\n"
                    },
                    "id": "java/transient-not-serializable",
                    "name": "java/transient-not-serializable",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/TransientNotSerializable.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Transient field in non-serializable class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "If 'C' is a final class, a type bound such as '? extends C' is confusing because it implies that 'C' has subclasses, but a final class has no subclasses."
                    },
                    "help": {
                      "markdown": "# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n",
                      "text": "# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n"
                    },
                    "id": "java/type-bound-extends-final",
                    "name": "java/type-bound-extends-final",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/TypeVarExtendsFinalType.ql",
                      "tags": [
                        "maintainability",
                        "readability",
                        "types"
                      ]
                    },
                    "shortDescription": {
                      "text": "Type bound extends a final class"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Testing whether 'this' is an instance of a derived type introduces a dependency cycle between the type of 'this' and the target type."
                    },
                    "help": {
                      "markdown": "# Dubious type test of 'this'\nTesting whether `this` is an instance of a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, the need for every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by testing the type of `this`.\n\n\n```java\npublic class DubiousTypeTestOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\t// violation\n\t\t\t\tthis.d = (Derived)this;\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n",
                      "text": "# Dubious type test of 'this'\nTesting whether `this` is an instance of a derived type creates a dependency cycle. Derived types already depend on their parent type and the cast creates a dependency in the other direction.\n\nDependency cycles should be avoided as they make code both difficult to read and difficult to test. In addition, a type should not know about its specific descendants, even though it may impose some constraints on them as a group (for example, the need for every derived type to implement a method with a specific signature).\n\n\n## Recommendation\nThe base and derived types should be redesigned so that there is no need for the base type to depend on the types deriving from it.\n\n\n## Example\nIn this example, `BadBase` introduces a dependency cycle with `Derived` by testing the type of `this`.\n\n\n```java\npublic class DubiousTypeTestOfThis {\n\tprivate static class BadBase {\n\t\tprivate Derived d;\n\n\t\tpublic BadBase(Derived d) {\n\t\t\tif(d != null && this instanceof Derived)\t// violation\n\t\t\t\tthis.d = (Derived)this;\n\t\t\telse\n\t\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tprivate static class Derived extends BadBase {\n\t\tpublic Derived() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {}\n}\n```\n"
                    },
                    "id": "java/type-test-of-this",
                    "name": "java/type-test-of-this",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/DubiousTypeTestOfThis.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Dubious type test of 'this'"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A field that is never assigned a value (except possibly 'null') just returns the default value when it is read."
                    },
                    "help": {
                      "markdown": "# Field is never assigned a non-null value\nIt is good practice to initialize every field in a constructor explicitly. A field that is never assigned any value (except possibly `null`) just returns the default value when it is read, or throws a `NullPointerException`.\n\n\n## Recommendation\nA field whose value is always `null` (or the corresponding default value for primitive types, for example `0`) is not particularly useful. Ensure that the code contains an assignment or initialization for each field. To help satisfy this rule, it is good practice to explicitly initialize every field in the constructor, even if the default value is acceptable.\n\nIf the field is genuinely never expected to hold a non-default value, check the statements that read the field and ensure that they are not making incorrect assumptions about the value of the field. Consider completely removing the field and rewriting the statements that read it, as appropriate.\n\n\n## Example\nIn the following example, the private field `name` is not initialized in the constructor (and thus is implicitly set to `null`), but there is a getter method to access it.\n\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n```\nTherefore, the following code throws a `NullPointerException`:\n\n```java\nPerson p = new Person(\"Arthur Dent\", 30);\nint l = p.getName().length();\n```\nTo fix the code, `name` should be initialized in the constructor by adding the following line: `this.name = name;`\n\n",
                      "text": "# Field is never assigned a non-null value\nIt is good practice to initialize every field in a constructor explicitly. A field that is never assigned any value (except possibly `null`) just returns the default value when it is read, or throws a `NullPointerException`.\n\n\n## Recommendation\nA field whose value is always `null` (or the corresponding default value for primitive types, for example `0`) is not particularly useful. Ensure that the code contains an assignment or initialization for each field. To help satisfy this rule, it is good practice to explicitly initialize every field in the constructor, even if the default value is acceptable.\n\nIf the field is genuinely never expected to hold a non-default value, check the statements that read the field and ensure that they are not making incorrect assumptions about the value of the field. Consider completely removing the field and rewriting the statements that read it, as appropriate.\n\n\n## Example\nIn the following example, the private field `name` is not initialized in the constructor (and thus is implicitly set to `null`), but there is a getter method to access it.\n\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n```\nTherefore, the following code throws a `NullPointerException`:\n\n```java\nPerson p = new Person(\"Arthur Dent\", 30);\nint l = p.getName().length();\n```\nTo fix the code, `name` should be initialized in the constructor by adding the following line: `this.name = name;`\n\n"
                    },
                    "id": "java/unassigned-field",
                    "name": "java/unassigned-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/NonAssignedFields.ql",
                      "tags": [
                        "external/cwe/cwe-457",
                        "maintainability",
                        "reliability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Field is never assigned a non-null value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Use of a single underscore character as an identifier results in a compiler error with Java source level 9 or later."
                    },
                    "help": {
                      "markdown": "# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n",
                      "text": "# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n"
                    },
                    "id": "java/underscore-identifier",
                    "name": "java/underscore-identifier",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Compatibility/JDK9/UnderscoreIdentifier.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Underscore used as identifier"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that throws an exception but does not have a Javadoc tag for the exception affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for thrown exception\nA public method or constructor that throws an exception but does not have a Javadoc tag for the exception makes an API more difficult to understand and maintain. This includes checked exceptions in `throws` clauses and unchecked exceptions that are explicitly thrown in `throw` statements.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each thrown exception.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 44 and 62. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for thrown exception\nA public method or constructor that throws an exception but does not have a Javadoc tag for the exception makes an API more difficult to understand and maintain. This includes checked exceptions in `throws` clauses and unchecked exceptions that are explicitly thrown in `throw` statements.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each thrown exception.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 44 and 62. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-exception",
                    "name": "java/undocumented-exception",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocThrows.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for thrown exception"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that does not have a Javadoc comment affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for public method or constructor\nA public method or constructor that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic methods and constructors should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public methods and constructors.\n\nThe Javadoc comment should describe *what* the method or constructor does rather than *how*, to allow for any potential implementation change that is invisible to users of an API. It should include the following:\n\n* A description of any preconditions or postconditions\n* Javadoc tag elements that describe any parameters, return value, and thrown exceptions\n* Any other important aspects such as side-effects and thread safety\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the method does, its parameter, return value, and thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for public method or constructor\nA public method or constructor that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic methods and constructors should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public methods and constructors.\n\nThe Javadoc comment should describe *what* the method or constructor does rather than *how*, to allow for any potential implementation change that is invisible to users of an API. It should include the following:\n\n* A description of any preconditions or postconditions\n* Javadoc tag elements that describe any parameters, return value, and thrown exceptions\n* Any other important aspects such as side-effects and thread safety\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the method does, its parameter, return value, and thrown exception.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-function",
                    "name": "java/undocumented-function",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocMethods.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for public method or constructor"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method or constructor that does not have a Javadoc tag for each parameter affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for parameter\nA public method or constructor that does not have a Javadoc tag for each parameter makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each parameter.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's parameter.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for parameter\nA public method or constructor that does not have a Javadoc tag for each parameter makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method or constructor should include a Javadoc tag element that describes each parameter.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's parameter.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-parameter",
                    "name": "java/undocumented-parameter",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocParameters.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public method that does not have a Javadoc tag for its return value affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for method return value\nA public method that does not have a Javadoc tag for its return value makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method should include a Javadoc tag element that describes the return value.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's return value.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for method return value\nA public method that does not have a Javadoc tag for its return value makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nThe Javadoc comment for a method should include a Javadoc tag element that describes the return value.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains the method's return value.\n\n\n```java\n/**\n * Extracts the user's name from the input arguments.\n *\n * Precondition: 'args' should contain at least one element, the user's name.\n *\n * @param  args            the command-line arguments.\n * @return                 the user's name (the first command-line argument).\n * @throws NoNameException if 'args' contains no element.\n */\npublic static String getName(String[] args) throws NoNameException {\n\tif(args.length == 0) {\n\t\tthrow new NoNameException();\n\t} else {\n\t\treturn args[0];\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-return-value",
                    "name": "java/undocumented-return-value",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocReturnValues.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for method return value"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A public class or interface that does not have a Javadoc comment affects maintainability."
                    },
                    "help": {
                      "markdown": "# Missing Javadoc for public type\nA public class or interface that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic classes and interfaces should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public classes and interfaces.\n\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the class does, its author, and version.\n\n\n```java\n/**\n * The Stack class represents a last-in-first-out stack of objects. \n *\n * @author  Joseph Bergin\n * @version 1.0, May 2000\n * Note that this version is not thread safe. \n */\npublic class Stack {\n// ...\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n",
                      "text": "# Missing Javadoc for public type\nA public class or interface that does not have a Javadoc comment makes an API more difficult to understand and maintain.\n\n\n## Recommendation\nPublic classes and interfaces should be documented to make an API usable. For the purpose of code maintainability, it is also advisable to document non-public classes and interfaces.\n\nDocumentation for users of an API should be written using the standard Javadoc format. This can be accessed conveniently by users of an API from within standard IDEs, and can be transformed automatically into HTML format.\n\n\n## Example\nThe following example shows a good Javadoc comment, which clearly explains what the class does, its author, and version.\n\n\n```java\n/**\n * The Stack class represents a last-in-first-out stack of objects. \n *\n * @author  Joseph Bergin\n * @version 1.0, May 2000\n * Note that this version is not thread safe. \n */\npublic class Stack {\n// ...\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 44. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html), [Requirements for Writing Java API Specifications](https://www.oracle.com/java/technologies/javase/api-specifications.html).\n"
                    },
                    "id": "java/undocumented-type",
                    "name": "java/undocumented-type",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/MissingJavadocTypes.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Missing Javadoc for public type"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An interface method that is incompatible with a protected method on 'java.lang.Object' means that the interface cannot be implemented."
                    },
                    "help": {
                      "markdown": "# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n",
                      "text": "# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n"
                    },
                    "id": "java/unimplementable-interface",
                    "name": "java/unimplementable-interface",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/InterfaceCannotBeImplemented.ql",
                      "tags": [
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Interface cannot be implemented"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Javadoc @param tags that do not match any parameters in the method or constructor or any type parameters of the annotated class are confusing."
                    },
                    "help": {
                      "markdown": "# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n",
                      "text": "# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n"
                    },
                    "id": "java/unknown-javadoc-parameter",
                    "name": "java/unknown-javadoc-parameter",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Advisory/Documentation/SpuriousJavadocParam.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Spurious Javadoc @param tags"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Calling 'this.getClass().getResource()' may yield unexpected results if called from a subclass in another package."
                    },
                    "help": {
                      "markdown": "# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n",
                      "text": "# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n"
                    },
                    "id": "java/unsafe-get-resource",
                    "name": "java/unsafe-get-resource",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Implementation%20Hiding/GetClassGetResource.ql",
                      "tags": [
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unsafe use of getResource"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "error"
                    },
                    "fullDescription": {
                      "text": "A collection or map whose contents are never queried or accessed is useless."
                    },
                    "help": {
                      "markdown": "# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-container",
                    "name": "java/unused-container",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Collections/WriteOnlyContainer.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Container contents are never accessed"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A field that is never used is probably unnecessary."
                    },
                    "help": {
                      "markdown": "# Unused field\nA field that is neither public nor protected and never accessed is typically a leftover from old refactorings or a sign of incomplete or pending code changes.\n\nThis rule does not apply to a field in a serializable class because it may be accessed during serialization and deserialization.\n\nFields annotated with `@SuppressWarnings(\"unused\")` are also not reported.\n\n\n## Recommendation\nIf an unused field is a leftover from old refactorings, you should just remove it. If it indicates incomplete or pending code changes, finish making the changes and remove the field if it is not needed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused field\nA field that is neither public nor protected and never accessed is typically a leftover from old refactorings or a sign of incomplete or pending code changes.\n\nThis rule does not apply to a field in a serializable class because it may be accessed during serialization and deserialization.\n\nFields annotated with `@SuppressWarnings(\"unused\")` are also not reported.\n\n\n## Recommendation\nIf an unused field is a leftover from old refactorings, you should just remove it. If it indicates incomplete or pending code changes, finish making the changes and remove the field if it is not needed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-field",
                    "name": "java/unused-field",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnusedField.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused field"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A format call with a format string that refers to fewer arguments than the number of supplied arguments will silently ignore the additional arguments."
                    },
                    "help": {
                      "markdown": "# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n",
                      "text": "# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"
                    },
                    "id": "java/unused-format-argument",
                    "name": "java/unused-format-argument",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Likely%20Typos/UnusedFormatArg.ql",
                      "tags": [
                        "external/cwe/cwe-685",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused format argument"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A redundant 'import' statement introduces unnecessary and undesirable dependencies."
                    },
                    "help": {
                      "markdown": "# Unnecessary import\nAn `import` statement that is not necessary (because no part of the file that it is in uses any imported type) should be avoided. Although importing too many types does not affect performance, redundant `import` statements introduce unnecessary and undesirable dependencies in the code. If an imported type is renamed or deleted, the source code cannot be compiled because the `import` statement cannot be resolved.\n\nUnnecessary `import` statements are often an indication of incomplete refactoring.\n\n\n## Recommendation\nAvoid including an `import` statement that is not needed. Many modern IDEs have automated support for doing this, typically under the name 'Organize imports'. This sorts the `import` statements and removes any that are not used, and it is good practice to run such a command before every commit.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unnecessary import\nAn `import` statement that is not necessary (because no part of the file that it is in uses any imported type) should be avoided. Although importing too many types does not affect performance, redundant `import` statements introduce unnecessary and undesirable dependencies in the code. If an imported type is renamed or deleted, the source code cannot be compiled because the `import` statement cannot be resolved.\n\nUnnecessary `import` statements are often an indication of incomplete refactoring.\n\n\n## Recommendation\nAvoid including an `import` statement that is not needed. Many modern IDEs have automated support for doing this, typically under the name 'Organize imports'. This sorts the `import` statements and removes any that are not used, and it is good practice to run such a command before every commit.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-import",
                    "name": "java/unused-import",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/legacy/UnnecessaryImport.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unnecessary import"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "An unused label for a loop or 'switch' statement is either redundant or indicates incorrect 'break' or 'continue' statements."
                    },
                    "help": {
                      "markdown": "# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-label",
                    "name": "java/unused-label",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/UnusedLabel.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused label"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Parameters that are not used add unnecessary complexity to an interface."
                    },
                    "help": {
                      "markdown": "# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-parameter",
                    "name": "java/unused-parameter",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/DeadCode/UselessParameter.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless parameter"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A non-public class or interface that is not used anywhere in the program wastes programmer resources."
                    },
                    "help": {
                      "markdown": "# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/unused-reference-type",
                    "name": "java/unused-reference-type",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/DeadRefTypes.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Unused classes and interfaces"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic number, which is used instead of an existing named constant, makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic numbers: use defined constant\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nReplace the magic number with the existing named constant. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `internalPort`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint internalPort = 8080;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, internalPort, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'PORT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic numbers: use defined constant\nA *magic number* is a numeric literal (for example, `8080`, `2048`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic numbers because:\n\n* A number in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic number represents the number of guests allowed, adding one more guest means that you must change every occurrence of the magic number.\n\n## Recommendation\nReplace the magic number with the existing named constant. This overcomes the two problems with magic numbers:\n\n* A named constant (such as `MAX_GUESTS`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the number in only one place.\n\n## Example\nThe following example shows a magic number `internalPort`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint internalPort = 8080;  // AVOID: Magic number\n\n\t\tnew MagicConstants().serve(IP, internalPort, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  // Use 'PORT' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/use-number-constant",
                    "name": "java/use-number-constant",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicNumbersUseConstant.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic numbers: use defined constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A magic string, which is used instead of an existing named constant, makes code less readable and maintainable."
                    },
                    "help": {
                      "markdown": "# Magic strings: use defined constant\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nReplace the magic string with the existing named constant. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `internalIp`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString internalIp = \"127.0.0.1\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(internalIp, PORT, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  //Use 'IP' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n",
                      "text": "# Magic strings: use defined constant\nA *magic string* is a string literal (for example, `\"SELECT\"`, `\"127.0.0.1\"`) that is used in the middle of a block of code without explanation. It is considered bad practice to use magic strings because:\n\n* A string in isolation can be difficult for other programmers to understand.\n* It can be difficult to update the code if the requirements change. For example, if the magic string represents a protocol, changing the protocol means that you must change every occurrence of the protocol.\n\n## Recommendation\nReplace the magic string with the existing named constant. This overcomes the two problems with magic strings:\n\n* A named constant (such as `SMTP_HELO`) is more easily understood by other programmers.\n* Using the same named constant in many places makes the code much easier to update if the requirements change, because you have to update the string in only one place.\n\n## Example\nThe following example shows a magic string `internalIp`. This should be replaced by the existing named constant, as shown in the fixed version.\n\n\n```java\n// Problem version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString internalIp = \"127.0.0.1\";  // AVOID: Magic string\n\n\t\tnew MagicConstants().serve(internalIp, PORT, USERNAME, TIMEOUT);\n\t}\n}\n\n\n// Fixed version\npublic class MagicConstants\n{\n\tpublic static final String IP = \"127.0.0.1\";\n\tpublic static final int PORT = 8080;\n\tpublic static final String USERNAME = \"test\";\n\tpublic static final int TIMEOUT = 60000;\n\n\tpublic void serve(String ip, int port, String user, int timeout) {\n\t\t// ...\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MagicConstants().serve(IP, PORT, USERNAME, TIMEOUT);  //Use 'IP' constant\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.G25. Prentice Hall, 2008.\n"
                    },
                    "id": "java/use-string-constant",
                    "name": "java/use-string-constant",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Magic%20Constants/MagicStringsUseConstant.ql",
                      "tags": [
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Magic strings: use defined constant"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "A method forwards calls to another method of the same name that is not called independently."
                    },
                    "help": {
                      "markdown": "# Pointless forwarding method\nIf a class contains two distinct methods of the same name such that:\n\n1. One method is only ever called from the other method.\n1. The calling method calls only the other method and nothing else.\nThen the first method is no more than a forwarding method for the second and the two methods can probably be merged.\n\nThere are several advantages to doing this:\n\n* It reduces the cognitive overhead involved in keeping track of the various different overloaded forms of a method.\n* If both methods are public, it simplifies the API of their containing class, making it more discoverable to other programmers.\n* It makes it clearer to other programmers that certain methods are called and other methods are not.\n\n## Example\nIn this example, the two `print` methods in `Bad` can be merged, as one is simply a forwarder for the other. The two classes `Better1` and `Better2` show two alternative ways of merging the methods.\n\n\n```java\nimport static java.lang.System.out;\n\npublic class PointlessForwardingMethod {\n\tprivate static class Bad {\n\t\t// Violation: This print does nothing but forward to the other one, which is not\n\t\t// called independently.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tprint(firstName + \" \" + lastName);\n\t\t}\n\n\t\tpublic void print(String fullName) {\n\t\t\tout.println(\"Pointless forwarding methods are bad, \"  + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better1 {\n\t\t// Better: Merge the methods, using local variables to replace the parameters in\n\t\t// the original version.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tString fullName = firstName + \" \" + lastName;\n\t\t\tout.println(\"Pointless forwarding methods are bad, \" + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better2 {\n\t\t// Better: If there's no complicated logic, you can often remove the extra\n\t\t// variables entirely.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tout.println(\n\t\t\t\t\"Pointless forwarding methods are bad, \" +\n\t\t\t\tfirstName + \" \" + lastName + \"...\"\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Bad().print(\"Foo\", \"Bar\");\n\t\tnew Better1().print(\"Foo\", \"Bar\");\n\t\tnew Better2().print(\"Foo\", \"Bar\");\n\t}\n}\n```\n",
                      "text": "# Pointless forwarding method\nIf a class contains two distinct methods of the same name such that:\n\n1. One method is only ever called from the other method.\n1. The calling method calls only the other method and nothing else.\nThen the first method is no more than a forwarding method for the second and the two methods can probably be merged.\n\nThere are several advantages to doing this:\n\n* It reduces the cognitive overhead involved in keeping track of the various different overloaded forms of a method.\n* If both methods are public, it simplifies the API of their containing class, making it more discoverable to other programmers.\n* It makes it clearer to other programmers that certain methods are called and other methods are not.\n\n## Example\nIn this example, the two `print` methods in `Bad` can be merged, as one is simply a forwarder for the other. The two classes `Better1` and `Better2` show two alternative ways of merging the methods.\n\n\n```java\nimport static java.lang.System.out;\n\npublic class PointlessForwardingMethod {\n\tprivate static class Bad {\n\t\t// Violation: This print does nothing but forward to the other one, which is not\n\t\t// called independently.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tprint(firstName + \" \" + lastName);\n\t\t}\n\n\t\tpublic void print(String fullName) {\n\t\t\tout.println(\"Pointless forwarding methods are bad, \"  + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better1 {\n\t\t// Better: Merge the methods, using local variables to replace the parameters in\n\t\t// the original version.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tString fullName = firstName + \" \" + lastName;\n\t\t\tout.println(\"Pointless forwarding methods are bad, \" + fullName + \"...\");\n\t\t}\n\t}\n\n\tprivate static class Better2 {\n\t\t// Better: If there's no complicated logic, you can often remove the extra\n\t\t// variables entirely.\n\t\tpublic void print(String firstName, String lastName) {\n\t\t\tout.println(\n\t\t\t\t\"Pointless forwarding methods are bad, \" +\n\t\t\t\tfirstName + \" \" + lastName + \"...\"\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Bad().print(\"Foo\", \"Bar\");\n\t\tnew Better1().print(\"Foo\", \"Bar\");\n\t\tnew Better2().print(\"Foo\", \"Bar\");\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-forwarding-method",
                    "name": "java/useless-forwarding-method",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Dead%20Code/PointlessForwardingMethod.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Pointless forwarding method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Checking whether an expression is null when that expression cannot possibly be null is useless."
                    },
                    "help": {
                      "markdown": "# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n",
                      "text": "# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
                    },
                    "id": "java/useless-null-check",
                    "name": "java/useless-null-check",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessNullCheck.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "maintainability",
                        "useless-code"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless null check"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "note"
                    },
                    "fullDescription": {
                      "text": "Calling 'toString' on a string is redundant."
                    },
                    "help": {
                      "markdown": "# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n",
                      "text": "# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n"
                    },
                    "id": "java/useless-tostring-call",
                    "name": "java/useless-tostring-call",
                    "properties": {
                      "precision": "high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Violations%20of%20Best%20Practice/Undesirable%20Calls/CallsToStringToString.ql",
                      "tags": [
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless toString on String"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Testing whether a derived type is an instance of its base type is unnecessary."
                    },
                    "help": {
                      "markdown": "# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n",
                      "text": "# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-type-test",
                    "name": "java/useless-type-test",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessTypeTest.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless type test"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Upcasting a derived type to its base type is usually unnecessary."
                    },
                    "help": {
                      "markdown": "# Useless upcast\nIn most situations, casting an instance of a derived type to a base type serves no purpose, since the conversion can be done implicitly. In such cases, the redundant cast can simply be removed. However, an upcast is not redundant in the following situations:\n\n* It is being used to force a call to an overloaded callable that takes a parameter of the base type rather than one of the derived type.\n* It is being used to specify the type to use for the operands of a ternary expression.\nBoth of these special cases are illustrated in the example below. This rule ignores these special cases and highlights upcasts which appear to be redundant.\n\n\n## Recommendation\nRemove the unnecessary upcast to simplify the code.\n\n\n## Example\nThe following code includes an example of a redundant upcast that would be highlighted by this rule. In addition, three examples of upcasts that are required and are ignored by this rule.\n\n\n```java\npublic class UselessUpcast {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tprivate static void Foo(B b) { System.out.println(\"Foo(B)\"); }\n\tprivate static void Foo(D d) { System.out.println(\"Foo(D)\"); }\n\n\tprivate static class Expr {}\n\tprivate static class AddExpr extends Expr {}\n\tprivate static class SubExpr extends Expr {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tB b_ = (B)d;\t// violation: redundant cast, consider removing\n\n\t\tB b = new D();\n\t\tD d_ = (D)b;\t// non-violation: required downcast\n\n\t\tFoo(d);\n\t\tFoo((B)d);\t\t// non-violation: required to call Foo(B)\n\n\t\t// Non-violation: required to specify the type of the ternary operands.\n\t\tExpr e = d != null ? (Expr)new AddExpr() : new SubExpr();\n\t}\n}\n```\n",
                      "text": "# Useless upcast\nIn most situations, casting an instance of a derived type to a base type serves no purpose, since the conversion can be done implicitly. In such cases, the redundant cast can simply be removed. However, an upcast is not redundant in the following situations:\n\n* It is being used to force a call to an overloaded callable that takes a parameter of the base type rather than one of the derived type.\n* It is being used to specify the type to use for the operands of a ternary expression.\nBoth of these special cases are illustrated in the example below. This rule ignores these special cases and highlights upcasts which appear to be redundant.\n\n\n## Recommendation\nRemove the unnecessary upcast to simplify the code.\n\n\n## Example\nThe following code includes an example of a redundant upcast that would be highlighted by this rule. In addition, three examples of upcasts that are required and are ignored by this rule.\n\n\n```java\npublic class UselessUpcast {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tprivate static void Foo(B b) { System.out.println(\"Foo(B)\"); }\n\tprivate static void Foo(D d) { System.out.println(\"Foo(D)\"); }\n\n\tprivate static class Expr {}\n\tprivate static class AddExpr extends Expr {}\n\tprivate static class SubExpr extends Expr {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tB b_ = (B)d;\t// violation: redundant cast, consider removing\n\n\t\tB b = new D();\n\t\tD d_ = (D)b;\t// non-violation: required downcast\n\n\t\tFoo(d);\n\t\tFoo((B)d);\t\t// non-violation: required to call Foo(B)\n\n\t\t// Non-violation: required to specify the type of the ternary operands.\n\t\tExpr e = d != null ? (Expr)new AddExpr() : new SubExpr();\n\t}\n}\n```\n"
                    },
                    "id": "java/useless-upcast",
                    "name": "java/useless-upcast",
                    "properties": {
                      "precision": "low",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Language%20Abuse/UselessUpcast.ql",
                      "tags": [
                        "external/cwe/cwe-561",
                        "language-features",
                        "maintainability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Useless upcast"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may even indicate a bug."
                    },
                    "help": {
                      "markdown": "# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n",
                      "text": "# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n"
                    },
                    "id": "java/whitespace-contradicts-precedence",
                    "name": "java/whitespace-contradicts-precedence",
                    "properties": {
                      "precision": "very-high",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Arithmetic/WhitespaceContradictsPrecedence.ql",
                      "tags": [
                        "external/cwe/cwe-783",
                        "maintainability",
                        "readability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Whitespace contradicts operator precedence"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not detected by JUnit."
                    },
                    "help": {
                      "markdown": "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n",
                      "text": "# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"
                    },
                    "id": "java/wrong-junit-suite-signature",
                    "name": "java/wrong-junit-suite-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/JUnit/BadSuiteMethod.ql",
                      "tags": [
                        "frameworks/junit",
                        "maintainability",
                        "testability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Bad suite method"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but does not use the correct signatures causes the default serialization mechanism to be used."
                    },
                    "help": {
                      "markdown": "# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n",
                      "text": "# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n"
                    },
                    "id": "java/wrong-object-serialization-signature",
                    "name": "java/wrong-object-serialization-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/IncorrectSerializableMethods.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Serialization methods do not match required signature"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "An implementation of 'readResolve' that does not have the signature that is expected by the Java serialization framework is not recognized by the serialization mechanism."
                    },
                    "help": {
                      "markdown": "# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n",
                      "text": "# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n"
                    },
                    "id": "java/wrong-readresolve-signature",
                    "name": "java/wrong-readresolve-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Serialization/ReadResolveObject.ql",
                      "tags": [
                        "language-features",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "ReadResolve must have Object return type, not void"
                    }
                  },
                  {
                    "defaultConfiguration": {
                      "level": "warning"
                    },
                    "fullDescription": {
                      "text": "In a class that extends a Swing or Abstract Window Toolkit event adapter, an event handler that does not have exactly the same name as the event handler that it overrides means that the overridden event handler is not called."
                    },
                    "help": {
                      "markdown": "# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n",
                      "text": "# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n"
                    },
                    "id": "java/wrong-swing-event-adapter-signature",
                    "name": "java/wrong-swing-event-adapter-signature",
                    "properties": {
                      "precision": "medium",
                      "queryURI": "https://github.com/github/codeql/blob/2501a701ad93601b7f892d9f510edb65b7e4a2da/java/ql/src/Likely%20Bugs/Frameworks/Swing/BadlyOverriddenAdapter.ql",
                      "tags": [
                        "frameworks/swing",
                        "maintainability",
                        "reliability"
                      ]
                    },
                    "shortDescription": {
                      "text": "Bad implementation of an event Adapter"
                    }
                  }
                ],
                "semanticVersion": "0.7.5+2501a701ad93601b7f892d9f510edb65b7e4a2da"
              }
            ]
          },
          "versionControlProvenance": [
            {
              "branch": "refs/heads/main",
              "repositoryUri": "https://github.com/octodemo-db/simple-java-project",
              "revisionId": "d70a63d1f5bbdfc3b8c4e838edfee727be5b56ab"
            }
          ]
        }
      ],
      "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
      "version": "2.1.0"
    }
  }
}